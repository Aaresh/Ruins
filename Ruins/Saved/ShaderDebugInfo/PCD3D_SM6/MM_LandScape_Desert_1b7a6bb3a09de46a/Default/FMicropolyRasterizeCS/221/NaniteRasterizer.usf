#line 1 "__UE_FILENAME_SENTINEL__"
uint2 UnpackUlongType(uint64_t Value)
		{
			return uint2(uint(Value), uint(Value >> 32));
		}
precise float MakePrecise(in precise float v) { precise float pv = v; return pv; }
precise float2 MakePrecise(in precise float2 v) { precise float2 pv = v; return pv; }
precise float3 MakePrecise(in precise float3 v) { precise float3 pv = v; return pv; }
precise float4 MakePrecise(in precise float4 v) { precise float4 pv = v; return pv; }
float min3(float a, float b, float c)
{
	return min(a, min(b, c));
}
int min3(int a, int b, int c)
{
	return min(a, min(b, c));
}
uint min3(uint a, uint b, uint c)
{
	return min(a, min(b, c));
}
float2 min3 ( float2 a, float2 b, float2 c) { return float2( min3 (a.x , b.x , c.x ), min3 (a.y , b.y , c.y )); }
float3 min3 ( float3 a, float3 b, float3 c) { return float3( min3 (a.xy, b.xy, c.xy), min3 (a.z , b.z , c.z )); }
float4 min3 ( float4 a, float4 b, float4 c) { return float4( min3 (a.xy, b.xy, c.xy), min3 (a.zw, b.zw, c.zw)); }
int2 min3 ( int2 a, int2 b, int2 c) { return int2( min3 (a.x , b.x , c.x ), min3 (a.y , b.y , c.y )); }
int3 min3 ( int3 a, int3 b, int3 c) { return int3( min3 (a.xy, b.xy, c.xy), min3 (a.z , b.z , c.z )); }
int4 min3 ( int4 a, int4 b, int4 c) { return int4( min3 (a.xy, b.xy, c.xy), min3 (a.zw, b.zw, c.zw)); }
uint2 min3 ( uint2 a, uint2 b, uint2 c) { return uint2( min3 (a.x , b.x , c.x ), min3 (a.y , b.y , c.y )); }
uint3 min3 ( uint3 a, uint3 b, uint3 c) { return uint3( min3 (a.xy, b.xy, c.xy), min3 (a.z , b.z , c.z )); }
uint4 min3 ( uint4 a, uint4 b, uint4 c) { return uint4( min3 (a.xy, b.xy, c.xy), min3 (a.zw, b.zw, c.zw)); }
float max3(float a, float b, float c)
{
	return max(a, max(b, c));
}
int max3(int a, int b, int c)
{
	return max(a, max(b, c));
}
uint max3(uint a, uint b, uint c)
{
	return max(a, max(b, c));
}
float2 max3 ( float2 a, float2 b, float2 c) { return float2( max3 (a.x , b.x , c.x ), max3 (a.y , b.y , c.y )); }
float3 max3 ( float3 a, float3 b, float3 c) { return float3( max3 (a.xy, b.xy, c.xy), max3 (a.z , b.z , c.z )); }
float4 max3 ( float4 a, float4 b, float4 c) { return float4( max3 (a.xy, b.xy, c.xy), max3 (a.zw, b.zw, c.zw)); }
int2 max3 ( int2 a, int2 b, int2 c) { return int2( max3 (a.x , b.x , c.x ), max3 (a.y , b.y , c.y )); }
int3 max3 ( int3 a, int3 b, int3 c) { return int3( max3 (a.xy, b.xy, c.xy), max3 (a.z , b.z , c.z )); }
int4 max3 ( int4 a, int4 b, int4 c) { return int4( max3 (a.xy, b.xy, c.xy), max3 (a.zw, b.zw, c.zw)); }
uint2 max3 ( uint2 a, uint2 b, uint2 c) { return uint2( max3 (a.x , b.x , c.x ), max3 (a.y , b.y , c.y )); }
uint3 max3 ( uint3 a, uint3 b, uint3 c) { return uint3( max3 (a.xy, b.xy, c.xy), max3 (a.z , b.z , c.z )); }
uint4 max3 ( uint4 a, uint4 b, uint4 c) { return uint4( max3 (a.xy, b.xy, c.xy), max3 (a.zw, b.zw, c.zw)); }
bool select_internal(bool    c, bool a, bool b) { return bool (c   ? a.x : b.x); }
bool2 select_internal(bool    c, bool a, bool2 b) { return bool2(c   ? a   : b.x, c   ? a   : b.y); }
bool2 select_internal(bool    c, bool2 a, bool b) { return bool2(c   ? a.x : b  , c   ? a.y : b  ); }
bool2 select_internal(bool    c, bool2 a, bool2 b) { return bool2(c   ? a.x : b.x, c   ? a.y : b.y); }
bool2 select_internal(bool2   c, bool a, bool b) { return bool2(c.x ? a   : b  , c.y ? a   : b  ); }
bool2 select_internal(bool2   c, bool a, bool2 b) { return bool2(c.x ? a   : b.x, c.y ? a   : b.y); }
bool2 select_internal(bool2   c, bool2 a, bool b) { return bool2(c.x ? a.x : b  , c.y ? a.y : b  ); }
bool2 select_internal(bool2   c, bool2 a, bool2 b) { return bool2(c.x ? a.x : b.x, c.y ? a.y : b.y); }
bool3 select_internal(bool    c, bool a, bool3 b) { return bool3(c   ? a   : b.x, c   ? a   : b.y, c   ? a   : b.z); }
bool3 select_internal(bool    c, bool3 a, bool b) { return bool3(c   ? a.x : b  , c   ? a.y : b  , c   ? a.z : b  ); }
bool3 select_internal(bool    c, bool3 a, bool3 b) { return bool3(c   ? a.x : b.x, c   ? a.y : b.y, c   ? a.z : b.z); }
bool3 select_internal(bool3   c, bool a, bool b) { return bool3(c.x ? a   : b  , c.y ? a   : b  , c.z ? a   : b  ); }
bool3 select_internal(bool3   c, bool a, bool3 b) { return bool3(c.x ? a   : b.x, c.y ? a   : b.y, c.z ? a   : b.z); }
bool3 select_internal(bool3   c, bool3 a, bool b) { return bool3(c.x ? a.x : b  , c.y ? a.y : b  , c.z ? a.z : b  ); }
bool3 select_internal(bool3   c, bool3 a, bool3 b) { return bool3(c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z); }
bool4 select_internal(bool    c, bool a, bool4 b) { return bool4(c   ? a   : b.x, c   ? a   : b.y, c   ? a   : b.z, c   ? a   : b.w); }
bool4 select_internal(bool    c, bool4 a, bool b) { return bool4(c   ? a.x : b  , c   ? a.y : b  , c   ? a.z : b  , c   ? a.w : b  ); }
bool4 select_internal(bool    c, bool4 a, bool4 b) { return bool4(c   ? a.x : b.x, c   ? a.y : b.y, c   ? a.z : b.z, c   ? a.w : b.w); }
bool4 select_internal(bool4   c, bool a, bool b) { return bool4(c.x ? a   : b  , c.y ? a   : b  , c.z ? a   : b  , c.w ? a   : b  ); }
bool4 select_internal(bool4   c, bool a, bool4 b) { return bool4(c.x ? a   : b.x, c.y ? a   : b.y, c.z ? a   : b.z, c.w ? a   : b.w); }
bool4 select_internal(bool4   c, bool4 a, bool b) { return bool4(c.x ? a.x : b  , c.y ? a.y : b  , c.z ? a.z : b  , c.w ? a.w : b  ); }
bool4 select_internal(bool4   c, bool4 a, bool4 b) { return bool4(c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z, c.w ? a.w : b.w); }
int select_internal(bool    c, int a, int b) { return int (c   ? a.x : b.x); }
int2 select_internal(bool    c, int a, int2 b) { return int2(c   ? a   : b.x, c   ? a   : b.y); }
int2 select_internal(bool    c, int2 a, int b) { return int2(c   ? a.x : b  , c   ? a.y : b  ); }
int2 select_internal(bool    c, int2 a, int2 b) { return int2(c   ? a.x : b.x, c   ? a.y : b.y); }
int2 select_internal(bool2   c, int a, int b) { return int2(c.x ? a   : b  , c.y ? a   : b  ); }
int2 select_internal(bool2   c, int a, int2 b) { return int2(c.x ? a   : b.x, c.y ? a   : b.y); }
int2 select_internal(bool2   c, int2 a, int b) { return int2(c.x ? a.x : b  , c.y ? a.y : b  ); }
int2 select_internal(bool2   c, int2 a, int2 b) { return int2(c.x ? a.x : b.x, c.y ? a.y : b.y); }
int3 select_internal(bool    c, int a, int3 b) { return int3(c   ? a   : b.x, c   ? a   : b.y, c   ? a   : b.z); }
int3 select_internal(bool    c, int3 a, int b) { return int3(c   ? a.x : b  , c   ? a.y : b  , c   ? a.z : b  ); }
int3 select_internal(bool    c, int3 a, int3 b) { return int3(c   ? a.x : b.x, c   ? a.y : b.y, c   ? a.z : b.z); }
int3 select_internal(bool3   c, int a, int b) { return int3(c.x ? a   : b  , c.y ? a   : b  , c.z ? a   : b  ); }
int3 select_internal(bool3   c, int a, int3 b) { return int3(c.x ? a   : b.x, c.y ? a   : b.y, c.z ? a   : b.z); }
int3 select_internal(bool3   c, int3 a, int b) { return int3(c.x ? a.x : b  , c.y ? a.y : b  , c.z ? a.z : b  ); }
int3 select_internal(bool3   c, int3 a, int3 b) { return int3(c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z); }
int4 select_internal(bool    c, int a, int4 b) { return int4(c   ? a   : b.x, c   ? a   : b.y, c   ? a   : b.z, c   ? a   : b.w); }
int4 select_internal(bool    c, int4 a, int b) { return int4(c   ? a.x : b  , c   ? a.y : b  , c   ? a.z : b  , c   ? a.w : b  ); }
int4 select_internal(bool    c, int4 a, int4 b) { return int4(c   ? a.x : b.x, c   ? a.y : b.y, c   ? a.z : b.z, c   ? a.w : b.w); }
int4 select_internal(bool4   c, int a, int b) { return int4(c.x ? a   : b  , c.y ? a   : b  , c.z ? a   : b  , c.w ? a   : b  ); }
int4 select_internal(bool4   c, int a, int4 b) { return int4(c.x ? a   : b.x, c.y ? a   : b.y, c.z ? a   : b.z, c.w ? a   : b.w); }
int4 select_internal(bool4   c, int4 a, int b) { return int4(c.x ? a.x : b  , c.y ? a.y : b  , c.z ? a.z : b  , c.w ? a.w : b  ); }
int4 select_internal(bool4   c, int4 a, int4 b) { return int4(c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z, c.w ? a.w : b.w); }
float select_internal(bool    c, float a, float b) { return float (c   ? a.x : b.x); }
float2 select_internal(bool    c, float a, float2 b) { return float2(c   ? a   : b.x, c   ? a   : b.y); }
float2 select_internal(bool    c, float2 a, float b) { return float2(c   ? a.x : b  , c   ? a.y : b  ); }
float2 select_internal(bool    c, float2 a, float2 b) { return float2(c   ? a.x : b.x, c   ? a.y : b.y); }
float2 select_internal(bool2   c, float a, float b) { return float2(c.x ? a   : b  , c.y ? a   : b  ); }
float2 select_internal(bool2   c, float a, float2 b) { return float2(c.x ? a   : b.x, c.y ? a   : b.y); }
float2 select_internal(bool2   c, float2 a, float b) { return float2(c.x ? a.x : b  , c.y ? a.y : b  ); }
float2 select_internal(bool2   c, float2 a, float2 b) { return float2(c.x ? a.x : b.x, c.y ? a.y : b.y); }
float3 select_internal(bool    c, float a, float3 b) { return float3(c   ? a   : b.x, c   ? a   : b.y, c   ? a   : b.z); }
float3 select_internal(bool    c, float3 a, float b) { return float3(c   ? a.x : b  , c   ? a.y : b  , c   ? a.z : b  ); }
float3 select_internal(bool    c, float3 a, float3 b) { return float3(c   ? a.x : b.x, c   ? a.y : b.y, c   ? a.z : b.z); }
float3 select_internal(bool3   c, float a, float b) { return float3(c.x ? a   : b  , c.y ? a   : b  , c.z ? a   : b  ); }
float3 select_internal(bool3   c, float a, float3 b) { return float3(c.x ? a   : b.x, c.y ? a   : b.y, c.z ? a   : b.z); }
float3 select_internal(bool3   c, float3 a, float b) { return float3(c.x ? a.x : b  , c.y ? a.y : b  , c.z ? a.z : b  ); }
float3 select_internal(bool3   c, float3 a, float3 b) { return float3(c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z); }
float4 select_internal(bool    c, float a, float4 b) { return float4(c   ? a   : b.x, c   ? a   : b.y, c   ? a   : b.z, c   ? a   : b.w); }
float4 select_internal(bool    c, float4 a, float b) { return float4(c   ? a.x : b  , c   ? a.y : b  , c   ? a.z : b  , c   ? a.w : b  ); }
float4 select_internal(bool    c, float4 a, float4 b) { return float4(c   ? a.x : b.x, c   ? a.y : b.y, c   ? a.z : b.z, c   ? a.w : b.w); }
float4 select_internal(bool4   c, float a, float b) { return float4(c.x ? a   : b  , c.y ? a   : b  , c.z ? a   : b  , c.w ? a   : b  ); }
float4 select_internal(bool4   c, float a, float4 b) { return float4(c.x ? a   : b.x, c.y ? a   : b.y, c.z ? a   : b.z, c.w ? a   : b.w); }
float4 select_internal(bool4   c, float4 a, float b) { return float4(c.x ? a.x : b  , c.y ? a.y : b  , c.z ? a.z : b  , c.w ? a.w : b  ); }
float4 select_internal(bool4   c, float4 a, float4 b) { return float4(c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z, c.w ? a.w : b.w); }
float  CondMask(bool Cond, float  Src0, float  Src1) { return Cond ? Src0 : Src1; }
float2 CondMask(bool Cond, float2 Src0, float2 Src1) { return Cond ? Src0 : Src1; }
float3 CondMask(bool Cond, float3 Src0, float3 Src1) { return Cond ? Src0 : Src1; }
float4 CondMask(bool Cond, float4 Src0, float4 Src1) { return Cond ? Src0 : Src1; }
int  CondMask(bool Cond, int  Src0, int  Src1) { return Cond ? Src0 : Src1; }
int2 CondMask(bool Cond, int2 Src0, int2 Src1) { return Cond ? Src0 : Src1; }
int3 CondMask(bool Cond, int3 Src0, int3 Src1) { return Cond ? Src0 : Src1; }
int4 CondMask(bool Cond, int4 Src0, int4 Src1) { return Cond ? Src0 : Src1; }
uint  CondMask(bool Cond, uint  Src0, uint  Src1) { return Cond ? Src0 : Src1; }
uint2 CondMask(bool Cond, uint2 Src0, uint2 Src1) { return Cond ? Src0 : Src1; }
uint3 CondMask(bool Cond, uint3 Src0, uint3 Src1) { return Cond ? Src0 : Src1; }
uint4 CondMask(bool Cond, uint4 Src0, uint4 Src1) { return Cond ? Src0 : Src1; }
float UnpackByte0(uint v) { return float(v & 0xff); }
float UnpackByte1(uint v) { return float((v >> 8) & 0xff); }
float UnpackByte2(uint v) { return float((v >> 16) & 0xff); }
float UnpackByte3(uint v) { return float(v >> 24); }
uint BitFieldExtractU32(uint Data, uint Size, uint Offset)
{
	Size &= 31;
	Offset &= 31;
	return (Data >> Offset) & ((1u << Size) - 1u);
}
uint BitFieldMaskU32(uint MaskWidth, uint MaskLocation)
{
	MaskWidth &= 31u;
	MaskLocation &= 31u;
	return ((1u << MaskWidth) - 1u) << MaskLocation;
}
uint BitAlignU32(uint High, uint Low, uint Shift)
{
	Shift &= 31u;
	uint Result = Low >> Shift;
	Result |= Shift > 0u ? (High << (32u - Shift)) : 0u;
	return Result;
}
struct FloatDeriv2
{
	float2 Value;
	float2 Ddx;
	float2 Ddy;
};
struct FloatDeriv3
{
	float3 Value;
	float3 Ddx;
	float3 Ddy;
};
const static float PI = 3.1415926535897932f;
struct FPackedNaniteView
{
	float4x4	SVPositionToTranslatedWorld;
	float4x4	ViewToTranslatedWorld;
	float4x4	TranslatedWorldToView;
	float4x4	TranslatedWorldToClip;
	float4x4	ViewToClip;
	float4x4	ClipToRelativeWorld;
	float4x4	PrevTranslatedWorldToView;
	float4x4	PrevTranslatedWorldToClip;
	float4x4	PrevViewToClip;
	float4x4	PrevClipToRelativeWorld;
	int4		ViewRect;
	float4		ViewSizeAndInvSize;
	float4		ClipSpaceScaleOffset;
	float3		PreViewTranslationHigh;
	float		ViewOriginHighX;
	float3		PrevPreViewTranslationHigh;
	float		ViewOriginHighY;
	float3		PrevPreViewTranslationLow;
	float		MinBoundsRadiusSq;
	float3		ViewOriginLow;
	float		ViewOriginHighZ;
	float3		CullingViewOriginTranslatedWorld;
	float		RangeBasedCullingDistance;
	float3		ViewForward;
	float 		NearPlane;
	float4		TranslatedGlobalClipPlane; 
	float3		PreViewTranslationLow;
	float		CullingViewScreenMultiple;
	float2		LODScales;
	uint		InstanceOcclusionQueryMask;
	uint		StreamingPriorityCategory_AndFlags;
	int4		TargetLayerIdX_AndMipLevelY_AndNumMipLevelsZ;
	int4		HZBTestViewRect;
	float3		Padding1;
	uint		LightingChannelMask;
};
struct FDFScalar;
FDFScalar DFAdd(FDFScalar Lhs, FDFScalar Rhs);
FDFScalar DFAdd(FDFScalar Lhs, float Rhs);
FDFScalar DFSubtract(FDFScalar Lhs, FDFScalar Rhs);
FDFScalar DFSubtract(FDFScalar Lhs, float Rhs);
FDFScalar DFMultiply(FDFScalar Lhs, FDFScalar Rhs);
FDFScalar DFMultiply(FDFScalar Lhs, float Rhs);
FDFScalar DFDivide(FDFScalar Lhs, FDFScalar Rhs);
FDFScalar DFDivide(FDFScalar Lhs, float Rhs);
FDFScalar DFNegate(FDFScalar V);
float DFDemote(FDFScalar V);
struct FDFScalar
{
	float High;
	float Low;
	float Demote() { return DFDemote(this); }
};
FDFScalar MakeDFScalar(float High, float Low)
{
	FDFScalar Result;
	Result.High = High;
	Result.Low = Low;
	return Result;
}
FDFScalar DFPromote(FDFScalar Value) { return Value; }
FDFScalar DFPromote(float Value) { return MakeDFScalar(Value, (float)0); }
float DFDemote(FDFScalar Value) { return Value.High + Value.Low; }
float DFDemote(float Value) { return Value; }
FDFScalar DFNegate(FDFScalar Value)
{
	return MakeDFScalar(-Value.High, -Value.Low);
}
FDFScalar DFTwoSum(float Lhs, float Rhs)
{
	const float S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float V =   MakePrecise( ( S ) - ( Lhs ) );
	const float Q =   MakePrecise( ( S ) - ( V ) );
	const float R =   MakePrecise( ( Lhs ) - ( Q ) );
	const float T =   MakePrecise( ( Rhs ) - ( V ) );
	const float Y =   MakePrecise( ( R ) + ( T ) );
	return MakeDFScalar(S, Y);
}
FDFScalar DFFastTwoSum(float Lhs, float Rhs)
{
	const float S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float T =   MakePrecise( ( S ) - ( Lhs ) );
	const float E =   MakePrecise( ( Rhs ) - ( T ) );
	return MakeDFScalar(S, E);
}
FDFScalar DFAdd(float Lhs, float Rhs) { return DFTwoSum(Lhs, Rhs); }
FDFScalar DFFastAdd(float Lhs, float Rhs) { return DFTwoSum(Lhs, Rhs); }
FDFScalar DFAdd(FDFScalar Lhs, FDFScalar Rhs)
{
	FDFScalar S = DFTwoSum(Lhs.High, Rhs.High);
	const FDFScalar T = DFTwoSum(Lhs.Low, Rhs.Low);
	S.Low += T.High;
	S = DFFastTwoSum(S.High, S.Low);
	S.Low += T.Low;
	S = DFFastTwoSum(S.High, S.Low);
	return S;
}
FDFScalar DFAdd(FDFScalar Lhs, float Rhs)
{
	const FDFScalar S = DFTwoSum(Lhs.High, Rhs);
	const float T = Lhs.Low + S.Low;
	return DFFastTwoSum(S.High, T);
}
FDFScalar DFAdd(float Lhs, FDFScalar Rhs) { return DFAdd(Rhs, Lhs); }
FDFScalar DFFastAdd(FDFScalar Lhs, FDFScalar Rhs)
{
	FDFScalar S = DFTwoSum(Lhs.High, Rhs.High);
	S.Low += Lhs.Low + Rhs.Low;
	S = DFFastTwoSum(S.High, S.Low);
	return S;
}
FDFScalar DFFastAdd(FDFScalar Lhs, float Rhs)
{
	FDFScalar S = DFTwoSum(Lhs.High, Rhs);
	S.Low += Lhs.Low;
	S = DFFastTwoSum(S.High, S.Low);
	return S;
}
FDFScalar DFFastAdd(float Lhs, FDFScalar Rhs) { return DFFastAdd(Rhs, Lhs); }
FDFScalar DFSubtract(float Lhs, float Rhs) { return DFAdd(Lhs, -Rhs); }
FDFScalar DFSubtract(FDFScalar Lhs, FDFScalar Rhs) { return DFAdd(Lhs, DFNegate(Rhs)); }
FDFScalar DFSubtract(FDFScalar Lhs, float Rhs) { return DFAdd(Lhs, -Rhs); }
FDFScalar DFSubtract(float Lhs, FDFScalar Rhs) { return DFAdd(Lhs, DFNegate(Rhs)); }
FDFScalar DFFastSubtract(float Lhs, float Rhs) { return DFFastAdd(Lhs, -Rhs); }
FDFScalar DFFastSubtract(FDFScalar Lhs, FDFScalar Rhs) { return DFFastAdd(Lhs, DFNegate(Rhs)); }
FDFScalar DFFastSubtract(FDFScalar Lhs, float Rhs) { return DFFastAdd(Lhs, -Rhs); }
FDFScalar DFFastSubtract(float Lhs, FDFScalar Rhs) { return DFFastAdd(Lhs, DFNegate(Rhs)); }
float DFFastLocalSubtractDemote(FDFScalar Lhs, FDFScalar Rhs)
{
	const float High =   MakePrecise( ( Lhs.High ) - ( Rhs.High ) );
	const float Low =   MakePrecise( ( Lhs.Low ) - ( Rhs.Low ) );
	const float Sum =   MakePrecise( ( High ) + ( Low ) );
	return Sum;
}
float DFFastLocalSubtractDemote(FDFScalar Lhs, float Rhs)
{
	const float High =   MakePrecise( ( Lhs.High ) - ( Rhs ) );
	const float Sum =   MakePrecise( ( High ) + ( Lhs.Low ) );
	return Sum;
}
float DFFastLocalSubtractDemote(float Lhs, FDFScalar Rhs)
{
	return DFFastLocalSubtractDemote(DFPromote(Lhs), Rhs);
}
FDFScalar DFTwoProduct(float Lhs, float Rhs)
{
	const float P = Lhs * Rhs;
	const float E =   MakePrecise(  mad( ( Lhs ) , ( Rhs ) , ( -P ) ) );
	return MakeDFScalar(P, E);
}
FDFScalar DFMultiply(float Lhs, float Rhs) { return DFTwoProduct(Lhs, Rhs); }
FDFScalar DFMultiply(FDFScalar Lhs, FDFScalar Rhs)
{
	const FDFScalar P = DFTwoProduct(Lhs.High, Rhs.High);
	float T =   MakePrecise( ( Lhs.High ) * ( Rhs.Low ) );
	T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs.High ) , ( T ) ) );
	T =   MakePrecise( ( T ) + ( P.Low ) );
	return DFFastTwoSum(P.High, T);
}
FDFScalar DFMultiply(FDFScalar Lhs, float Rhs)
{
	FDFScalar P = DFTwoProduct(Lhs.High, Rhs);
	float T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs ) , ( P.Low ) ) );
	return DFFastTwoSum(P.High, T);
}
FDFScalar DFMultiply(float Lhs, FDFScalar Rhs) { return DFMultiply(Rhs, Lhs); }
FDFScalar DFFastDivide(FDFScalar Lhs, FDFScalar Rhs);
FDFScalar DFDivide(FDFScalar Lhs, FDFScalar Rhs)
{
	const float Th =   MakePrecise( ( 1.0 ) / ( Rhs.High ) );
	const float Rh =   MakePrecise(  mad( ( -Rhs.High ) , ( Th ) , ( (float)1 ) ) );
	const float Rl =   MakePrecise( ( -Rhs.Low ) * ( Th ) );
	const FDFScalar E = DFFastTwoSum(Rh, Rl);
	const FDFScalar D = DFMultiply(E, Th);
	const FDFScalar M = DFAdd(D, Th);
	return DFMultiply(Lhs, M);
}
FDFScalar DFDivide(FDFScalar Lhs, float Rhs)
{
	const float Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFScalar P = DFTwoProduct(Th, Rhs);
	const float Dh =   MakePrecise( ( Lhs.High ) - ( P.High ) );
	const float Dt =   MakePrecise( ( Dh ) - ( P.Low ) );
	const float D =   MakePrecise( ( Dt ) + ( Lhs.Low ) );
	const float Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFScalar DFDivide(float Lhs, float Rhs)
{
	return DFDivide(DFPromote(Lhs), Rhs);
}
FDFScalar DFDivide(float Lhs, FDFScalar Rhs)
{
	return DFDivide(DFPromote(Lhs), Rhs);
}
FDFScalar DFFastDivide(FDFScalar Lhs, FDFScalar Rhs)
{
	const float Th =   MakePrecise( ( Lhs.High ) / ( Rhs.High ) );
	const FDFScalar R = DFMultiply(Rhs, Th);
	const float Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float Tl =   MakePrecise( ( D ) / ( Rhs.High ) );
	return DFFastTwoSum(Th, Tl);
}
FDFScalar DFFastDivide(FDFScalar Lhs, float Rhs)
{
	const float Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFScalar R = DFTwoProduct(Rhs, Th);
	const float Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFScalar DFFastDivide(float Lhs, FDFScalar Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFScalar DFFastDivide(float Lhs, float Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFScalar DFGetComponent(float V, int C) { return MakeDFScalar(V, 0); }
FDFScalar DFGetComponent(FDFScalar V, int C) { return V; }
struct FDFVector2;
FDFVector2 DFBroadcast2(FDFScalar V);
float2 DFBroadcast2(float V);
FDFScalar DFGetComponent(FDFVector2 V, int C);
FDFVector2 DFNegate(FDFVector2 In);
FDFVector2 DFAdd (FDFVector2 Lhs, FDFVector2 Rhs);
FDFVector2 DFAdd (FDFVector2 Lhs, float2 Rhs);
FDFVector2 DFAdd (FDFVector2 Lhs, FDFScalar Rhs);
FDFVector2 DFAdd (FDFVector2 Lhs, float Rhs);
FDFVector2 DFSubtract (FDFVector2 Lhs, FDFVector2 Rhs);
FDFVector2 DFSubtract (FDFVector2 Lhs, float2 Rhs);
FDFVector2 DFSubtract (FDFVector2 Lhs, FDFScalar Rhs);
FDFVector2 DFSubtract (FDFVector2 Lhs, float Rhs);
FDFVector2 DFMultiply (FDFVector2 Lhs, FDFVector2 Rhs);
FDFVector2 DFMultiply (FDFVector2 Lhs, float2 Rhs);
FDFVector2 DFMultiply (FDFVector2 Lhs, FDFScalar Rhs);
FDFVector2 DFMultiply (FDFVector2 Lhs, float Rhs);
FDFVector2 DFDivide (FDFVector2 Lhs, FDFVector2 Rhs);
FDFVector2 DFDivide (FDFVector2 Lhs, float2 Rhs);
FDFVector2 DFDivide (FDFVector2 Lhs, FDFScalar Rhs);
FDFVector2 DFDivide (FDFVector2 Lhs, float Rhs);
float2 DFDemote(FDFVector2 In);
struct FDFVector2
{
	float2 High;
	float2 Low;
	float2 Demote() { return DFDemote(this); }
};
FDFScalar DFGetComponent(FDFVector2 V, int C) { return MakeDFScalar(V.High[C], V.Low[C]); }
FDFVector2 MakeDFVector2(float2 High, float2 Low)
{
	FDFVector2 Result;
	Result.High = High;
	Result.Low = Low;
	return Result;
}
FDFVector2 DFPromote(FDFVector2 Value) { return Value; }
FDFVector2 DFPromote(float2 Value) { return MakeDFVector2(Value, (float2)0); }
float2 DFDemote(FDFVector2 Value) { return Value.High + Value.Low; }
float2 DFDemote(float2 Value) { return Value; }
FDFVector2 DFNegate(FDFVector2 Value)
{
	return MakeDFVector2(-Value.High, -Value.Low);
}
FDFVector2 DFTwoSum(float2 Lhs, float2 Rhs)
{
	const float2 S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float2 V =   MakePrecise( ( S ) - ( Lhs ) );
	const float2 Q =   MakePrecise( ( S ) - ( V ) );
	const float2 R =   MakePrecise( ( Lhs ) - ( Q ) );
	const float2 T =   MakePrecise( ( Rhs ) - ( V ) );
	const float2 Y =   MakePrecise( ( R ) + ( T ) );
	return MakeDFVector2(S, Y);
}
FDFVector2 DFFastTwoSum(float2 Lhs, float2 Rhs)
{
	const float2 S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float2 T =   MakePrecise( ( S ) - ( Lhs ) );
	const float2 E =   MakePrecise( ( Rhs ) - ( T ) );
	return MakeDFVector2(S, E);
}
FDFVector2 DFAdd(float2 Lhs, float2 Rhs) { return DFTwoSum(Lhs, Rhs); }
FDFVector2 DFFastAdd(float2 Lhs, float2 Rhs) { return DFTwoSum(Lhs, Rhs); }
FDFVector2 DFAdd(FDFVector2 Lhs, FDFVector2 Rhs)
{
	FDFVector2 S = DFTwoSum(Lhs.High, Rhs.High);
	const FDFVector2 T = DFTwoSum(Lhs.Low, Rhs.Low);
	S.Low += T.High;
	S = DFFastTwoSum(S.High, S.Low);
	S.Low += T.Low;
	S = DFFastTwoSum(S.High, S.Low);
	return S;
}
FDFVector2 DFAdd(FDFVector2 Lhs, float2 Rhs)
{
	const FDFVector2 S = DFTwoSum(Lhs.High, Rhs);
	const float2 T = Lhs.Low + S.Low;
	return DFFastTwoSum(S.High, T);
}
FDFVector2 DFAdd(float2 Lhs, FDFVector2 Rhs) { return DFAdd(Rhs, Lhs); }
FDFVector2 DFFastAdd(FDFVector2 Lhs, FDFVector2 Rhs)
{
	FDFVector2 S = DFTwoSum(Lhs.High, Rhs.High);
	S.Low += Lhs.Low + Rhs.Low;
	S = DFFastTwoSum(S.High, S.Low);
	return S;
}
FDFVector2 DFFastAdd(FDFVector2 Lhs, float2 Rhs)
{
	FDFVector2 S = DFTwoSum(Lhs.High, Rhs);
	S.Low += Lhs.Low;
	S = DFFastTwoSum(S.High, S.Low);
	return S;
}
FDFVector2 DFFastAdd(float2 Lhs, FDFVector2 Rhs) { return DFFastAdd(Rhs, Lhs); }
FDFVector2 DFSubtract(float2 Lhs, float2 Rhs) { return DFAdd(Lhs, -Rhs); }
FDFVector2 DFSubtract(FDFVector2 Lhs, FDFVector2 Rhs) { return DFAdd(Lhs, DFNegate(Rhs)); }
FDFVector2 DFSubtract(FDFVector2 Lhs, float2 Rhs) { return DFAdd(Lhs, -Rhs); }
FDFVector2 DFSubtract(float2 Lhs, FDFVector2 Rhs) { return DFAdd(Lhs, DFNegate(Rhs)); }
FDFVector2 DFFastSubtract(float2 Lhs, float2 Rhs) { return DFFastAdd(Lhs, -Rhs); }
FDFVector2 DFFastSubtract(FDFVector2 Lhs, FDFVector2 Rhs) { return DFFastAdd(Lhs, DFNegate(Rhs)); }
FDFVector2 DFFastSubtract(FDFVector2 Lhs, float2 Rhs) { return DFFastAdd(Lhs, -Rhs); }
FDFVector2 DFFastSubtract(float2 Lhs, FDFVector2 Rhs) { return DFFastAdd(Lhs, DFNegate(Rhs)); }
float2 DFFastLocalSubtractDemote(FDFVector2 Lhs, FDFVector2 Rhs)
{
	const float2 High =   MakePrecise( ( Lhs.High ) - ( Rhs.High ) );
	const float2 Low =   MakePrecise( ( Lhs.Low ) - ( Rhs.Low ) );
	const float2 Sum =   MakePrecise( ( High ) + ( Low ) );
	return Sum;
}
float2 DFFastLocalSubtractDemote(FDFVector2 Lhs, float2 Rhs)
{
	const float2 High =   MakePrecise( ( Lhs.High ) - ( Rhs ) );
	const float2 Sum =   MakePrecise( ( High ) + ( Lhs.Low ) );
	return Sum;
}
float2 DFFastLocalSubtractDemote(float2 Lhs, FDFVector2 Rhs)
{
	return DFFastLocalSubtractDemote(DFPromote(Lhs), Rhs);
}
FDFVector2 DFTwoProduct(float2 Lhs, float2 Rhs)
{
	const float2 P = Lhs * Rhs;
	const float2 E =   MakePrecise(  mad( ( Lhs ) , ( Rhs ) , ( -P ) ) );
	return MakeDFVector2(P, E);
}
FDFVector2 DFMultiply(float2 Lhs, float2 Rhs) { return DFTwoProduct(Lhs, Rhs); }
FDFVector2 DFMultiply(FDFVector2 Lhs, FDFVector2 Rhs)
{
	const FDFVector2 P = DFTwoProduct(Lhs.High, Rhs.High);
	float2 T =   MakePrecise( ( Lhs.High ) * ( Rhs.Low ) );
	T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs.High ) , ( T ) ) );
	T =   MakePrecise( ( T ) + ( P.Low ) );
	return DFFastTwoSum(P.High, T);
}
FDFVector2 DFMultiply(FDFVector2 Lhs, float2 Rhs)
{
	FDFVector2 P = DFTwoProduct(Lhs.High, Rhs);
	float2 T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs ) , ( P.Low ) ) );
	return DFFastTwoSum(P.High, T);
}
FDFVector2 DFMultiply(float2 Lhs, FDFVector2 Rhs) { return DFMultiply(Rhs, Lhs); }
FDFVector2 DFFastDivide(FDFVector2 Lhs, FDFVector2 Rhs);
FDFVector2 DFDivide(FDFVector2 Lhs, FDFVector2 Rhs)
{
	const float2 Th =   MakePrecise( ( 1.0 ) / ( Rhs.High ) );
	const float2 Rh =   MakePrecise(  mad( ( -Rhs.High ) , ( Th ) , ( (float2)1 ) ) );
	const float2 Rl =   MakePrecise( ( -Rhs.Low ) * ( Th ) );
	const FDFVector2 E = DFFastTwoSum(Rh, Rl);
	const FDFVector2 D = DFMultiply(E, Th);
	const FDFVector2 M = DFAdd(D, Th);
	return DFMultiply(Lhs, M);
}
FDFVector2 DFDivide(FDFVector2 Lhs, float2 Rhs)
{
	const float2 Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFVector2 P = DFTwoProduct(Th, Rhs);
	const float2 Dh =   MakePrecise( ( Lhs.High ) - ( P.High ) );
	const float2 Dt =   MakePrecise( ( Dh ) - ( P.Low ) );
	const float2 D =   MakePrecise( ( Dt ) + ( Lhs.Low ) );
	const float2 Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector2 DFDivide(float2 Lhs, float2 Rhs)
{
	return DFDivide(DFPromote(Lhs), Rhs);
}
FDFVector2 DFDivide(float2 Lhs, FDFVector2 Rhs)
{
	return DFDivide(DFPromote(Lhs), Rhs);
}
FDFVector2 DFFastDivide(FDFVector2 Lhs, FDFVector2 Rhs)
{
	const float2 Th =   MakePrecise( ( Lhs.High ) / ( Rhs.High ) );
	const FDFVector2 R = DFMultiply(Rhs, Th);
	const float2 Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float2 Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float2 D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float2 Tl =   MakePrecise( ( D ) / ( Rhs.High ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector2 DFFastDivide(FDFVector2 Lhs, float2 Rhs)
{
	const float2 Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFVector2 R = DFTwoProduct(Rhs, Th);
	const float2 Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float2 Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float2 D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float2 Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector2 DFFastDivide(float2 Lhs, FDFVector2 Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFVector2 DFFastDivide(float2 Lhs, float2 Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFVector2 DFBroadcast2(FDFScalar V)
{
	const float2 High = V.High;
	const float2 Low = V.Low;
	return MakeDFVector2(High, Low);
}
float2 DFBroadcast2(float V)
{
	const float2 Single = V;
	return Single;
}
FDFVector2  DFAdd (FDFScalar Lhs, FDFVector2 Rhs) { return DFAdd (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFAdd (float Lhs, FDFVector2 Rhs) { return DFAdd (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFAdd (FDFScalar Lhs, float2 Rhs) { return DFAdd (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFAdd (float Lhs, float2 Rhs) { return DFAdd (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFAdd (FDFVector2 Lhs, FDFScalar Rhs) { return DFAdd (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFAdd (FDFVector2 Lhs, float Rhs)     { return DFAdd (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFAdd (float2 Lhs, FDFScalar Rhs) { return DFAdd (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFAdd (float2 Lhs, float Rhs) { return DFAdd (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastAdd (FDFScalar Lhs, FDFVector2 Rhs) { return DFFastAdd (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastAdd (float Lhs, FDFVector2 Rhs) { return DFFastAdd (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastAdd (FDFScalar Lhs, float2 Rhs) { return DFFastAdd (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastAdd (float Lhs, float2 Rhs) { return DFFastAdd (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastAdd (FDFVector2 Lhs, FDFScalar Rhs) { return DFFastAdd (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastAdd (FDFVector2 Lhs, float Rhs)     { return DFFastAdd (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastAdd (float2 Lhs, FDFScalar Rhs) { return DFFastAdd (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastAdd (float2 Lhs, float Rhs) { return DFFastAdd (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFSubtract (FDFScalar Lhs, FDFVector2 Rhs) { return DFSubtract (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFSubtract (float Lhs, FDFVector2 Rhs) { return DFSubtract (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFSubtract (FDFScalar Lhs, float2 Rhs) { return DFSubtract (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFSubtract (float Lhs, float2 Rhs) { return DFSubtract (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFSubtract (FDFVector2 Lhs, FDFScalar Rhs) { return DFSubtract (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFSubtract (FDFVector2 Lhs, float Rhs)     { return DFSubtract (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFSubtract (float2 Lhs, FDFScalar Rhs) { return DFSubtract (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFSubtract (float2 Lhs, float Rhs) { return DFSubtract (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastSubtract (FDFScalar Lhs, FDFVector2 Rhs) { return DFFastSubtract (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastSubtract (float Lhs, FDFVector2 Rhs) { return DFFastSubtract (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastSubtract (FDFScalar Lhs, float2 Rhs) { return DFFastSubtract (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastSubtract (float Lhs, float2 Rhs) { return DFFastSubtract (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastSubtract (FDFVector2 Lhs, FDFScalar Rhs) { return DFFastSubtract (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastSubtract (FDFVector2 Lhs, float Rhs)     { return DFFastSubtract (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastSubtract (float2 Lhs, FDFScalar Rhs) { return DFFastSubtract (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastSubtract (float2 Lhs, float Rhs) { return DFFastSubtract (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFMultiply (FDFScalar Lhs, FDFVector2 Rhs) { return DFMultiply (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFMultiply (float Lhs, FDFVector2 Rhs) { return DFMultiply (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFMultiply (FDFScalar Lhs, float2 Rhs) { return DFMultiply (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFMultiply (float Lhs, float2 Rhs) { return DFMultiply (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFMultiply (FDFVector2 Lhs, FDFScalar Rhs) { return DFMultiply (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFMultiply (FDFVector2 Lhs, float Rhs)     { return DFMultiply (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFMultiply (float2 Lhs, FDFScalar Rhs) { return DFMultiply (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFMultiply (float2 Lhs, float Rhs) { return DFMultiply (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFDivide (FDFScalar Lhs, FDFVector2 Rhs) { return DFDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFDivide (float Lhs, FDFVector2 Rhs) { return DFDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFDivide (FDFScalar Lhs, float2 Rhs) { return DFDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFDivide (float Lhs, float2 Rhs) { return DFDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFDivide (FDFVector2 Lhs, FDFScalar Rhs) { return DFDivide (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFDivide (FDFVector2 Lhs, float Rhs)     { return DFDivide (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFDivide (float2 Lhs, FDFScalar Rhs) { return DFDivide (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFDivide (float2 Lhs, float Rhs) { return DFDivide (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastDivide (FDFScalar Lhs, FDFVector2 Rhs) { return DFFastDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastDivide (float Lhs, FDFVector2 Rhs) { return DFFastDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastDivide (FDFScalar Lhs, float2 Rhs) { return DFFastDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastDivide (float Lhs, float2 Rhs) { return DFFastDivide (DFBroadcast2(Lhs), Rhs); }
FDFVector2  DFFastDivide (FDFVector2 Lhs, FDFScalar Rhs) { return DFFastDivide (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastDivide (FDFVector2 Lhs, float Rhs)     { return DFFastDivide (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastDivide (float2 Lhs, FDFScalar Rhs) { return DFFastDivide (Lhs, DFBroadcast2(Rhs)); }
FDFVector2  DFFastDivide (float2 Lhs, float Rhs) { return DFFastDivide (Lhs, DFBroadcast2(Rhs)); }
struct FDFVector3;
FDFVector3 DFBroadcast3(FDFScalar V);
float3 DFBroadcast3(float V);
FDFScalar DFGetComponent(FDFVector3 V, int C);
FDFVector3 DFNegate(FDFVector3 In);
FDFVector3 DFAdd (FDFVector3 Lhs, FDFVector3 Rhs);
FDFVector3 DFAdd (FDFVector3 Lhs, float3 Rhs);
FDFVector3 DFAdd (FDFVector3 Lhs, FDFScalar Rhs);
FDFVector3 DFAdd (FDFVector3 Lhs, float Rhs);
FDFVector3 DFSubtract (FDFVector3 Lhs, FDFVector3 Rhs);
FDFVector3 DFSubtract (FDFVector3 Lhs, float3 Rhs);
FDFVector3 DFSubtract (FDFVector3 Lhs, FDFScalar Rhs);
FDFVector3 DFSubtract (FDFVector3 Lhs, float Rhs);
FDFVector3 DFMultiply (FDFVector3 Lhs, FDFVector3 Rhs);
FDFVector3 DFMultiply (FDFVector3 Lhs, float3 Rhs);
FDFVector3 DFMultiply (FDFVector3 Lhs, FDFScalar Rhs);
FDFVector3 DFMultiply (FDFVector3 Lhs, float Rhs);
FDFVector3 DFDivide (FDFVector3 Lhs, FDFVector3 Rhs);
FDFVector3 DFDivide (FDFVector3 Lhs, float3 Rhs);
FDFVector3 DFDivide (FDFVector3 Lhs, FDFScalar Rhs);
FDFVector3 DFDivide (FDFVector3 Lhs, float Rhs);
float3 DFDemote(FDFVector3 In);
struct FDFVector3
{
	float3 High;
	float3 Low;
	float3 Demote() { return DFDemote(this); }
};
FDFScalar DFGetComponent(FDFVector3 V, int C) { return MakeDFScalar(V.High[C], V.Low[C]); }
FDFVector3 MakeDFVector3(float3 High, float3 Low)
{
	FDFVector3 Result;
	Result.High = High;
	Result.Low = Low;
	return Result;
}
FDFVector3 DFPromote(FDFVector3 Value) { return Value; }
FDFVector3 DFPromote(float3 Value) { return MakeDFVector3(Value, (float3)0); }
float3 DFDemote(FDFVector3 Value) { return Value.High + Value.Low; }
float3 DFDemote(float3 Value) { return Value; }
FDFVector3 DFNegate(FDFVector3 Value)
{
	return MakeDFVector3(-Value.High, -Value.Low);
}
FDFVector3 DFTwoSum(float3 Lhs, float3 Rhs)
{
	const float3 S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float3 V =   MakePrecise( ( S ) - ( Lhs ) );
	const float3 Q =   MakePrecise( ( S ) - ( V ) );
	const float3 R =   MakePrecise( ( Lhs ) - ( Q ) );
	const float3 T =   MakePrecise( ( Rhs ) - ( V ) );
	const float3 Y =   MakePrecise( ( R ) + ( T ) );
	return MakeDFVector3(S, Y);
}
FDFVector3 DFFastTwoSum(float3 Lhs, float3 Rhs)
{
	const float3 S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float3 T =   MakePrecise( ( S ) - ( Lhs ) );
	const float3 E =   MakePrecise( ( Rhs ) - ( T ) );
	return MakeDFVector3(S, E);
}
FDFVector3 DFAdd(float3 Lhs, float3 Rhs) { return DFTwoSum(Lhs, Rhs); }
FDFVector3 DFFastAdd(float3 Lhs, float3 Rhs) { return DFTwoSum(Lhs, Rhs); }
FDFVector3 DFAdd(FDFVector3 Lhs, FDFVector3 Rhs)
{
	FDFVector3 S = DFTwoSum(Lhs.High, Rhs.High);
	const FDFVector3 T = DFTwoSum(Lhs.Low, Rhs.Low);
	S.Low += T.High;
	S = DFFastTwoSum(S.High, S.Low);
	S.Low += T.Low;
	S = DFFastTwoSum(S.High, S.Low);
	return S;
}
FDFVector3 DFAdd(FDFVector3 Lhs, float3 Rhs)
{
	const FDFVector3 S = DFTwoSum(Lhs.High, Rhs);
	const float3 T = Lhs.Low + S.Low;
	return DFFastTwoSum(S.High, T);
}
FDFVector3 DFAdd(float3 Lhs, FDFVector3 Rhs) { return DFAdd(Rhs, Lhs); }
FDFVector3 DFFastAdd(FDFVector3 Lhs, FDFVector3 Rhs)
{
	FDFVector3 S = DFTwoSum(Lhs.High, Rhs.High);
	S.Low += Lhs.Low + Rhs.Low;
	S = DFFastTwoSum(S.High, S.Low);
	return S;
}
FDFVector3 DFFastAdd(FDFVector3 Lhs, float3 Rhs)
{
	FDFVector3 S = DFTwoSum(Lhs.High, Rhs);
	S.Low += Lhs.Low;
	S = DFFastTwoSum(S.High, S.Low);
	return S;
}
FDFVector3 DFFastAdd(float3 Lhs, FDFVector3 Rhs) { return DFFastAdd(Rhs, Lhs); }
FDFVector3 DFSubtract(float3 Lhs, float3 Rhs) { return DFAdd(Lhs, -Rhs); }
FDFVector3 DFSubtract(FDFVector3 Lhs, FDFVector3 Rhs) { return DFAdd(Lhs, DFNegate(Rhs)); }
FDFVector3 DFSubtract(FDFVector3 Lhs, float3 Rhs) { return DFAdd(Lhs, -Rhs); }
FDFVector3 DFSubtract(float3 Lhs, FDFVector3 Rhs) { return DFAdd(Lhs, DFNegate(Rhs)); }
FDFVector3 DFFastSubtract(float3 Lhs, float3 Rhs) { return DFFastAdd(Lhs, -Rhs); }
FDFVector3 DFFastSubtract(FDFVector3 Lhs, FDFVector3 Rhs) { return DFFastAdd(Lhs, DFNegate(Rhs)); }
FDFVector3 DFFastSubtract(FDFVector3 Lhs, float3 Rhs) { return DFFastAdd(Lhs, -Rhs); }
FDFVector3 DFFastSubtract(float3 Lhs, FDFVector3 Rhs) { return DFFastAdd(Lhs, DFNegate(Rhs)); }
float3 DFFastLocalSubtractDemote(FDFVector3 Lhs, FDFVector3 Rhs)
{
	const float3 High =   MakePrecise( ( Lhs.High ) - ( Rhs.High ) );
	const float3 Low =   MakePrecise( ( Lhs.Low ) - ( Rhs.Low ) );
	const float3 Sum =   MakePrecise( ( High ) + ( Low ) );
	return Sum;
}
float3 DFFastLocalSubtractDemote(FDFVector3 Lhs, float3 Rhs)
{
	const float3 High =   MakePrecise( ( Lhs.High ) - ( Rhs ) );
	const float3 Sum =   MakePrecise( ( High ) + ( Lhs.Low ) );
	return Sum;
}
float3 DFFastLocalSubtractDemote(float3 Lhs, FDFVector3 Rhs)
{
	return DFFastLocalSubtractDemote(DFPromote(Lhs), Rhs);
}
FDFVector3 DFTwoProduct(float3 Lhs, float3 Rhs)
{
	const float3 P = Lhs * Rhs;
	const float3 E =   MakePrecise(  mad( ( Lhs ) , ( Rhs ) , ( -P ) ) );
	return MakeDFVector3(P, E);
}
FDFVector3 DFMultiply(float3 Lhs, float3 Rhs) { return DFTwoProduct(Lhs, Rhs); }
FDFVector3 DFMultiply(FDFVector3 Lhs, FDFVector3 Rhs)
{
	const FDFVector3 P = DFTwoProduct(Lhs.High, Rhs.High);
	float3 T =   MakePrecise( ( Lhs.High ) * ( Rhs.Low ) );
	T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs.High ) , ( T ) ) );
	T =   MakePrecise( ( T ) + ( P.Low ) );
	return DFFastTwoSum(P.High, T);
}
FDFVector3 DFMultiply(FDFVector3 Lhs, float3 Rhs)
{
	FDFVector3 P = DFTwoProduct(Lhs.High, Rhs);
	float3 T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs ) , ( P.Low ) ) );
	return DFFastTwoSum(P.High, T);
}
FDFVector3 DFMultiply(float3 Lhs, FDFVector3 Rhs) { return DFMultiply(Rhs, Lhs); }
FDFVector3 DFFastDivide(FDFVector3 Lhs, FDFVector3 Rhs);
FDFVector3 DFDivide(FDFVector3 Lhs, FDFVector3 Rhs)
{
	const float3 Th =   MakePrecise( ( 1.0 ) / ( Rhs.High ) );
	const float3 Rh =   MakePrecise(  mad( ( -Rhs.High ) , ( Th ) , ( (float3)1 ) ) );
	const float3 Rl =   MakePrecise( ( -Rhs.Low ) * ( Th ) );
	const FDFVector3 E = DFFastTwoSum(Rh, Rl);
	const FDFVector3 D = DFMultiply(E, Th);
	const FDFVector3 M = DFAdd(D, Th);
	return DFMultiply(Lhs, M);
}
FDFVector3 DFDivide(FDFVector3 Lhs, float3 Rhs)
{
	const float3 Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFVector3 P = DFTwoProduct(Th, Rhs);
	const float3 Dh =   MakePrecise( ( Lhs.High ) - ( P.High ) );
	const float3 Dt =   MakePrecise( ( Dh ) - ( P.Low ) );
	const float3 D =   MakePrecise( ( Dt ) + ( Lhs.Low ) );
	const float3 Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector3 DFDivide(float3 Lhs, float3 Rhs)
{
	return DFDivide(DFPromote(Lhs), Rhs);
}
FDFVector3 DFDivide(float3 Lhs, FDFVector3 Rhs)
{
	return DFDivide(DFPromote(Lhs), Rhs);
}
FDFVector3 DFFastDivide(FDFVector3 Lhs, FDFVector3 Rhs)
{
	const float3 Th =   MakePrecise( ( Lhs.High ) / ( Rhs.High ) );
	const FDFVector3 R = DFMultiply(Rhs, Th);
	const float3 Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float3 Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float3 D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float3 Tl =   MakePrecise( ( D ) / ( Rhs.High ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector3 DFFastDivide(FDFVector3 Lhs, float3 Rhs)
{
	const float3 Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFVector3 R = DFTwoProduct(Rhs, Th);
	const float3 Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float3 Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float3 D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float3 Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector3 DFFastDivide(float3 Lhs, FDFVector3 Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFVector3 DFFastDivide(float3 Lhs, float3 Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFVector3 DFBroadcast3(FDFScalar V)
{
	const float3 High = V.High;
	const float3 Low = V.Low;
	return MakeDFVector3(High, Low);
}
float3 DFBroadcast3(float V)
{
	const float3 Single = V;
	return Single;
}
FDFVector3  DFAdd (FDFScalar Lhs, FDFVector3 Rhs) { return DFAdd (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFAdd (float Lhs, FDFVector3 Rhs) { return DFAdd (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFAdd (FDFScalar Lhs, float3 Rhs) { return DFAdd (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFAdd (float Lhs, float3 Rhs) { return DFAdd (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFAdd (FDFVector3 Lhs, FDFScalar Rhs) { return DFAdd (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFAdd (FDFVector3 Lhs, float Rhs)     { return DFAdd (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFAdd (float3 Lhs, FDFScalar Rhs) { return DFAdd (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFAdd (float3 Lhs, float Rhs) { return DFAdd (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastAdd (FDFScalar Lhs, FDFVector3 Rhs) { return DFFastAdd (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastAdd (float Lhs, FDFVector3 Rhs) { return DFFastAdd (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastAdd (FDFScalar Lhs, float3 Rhs) { return DFFastAdd (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastAdd (float Lhs, float3 Rhs) { return DFFastAdd (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastAdd (FDFVector3 Lhs, FDFScalar Rhs) { return DFFastAdd (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastAdd (FDFVector3 Lhs, float Rhs)     { return DFFastAdd (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastAdd (float3 Lhs, FDFScalar Rhs) { return DFFastAdd (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastAdd (float3 Lhs, float Rhs) { return DFFastAdd (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFSubtract (FDFScalar Lhs, FDFVector3 Rhs) { return DFSubtract (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFSubtract (float Lhs, FDFVector3 Rhs) { return DFSubtract (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFSubtract (FDFScalar Lhs, float3 Rhs) { return DFSubtract (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFSubtract (float Lhs, float3 Rhs) { return DFSubtract (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFSubtract (FDFVector3 Lhs, FDFScalar Rhs) { return DFSubtract (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFSubtract (FDFVector3 Lhs, float Rhs)     { return DFSubtract (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFSubtract (float3 Lhs, FDFScalar Rhs) { return DFSubtract (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFSubtract (float3 Lhs, float Rhs) { return DFSubtract (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastSubtract (FDFScalar Lhs, FDFVector3 Rhs) { return DFFastSubtract (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastSubtract (float Lhs, FDFVector3 Rhs) { return DFFastSubtract (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastSubtract (FDFScalar Lhs, float3 Rhs) { return DFFastSubtract (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastSubtract (float Lhs, float3 Rhs) { return DFFastSubtract (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastSubtract (FDFVector3 Lhs, FDFScalar Rhs) { return DFFastSubtract (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastSubtract (FDFVector3 Lhs, float Rhs)     { return DFFastSubtract (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastSubtract (float3 Lhs, FDFScalar Rhs) { return DFFastSubtract (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastSubtract (float3 Lhs, float Rhs) { return DFFastSubtract (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFMultiply (FDFScalar Lhs, FDFVector3 Rhs) { return DFMultiply (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFMultiply (float Lhs, FDFVector3 Rhs) { return DFMultiply (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFMultiply (FDFScalar Lhs, float3 Rhs) { return DFMultiply (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFMultiply (float Lhs, float3 Rhs) { return DFMultiply (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFMultiply (FDFVector3 Lhs, FDFScalar Rhs) { return DFMultiply (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFMultiply (FDFVector3 Lhs, float Rhs)     { return DFMultiply (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFMultiply (float3 Lhs, FDFScalar Rhs) { return DFMultiply (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFMultiply (float3 Lhs, float Rhs) { return DFMultiply (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFDivide (FDFScalar Lhs, FDFVector3 Rhs) { return DFDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFDivide (float Lhs, FDFVector3 Rhs) { return DFDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFDivide (FDFScalar Lhs, float3 Rhs) { return DFDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFDivide (float Lhs, float3 Rhs) { return DFDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFDivide (FDFVector3 Lhs, FDFScalar Rhs) { return DFDivide (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFDivide (FDFVector3 Lhs, float Rhs)     { return DFDivide (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFDivide (float3 Lhs, FDFScalar Rhs) { return DFDivide (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFDivide (float3 Lhs, float Rhs) { return DFDivide (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastDivide (FDFScalar Lhs, FDFVector3 Rhs) { return DFFastDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastDivide (float Lhs, FDFVector3 Rhs) { return DFFastDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastDivide (FDFScalar Lhs, float3 Rhs) { return DFFastDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastDivide (float Lhs, float3 Rhs) { return DFFastDivide (DFBroadcast3(Lhs), Rhs); }
FDFVector3  DFFastDivide (FDFVector3 Lhs, FDFScalar Rhs) { return DFFastDivide (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastDivide (FDFVector3 Lhs, float Rhs)     { return DFFastDivide (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastDivide (float3 Lhs, FDFScalar Rhs) { return DFFastDivide (Lhs, DFBroadcast3(Rhs)); }
FDFVector3  DFFastDivide (float3 Lhs, float Rhs) { return DFFastDivide (Lhs, DFBroadcast3(Rhs)); }
struct FDFVector4;
FDFVector4 DFBroadcast4(FDFScalar V);
float4 DFBroadcast4(float V);
FDFScalar DFGetComponent(FDFVector4 V, int C);
FDFVector4 DFNegate(FDFVector4 In);
FDFVector4 DFAdd (FDFVector4 Lhs, FDFVector4 Rhs);
FDFVector4 DFAdd (FDFVector4 Lhs, float4 Rhs);
FDFVector4 DFAdd (FDFVector4 Lhs, FDFScalar Rhs);
FDFVector4 DFAdd (FDFVector4 Lhs, float Rhs);
FDFVector4 DFSubtract (FDFVector4 Lhs, FDFVector4 Rhs);
FDFVector4 DFSubtract (FDFVector4 Lhs, float4 Rhs);
FDFVector4 DFSubtract (FDFVector4 Lhs, FDFScalar Rhs);
FDFVector4 DFSubtract (FDFVector4 Lhs, float Rhs);
FDFVector4 DFMultiply (FDFVector4 Lhs, FDFVector4 Rhs);
FDFVector4 DFMultiply (FDFVector4 Lhs, float4 Rhs);
FDFVector4 DFMultiply (FDFVector4 Lhs, FDFScalar Rhs);
FDFVector4 DFMultiply (FDFVector4 Lhs, float Rhs);
FDFVector4 DFDivide (FDFVector4 Lhs, FDFVector4 Rhs);
FDFVector4 DFDivide (FDFVector4 Lhs, float4 Rhs);
FDFVector4 DFDivide (FDFVector4 Lhs, FDFScalar Rhs);
FDFVector4 DFDivide (FDFVector4 Lhs, float Rhs);
float4 DFDemote(FDFVector4 In);
struct FDFVector4
{
	float4 High;
	float4 Low;
	float4 Demote() { return DFDemote(this); }
};
FDFScalar DFGetComponent(FDFVector4 V, int C) { return MakeDFScalar(V.High[C], V.Low[C]); }
FDFVector4 MakeDFVector4(float4 High, float4 Low)
{
	FDFVector4 Result;
	Result.High = High;
	Result.Low = Low;
	return Result;
}
FDFVector4 DFPromote(FDFVector4 Value) { return Value; }
FDFVector4 DFPromote(float4 Value) { return MakeDFVector4(Value, (float4)0); }
float4 DFDemote(FDFVector4 Value) { return Value.High + Value.Low; }
float4 DFDemote(float4 Value) { return Value; }
FDFVector4 DFNegate(FDFVector4 Value)
{
	return MakeDFVector4(-Value.High, -Value.Low);
}
FDFVector4 DFTwoSum(float4 Lhs, float4 Rhs)
{
	const float4 S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float4 V =   MakePrecise( ( S ) - ( Lhs ) );
	const float4 Q =   MakePrecise( ( S ) - ( V ) );
	const float4 R =   MakePrecise( ( Lhs ) - ( Q ) );
	const float4 T =   MakePrecise( ( Rhs ) - ( V ) );
	const float4 Y =   MakePrecise( ( R ) + ( T ) );
	return MakeDFVector4(S, Y);
}
FDFVector4 DFFastTwoSum(float4 Lhs, float4 Rhs)
{
	const float4 S =   MakePrecise( ( Lhs ) + ( Rhs ) );
	const float4 T =   MakePrecise( ( S ) - ( Lhs ) );
	const float4 E =   MakePrecise( ( Rhs ) - ( T ) );
	return MakeDFVector4(S, E);
}
FDFVector4 DFAdd(float4 Lhs, float4 Rhs) { return DFTwoSum(Lhs, Rhs); }
FDFVector4 DFFastAdd(float4 Lhs, float4 Rhs) { return DFTwoSum(Lhs, Rhs); }
FDFVector4 DFAdd(FDFVector4 Lhs, FDFVector4 Rhs)
{
	FDFVector4 S = DFTwoSum(Lhs.High, Rhs.High);
	const FDFVector4 T = DFTwoSum(Lhs.Low, Rhs.Low);
	S.Low += T.High;
	S = DFFastTwoSum(S.High, S.Low);
	S.Low += T.Low;
	S = DFFastTwoSum(S.High, S.Low);
	return S;
}
FDFVector4 DFAdd(FDFVector4 Lhs, float4 Rhs)
{
	const FDFVector4 S = DFTwoSum(Lhs.High, Rhs);
	const float4 T = Lhs.Low + S.Low;
	return DFFastTwoSum(S.High, T);
}
FDFVector4 DFAdd(float4 Lhs, FDFVector4 Rhs) { return DFAdd(Rhs, Lhs); }
FDFVector4 DFFastAdd(FDFVector4 Lhs, FDFVector4 Rhs)
{
	FDFVector4 S = DFTwoSum(Lhs.High, Rhs.High);
	S.Low += Lhs.Low + Rhs.Low;
	S = DFFastTwoSum(S.High, S.Low);
	return S;
}
FDFVector4 DFFastAdd(FDFVector4 Lhs, float4 Rhs)
{
	FDFVector4 S = DFTwoSum(Lhs.High, Rhs);
	S.Low += Lhs.Low;
	S = DFFastTwoSum(S.High, S.Low);
	return S;
}
FDFVector4 DFFastAdd(float4 Lhs, FDFVector4 Rhs) { return DFFastAdd(Rhs, Lhs); }
FDFVector4 DFSubtract(float4 Lhs, float4 Rhs) { return DFAdd(Lhs, -Rhs); }
FDFVector4 DFSubtract(FDFVector4 Lhs, FDFVector4 Rhs) { return DFAdd(Lhs, DFNegate(Rhs)); }
FDFVector4 DFSubtract(FDFVector4 Lhs, float4 Rhs) { return DFAdd(Lhs, -Rhs); }
FDFVector4 DFSubtract(float4 Lhs, FDFVector4 Rhs) { return DFAdd(Lhs, DFNegate(Rhs)); }
FDFVector4 DFFastSubtract(float4 Lhs, float4 Rhs) { return DFFastAdd(Lhs, -Rhs); }
FDFVector4 DFFastSubtract(FDFVector4 Lhs, FDFVector4 Rhs) { return DFFastAdd(Lhs, DFNegate(Rhs)); }
FDFVector4 DFFastSubtract(FDFVector4 Lhs, float4 Rhs) { return DFFastAdd(Lhs, -Rhs); }
FDFVector4 DFFastSubtract(float4 Lhs, FDFVector4 Rhs) { return DFFastAdd(Lhs, DFNegate(Rhs)); }
float4 DFFastLocalSubtractDemote(FDFVector4 Lhs, FDFVector4 Rhs)
{
	const float4 High =   MakePrecise( ( Lhs.High ) - ( Rhs.High ) );
	const float4 Low =   MakePrecise( ( Lhs.Low ) - ( Rhs.Low ) );
	const float4 Sum =   MakePrecise( ( High ) + ( Low ) );
	return Sum;
}
float4 DFFastLocalSubtractDemote(FDFVector4 Lhs, float4 Rhs)
{
	const float4 High =   MakePrecise( ( Lhs.High ) - ( Rhs ) );
	const float4 Sum =   MakePrecise( ( High ) + ( Lhs.Low ) );
	return Sum;
}
float4 DFFastLocalSubtractDemote(float4 Lhs, FDFVector4 Rhs)
{
	return DFFastLocalSubtractDemote(DFPromote(Lhs), Rhs);
}
FDFVector4 DFTwoProduct(float4 Lhs, float4 Rhs)
{
	const float4 P = Lhs * Rhs;
	const float4 E =   MakePrecise(  mad( ( Lhs ) , ( Rhs ) , ( -P ) ) );
	return MakeDFVector4(P, E);
}
FDFVector4 DFMultiply(float4 Lhs, float4 Rhs) { return DFTwoProduct(Lhs, Rhs); }
FDFVector4 DFMultiply(FDFVector4 Lhs, FDFVector4 Rhs)
{
	const FDFVector4 P = DFTwoProduct(Lhs.High, Rhs.High);
	float4 T =   MakePrecise( ( Lhs.High ) * ( Rhs.Low ) );
	T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs.High ) , ( T ) ) );
	T =   MakePrecise( ( T ) + ( P.Low ) );
	return DFFastTwoSum(P.High, T);
}
FDFVector4 DFMultiply(FDFVector4 Lhs, float4 Rhs)
{
	FDFVector4 P = DFTwoProduct(Lhs.High, Rhs);
	float4 T =   MakePrecise(  mad( ( Lhs.Low ) , ( Rhs ) , ( P.Low ) ) );
	return DFFastTwoSum(P.High, T);
}
FDFVector4 DFMultiply(float4 Lhs, FDFVector4 Rhs) { return DFMultiply(Rhs, Lhs); }
FDFVector4 DFFastDivide(FDFVector4 Lhs, FDFVector4 Rhs);
FDFVector4 DFDivide(FDFVector4 Lhs, FDFVector4 Rhs)
{
	const float4 Th =   MakePrecise( ( 1.0 ) / ( Rhs.High ) );
	const float4 Rh =   MakePrecise(  mad( ( -Rhs.High ) , ( Th ) , ( (float4)1 ) ) );
	const float4 Rl =   MakePrecise( ( -Rhs.Low ) * ( Th ) );
	const FDFVector4 E = DFFastTwoSum(Rh, Rl);
	const FDFVector4 D = DFMultiply(E, Th);
	const FDFVector4 M = DFAdd(D, Th);
	return DFMultiply(Lhs, M);
}
FDFVector4 DFDivide(FDFVector4 Lhs, float4 Rhs)
{
	const float4 Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFVector4 P = DFTwoProduct(Th, Rhs);
	const float4 Dh =   MakePrecise( ( Lhs.High ) - ( P.High ) );
	const float4 Dt =   MakePrecise( ( Dh ) - ( P.Low ) );
	const float4 D =   MakePrecise( ( Dt ) + ( Lhs.Low ) );
	const float4 Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector4 DFDivide(float4 Lhs, float4 Rhs)
{
	return DFDivide(DFPromote(Lhs), Rhs);
}
FDFVector4 DFDivide(float4 Lhs, FDFVector4 Rhs)
{
	return DFDivide(DFPromote(Lhs), Rhs);
}
FDFVector4 DFFastDivide(FDFVector4 Lhs, FDFVector4 Rhs)
{
	const float4 Th =   MakePrecise( ( Lhs.High ) / ( Rhs.High ) );
	const FDFVector4 R = DFMultiply(Rhs, Th);
	const float4 Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float4 Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float4 D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float4 Tl =   MakePrecise( ( D ) / ( Rhs.High ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector4 DFFastDivide(FDFVector4 Lhs, float4 Rhs)
{
	const float4 Th =   MakePrecise( ( Lhs.High ) / ( Rhs ) );
	const FDFVector4 R = DFTwoProduct(Rhs, Th);
	const float4 Ph =   MakePrecise( ( Lhs.High ) - ( R.High ) );
	const float4 Dl =   MakePrecise( ( Lhs.Low ) - ( R.Low ) );
	const float4 D =   MakePrecise( ( Ph ) + ( Dl ) );
	const float4 Tl =   MakePrecise( ( D ) / ( Rhs ) );
	return DFFastTwoSum(Th, Tl);
}
FDFVector4 DFFastDivide(float4 Lhs, FDFVector4 Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFVector4 DFFastDivide(float4 Lhs, float4 Rhs) { return DFFastDivide(DFPromote(Lhs), Rhs); }
FDFVector4 DFBroadcast4(FDFScalar V)
{
	const float4 High = V.High;
	const float4 Low = V.Low;
	return MakeDFVector4(High, Low);
}
float4 DFBroadcast4(float V)
{
	const float4 Single = V;
	return Single;
}
FDFVector4  DFAdd (FDFScalar Lhs, FDFVector4 Rhs) { return DFAdd (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFAdd (float Lhs, FDFVector4 Rhs) { return DFAdd (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFAdd (FDFScalar Lhs, float4 Rhs) { return DFAdd (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFAdd (float Lhs, float4 Rhs) { return DFAdd (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFAdd (FDFVector4 Lhs, FDFScalar Rhs) { return DFAdd (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFAdd (FDFVector4 Lhs, float Rhs)     { return DFAdd (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFAdd (float4 Lhs, FDFScalar Rhs) { return DFAdd (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFAdd (float4 Lhs, float Rhs) { return DFAdd (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastAdd (FDFScalar Lhs, FDFVector4 Rhs) { return DFFastAdd (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastAdd (float Lhs, FDFVector4 Rhs) { return DFFastAdd (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastAdd (FDFScalar Lhs, float4 Rhs) { return DFFastAdd (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastAdd (float Lhs, float4 Rhs) { return DFFastAdd (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastAdd (FDFVector4 Lhs, FDFScalar Rhs) { return DFFastAdd (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastAdd (FDFVector4 Lhs, float Rhs)     { return DFFastAdd (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastAdd (float4 Lhs, FDFScalar Rhs) { return DFFastAdd (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastAdd (float4 Lhs, float Rhs) { return DFFastAdd (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFSubtract (FDFScalar Lhs, FDFVector4 Rhs) { return DFSubtract (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFSubtract (float Lhs, FDFVector4 Rhs) { return DFSubtract (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFSubtract (FDFScalar Lhs, float4 Rhs) { return DFSubtract (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFSubtract (float Lhs, float4 Rhs) { return DFSubtract (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFSubtract (FDFVector4 Lhs, FDFScalar Rhs) { return DFSubtract (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFSubtract (FDFVector4 Lhs, float Rhs)     { return DFSubtract (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFSubtract (float4 Lhs, FDFScalar Rhs) { return DFSubtract (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFSubtract (float4 Lhs, float Rhs) { return DFSubtract (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastSubtract (FDFScalar Lhs, FDFVector4 Rhs) { return DFFastSubtract (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastSubtract (float Lhs, FDFVector4 Rhs) { return DFFastSubtract (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastSubtract (FDFScalar Lhs, float4 Rhs) { return DFFastSubtract (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastSubtract (float Lhs, float4 Rhs) { return DFFastSubtract (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastSubtract (FDFVector4 Lhs, FDFScalar Rhs) { return DFFastSubtract (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastSubtract (FDFVector4 Lhs, float Rhs)     { return DFFastSubtract (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastSubtract (float4 Lhs, FDFScalar Rhs) { return DFFastSubtract (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastSubtract (float4 Lhs, float Rhs) { return DFFastSubtract (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFMultiply (FDFScalar Lhs, FDFVector4 Rhs) { return DFMultiply (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFMultiply (float Lhs, FDFVector4 Rhs) { return DFMultiply (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFMultiply (FDFScalar Lhs, float4 Rhs) { return DFMultiply (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFMultiply (float Lhs, float4 Rhs) { return DFMultiply (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFMultiply (FDFVector4 Lhs, FDFScalar Rhs) { return DFMultiply (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFMultiply (FDFVector4 Lhs, float Rhs)     { return DFMultiply (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFMultiply (float4 Lhs, FDFScalar Rhs) { return DFMultiply (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFMultiply (float4 Lhs, float Rhs) { return DFMultiply (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFDivide (FDFScalar Lhs, FDFVector4 Rhs) { return DFDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFDivide (float Lhs, FDFVector4 Rhs) { return DFDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFDivide (FDFScalar Lhs, float4 Rhs) { return DFDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFDivide (float Lhs, float4 Rhs) { return DFDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFDivide (FDFVector4 Lhs, FDFScalar Rhs) { return DFDivide (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFDivide (FDFVector4 Lhs, float Rhs)     { return DFDivide (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFDivide (float4 Lhs, FDFScalar Rhs) { return DFDivide (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFDivide (float4 Lhs, float Rhs) { return DFDivide (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastDivide (FDFScalar Lhs, FDFVector4 Rhs) { return DFFastDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastDivide (float Lhs, FDFVector4 Rhs) { return DFFastDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastDivide (FDFScalar Lhs, float4 Rhs) { return DFFastDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastDivide (float Lhs, float4 Rhs) { return DFFastDivide (DFBroadcast4(Lhs), Rhs); }
FDFVector4  DFFastDivide (FDFVector4 Lhs, FDFScalar Rhs) { return DFFastDivide (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastDivide (FDFVector4 Lhs, float Rhs)     { return DFFastDivide (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastDivide (float4 Lhs, FDFScalar Rhs) { return DFFastDivide (Lhs, DFBroadcast4(Rhs)); }
FDFVector4  DFFastDivide (float4 Lhs, float Rhs) { return DFFastDivide (Lhs, DFBroadcast4(Rhs)); }
struct FDFMatrix
{
	float4x4 M;
	float3 PostTranslation; 
};
float4x4 Make4x3Matrix(float4x4 M)
{
	float4x4 Result;
	Result[0] = float4(M[0].xyz, 0.0f);
	Result[1] = float4(M[1].xyz, 0.0f);
	Result[2] = float4(M[2].xyz, 0.0f);
	Result[3] = float4(M[3].xyz, 1.0f);
	return Result;
}
float4x4 MakeTranslationMatrix(float3 Offset)
{
	float4x4 Result;
	Result[0] = float4(1.0f, 0.0f, 0.0f, 0.0f);
	Result[1] = float4(0.0f, 1.0f, 0.0f, 0.0f);
	Result[2] = float4(0.0f, 0.0f, 1.0f, 0.0f);
	Result[3] = float4(Offset, 1.0f);
	return Result;
}
FDFMatrix MakeDFMatrix4x3(float3 PostTranslation, float4x4 InMatrix)
{
	FDFMatrix Result;
	Result.PostTranslation = PostTranslation;
	Result.M = Make4x3Matrix(InMatrix);
	return Result;
}
FDFMatrix MakeDFMatrix(float3 PostTranslation, float4x4 InMatrix)
{
	FDFMatrix Result;
	Result.PostTranslation = PostTranslation;
	Result.M = InMatrix;
	return Result;
}
struct FDFInverseMatrix
{
	float4x4 M;
	float3 PreTranslation; 
};
FDFInverseMatrix MakeDFInverseMatrix(float3 PreTranslation, float4x4 InMatrix)
{
	FDFInverseMatrix Result;
	Result.PreTranslation = PreTranslation;
	Result.M = InMatrix;
	return Result;
}
FDFInverseMatrix MakeDFInverseMatrix4x3(float3 PreTranslation, float4x4 InMatrix)
{
	FDFInverseMatrix Result;
	Result.PreTranslation = PreTranslation;
	Result.M = Make4x3Matrix(InMatrix);
	return Result;
}
FDFVector3 DFMultiply(float3 Vector, FDFMatrix InMatrix)
{
	float4 Result = mul(float4(Vector, 1), InMatrix.M);
	FDFVector3 V = DFTwoSum(InMatrix.PostTranslation, Result.xyz);
	return V;
}
FDFVector4 DFMultiply(float4 Vector, FDFMatrix InMatrix)
{
	float4 Result = mul(Vector, InMatrix.M);
	FDFVector4 V = DFTwoSum(float4(InMatrix.PostTranslation, 0), Result);
	return V;
}
FDFInverseMatrix DFMultiply(FDFInverseMatrix Lhs, float4x4 Rhs)
{
	float4x4 M = mul(Lhs.M, Rhs);
	float3 PreTranslation = Lhs.PreTranslation;
	return MakeDFInverseMatrix(PreTranslation, M);
}
FDFMatrix DFMultiply(float4x4 Lhs, FDFMatrix Rhs)
{
	float4x4 M = mul(Lhs, Rhs.M);
	float3 PostTranslation = Rhs.PostTranslation;
	return MakeDFMatrix(PostTranslation, M);
}
float4x4 MultiplyTranslation(float4x4 M, float3 Translation)
{
	float4x4 Result = M;
	Result[3].xyz += Translation;
	return Result;
}
float4x4 MultiplyTranslation(float3 Translation, float4x4 M)
{
	return mul(MakeTranslationMatrix(Translation), M);
}
float4x4 DFFastMultiplyTranslationDemote(FDFMatrix Lhs, FDFVector3 Rhs)
{
	float3 Translation = DFFastLocalSubtractDemote(Lhs.PostTranslation, DFNegate(Rhs));
	float4x4 Result = MultiplyTranslation(Lhs.M, Translation);
	return Result;
}
float4x4 DFFastMultiplyTranslationDemote(FDFVector3 Lhs, FDFInverseMatrix Rhs)
{
	float3 Translation = DFFastLocalSubtractDemote(Lhs, Rhs.PreTranslation);
	float4x4 Result = MultiplyTranslation(Translation, Rhs.M);
	return Result;
}
float3x3 DFToFloat3x3(FDFMatrix Value)
{
	return (float3x3)Value.M;
}
float3x3 DFToFloat3x3(FDFInverseMatrix Value)
{
	return (float3x3)Value.M;
}
float3 DFMultiplyVector(float3 Vector, FDFMatrix InMatrix)
{
	return mul(Vector, (float3x3)InMatrix.M);
}
float3 DFMultiplyVector(float3 Vector, FDFInverseMatrix InMatrix)
{
	return mul(Vector, (float3x3)InMatrix.M);
}
FDFMatrix DFPromote(FDFMatrix Value) { return Value; }
FDFMatrix  DFPromote(float4x4 Value) { return MakeDFMatrix((float3)0, Value); }
float4x4 DFDemote(FDFMatrix V)
{
	return MultiplyTranslation(V.M, V.PostTranslation);
}
float4x4 DFDemote(float4x4 V)
{
	return V;
}
float4x4 DFDemote(FDFInverseMatrix V)
{
	return MultiplyTranslation(-V.PreTranslation, V.M);
}
float3 DFFastToTranslatedWorld(FDFVector3 WorldPosition, FDFVector3 PreViewTranslation)
{
	return DFFastLocalSubtractDemote(WorldPosition, DFNegate(PreViewTranslation));
}
float3 DFFastToTranslatedWorld(float3 WorldPosition, FDFVector3 PreViewTranslation)
{
	return DFFastLocalSubtractDemote(WorldPosition, DFNegate(PreViewTranslation));
}
float4x4 DFFastToTranslatedWorld(FDFInverseMatrix WorldToLocal, FDFVector3 PreViewTranslation)
{
	return DFFastMultiplyTranslationDemote(DFNegate(PreViewTranslation), WorldToLocal);
}
float4x4 DFFastToTranslatedWorld(FDFMatrix LocalToWorld, FDFVector3 PreViewTranslation)
{
	return DFFastMultiplyTranslationDemote(LocalToWorld, PreViewTranslation);
}
FDFVector3 DFMultiplyLHSAndFastTwoSum(float3 Lhs, float Factor, float3 Rhs)
{
	const float3 S =  MakePrecise(  mad( Lhs , Factor , Rhs ) );
	const float3 E =  MakePrecise( Rhs -  mad( -Lhs , Factor , S ) );
	return MakeDFVector3(S, E);
}
FDFMatrix WaveReadLaneAt(FDFMatrix In, uint SrcIndex)
{
	FDFMatrix Result;
	Result.M[0] = WaveReadLaneAt(In.M[0], SrcIndex);
	Result.M[1] = WaveReadLaneAt(In.M[1], SrcIndex);
	Result.M[2] = WaveReadLaneAt(In.M[2], SrcIndex);
	Result.M[3] = WaveReadLaneAt(In.M[3], SrcIndex);
	Result.PostTranslation = WaveReadLaneAt(In.PostTranslation, SrcIndex);
	return Result;
}
FDFInverseMatrix WaveReadLaneAt(FDFInverseMatrix In, uint SrcIndex)
{
	FDFInverseMatrix Result;
	Result.M[0] = WaveReadLaneAt(In.M[0], SrcIndex);
	Result.M[1] = WaveReadLaneAt(In.M[1], SrcIndex);
	Result.M[2] = WaveReadLaneAt(In.M[2], SrcIndex);
	Result.M[3] = WaveReadLaneAt(In.M[3], SrcIndex);
	Result.PreTranslation = WaveReadLaneAt(In.PreTranslation, SrcIndex);
	return Result;
}
struct FLWCScalar
{
	float Tile;
	float Offset;
};
struct FLWCVector2
{
	float2 Tile;
	float2 Offset;
};
struct FLWCVector3
{
	float3 Tile;
	float3 Offset;
};
struct FLWCVector4
{
	float4 Tile;
	float4 Offset;
};
struct FLWCVector2Deriv
{
	FLWCVector2 Value;
	float2 Ddx;
	float2 Ddy;
};
struct FLWCVector3Deriv
{
	FLWCVector3 Value;
	float3 Ddx;
	float3 Ddy;
};
struct FLWCMatrix
{
	float4x4 M;
	float3 Tile; 
};
struct FLWCInverseMatrix
{
	float4x4 M;
	float3 Tile; 
};
float LWCGetTileOffset(FLWCScalar V) { return  (( V ).Tile) * 2097152.00f; }
float2 LWCGetTileOffset(FLWCVector2 V) { return  (( V ).Tile) * 2097152.00f; }
float3 LWCGetTileOffset(FLWCVector3 V) { return  (( V ).Tile) * 2097152.00f; }
float4 LWCGetTileOffset(FLWCVector4 V) { return  (( V ).Tile) * 2097152.00f; }
float3 LWCGetTileOffset(FLWCMatrix V) { return  (( V ).Tile) * 2097152.00f; }
float3 LWCGetTileOffset(FLWCInverseMatrix V) { return  (( V ).Tile) * 2097152.00f; }
FLWCScalar MakeLWCScalar(float Tile, float Offset)
{
	FLWCScalar Result;
	 ( Result ).Tile = ( Tile );
	Result.Offset = Offset;
	return Result;
}
FLWCVector2 MakeLWCVector2(float2 Tile, float2 Offset)
{
	FLWCVector2 Result;
	 ( Result ).Tile = ( Tile );
	Result.Offset = Offset;
	return Result;
}
FLWCVector3 MakeLWCVector3(float3 Tile, float3 Offset)
{
	FLWCVector3 Result;
	 ( Result ).Tile = ( Tile );
	Result.Offset = Offset;
	return Result;
}
FLWCVector4 MakeLWCVector4(float4 Tile, float4 Offset)
{
	FLWCVector4 Result;
	 ( Result ).Tile = ( Tile );
	Result.Offset = Offset;
	return Result;
}
FLWCVector4 MakeLWCVector4(float3 Tile, float4 Offset)
{
	return MakeLWCVector4(float4(Tile, 0), Offset);
}
FLWCVector4 MakeLWCVector4(FLWCVector3 XYZ, float W)
{
	return MakeLWCVector4( (( XYZ ).Tile), float4(XYZ.Offset, W));
}
FLWCScalar MakeLWCVector(FLWCScalar X) { return X; }
FLWCVector2 MakeLWCVector(FLWCScalar X, FLWCScalar Y) { return MakeLWCVector2(float2( (( X ).Tile),  (( Y ).Tile)), float2(X.Offset, Y.Offset)); }
FLWCVector3 MakeLWCVector(FLWCScalar X, FLWCScalar Y, FLWCScalar Z) { return MakeLWCVector3(float3( (( X ).Tile),  (( Y ).Tile),  (( Z ).Tile)), float3(X.Offset, Y.Offset, Z.Offset)); }
FLWCVector3 MakeLWCVector(FLWCScalar X, FLWCVector2 YZ) { return MakeLWCVector3(float3( (( X ).Tile),  (( YZ ).Tile)), float3(X.Offset, YZ.Offset)); }
FLWCVector3 MakeLWCVector(FLWCVector2 XY, FLWCScalar Z) { return MakeLWCVector3(float3( (( XY ).Tile),  (( Z ).Tile)), float3(XY.Offset, Z.Offset)); }
FLWCVector4 MakeLWCVector(FLWCScalar X, FLWCScalar Y, FLWCScalar Z, FLWCScalar W) { return MakeLWCVector4(float4( (( X ).Tile),  (( Y ).Tile),  (( Z ).Tile),  (( W ).Tile)), float4(X.Offset, Y.Offset, Z.Offset, W.Offset)); }
FLWCVector4 MakeLWCVector(FLWCScalar X, FLWCScalar Y, FLWCVector2 ZW) { return MakeLWCVector4(float4( (( X ).Tile),  (( Y ).Tile),  (( ZW ).Tile)), float4(X.Offset, Y.Offset, ZW.Offset)); }
FLWCVector4 MakeLWCVector(FLWCScalar X, FLWCVector2 YZ, FLWCScalar W) { return MakeLWCVector4(float4( (( X ).Tile),  (( YZ ).Tile),  (( W ).Tile)), float4(X.Offset, YZ.Offset, W.Offset)); }
FLWCVector4 MakeLWCVector(FLWCVector2 XY, FLWCScalar Z, FLWCScalar W) { return MakeLWCVector4(float4( (( XY ).Tile),  (( Z ).Tile),  (( W ).Tile)), float4(XY.Offset, Z.Offset, W.Offset)); }
FLWCVector4 MakeLWCVector(FLWCVector2 XY, FLWCVector2 ZW) { return MakeLWCVector4(float4( (( XY ).Tile),  (( ZW ).Tile)), float4(XY.Offset, ZW.Offset)); }
FLWCVector4 MakeLWCVector(FLWCScalar X, FLWCVector3 YZW) { return MakeLWCVector4(float4( (( X ).Tile),  (( YZW ).Tile)), float4(X.Offset, YZW.Offset)); }
FLWCVector4 MakeLWCVector(FLWCVector3 XYZ, FLWCScalar W) { return MakeLWCVector4(float4( (( XYZ ).Tile),  (( W ).Tile)), float4(XYZ.Offset, W.Offset)); }
FLWCMatrix MakeLWCMatrix(float3 Tile, float4x4 InMatrix)
{
	FLWCMatrix Result;
	 ( Result ).Tile = ( Tile );
	Result.M = InMatrix;
	return Result;
}
FLWCInverseMatrix MakeLWCInverseMatrix(float3 Tile, float4x4 InMatrix)
{
	FLWCInverseMatrix Result;
	 ( Result ).Tile = ( -Tile );
	Result.M = InMatrix;
	return Result;
}
FLWCScalar LWCGetComponent(FLWCScalar V, int C) { return V; }
FLWCScalar LWCGetComponent(FLWCVector2 V, int C) { return MakeLWCScalar( (( V ).Tile)[C], V.Offset[C]); }
FLWCScalar LWCGetComponent(FLWCVector3 V, int C) { return MakeLWCScalar( (( V ).Tile)[C], V.Offset[C]); }
FLWCScalar LWCGetComponent(FLWCVector4 V, int C) { return MakeLWCScalar( (( V ).Tile)[C], V.Offset[C]); }
float LWCToFloat(FLWCScalar Value)   { return LWCGetTileOffset(Value) + Value.Offset; }
float2 LWCToFloat(FLWCVector2 Value) { return LWCGetTileOffset(Value) + Value.Offset; }
float3 LWCToFloat(FLWCVector3 Value) { return LWCGetTileOffset(Value) + Value.Offset; }
float4 LWCToFloat(FLWCVector4 Value) { return LWCGetTileOffset(Value) + Value.Offset; }
float4x4 LWCToFloat(FLWCMatrix Value)
{
	float4x4 Result = Value.M;
	Result[3].xyz = LWCGetTileOffset(Value) + Result[3].xyz;
	return Result;
}
float4x4 LWCToFloat(FLWCInverseMatrix Value)
{
	float4x4 TileOffset = MakeTranslationMatrix(LWCGetTileOffset(Value));
	return mul(TileOffset, Value.M);
}
float LWCToFloat(float Value) { return Value; }
float2 LWCToFloat(float2 Value) { return Value; }
float3 LWCToFloat(float3 Value) { return Value; }
float4 LWCToFloat(float4 Value) { return Value; }
float4x4 LWCToFloat(float4x4 Value) { return Value; }
FLWCVector3 LWCMultiply(float3 Position, FLWCMatrix InMatrix)
{
	float3 Offset = (Position.xxx * InMatrix.M[0].xyz + Position.yyy * InMatrix.M[1].xyz + Position.zzz * InMatrix.M[2].xyz) + InMatrix.M[3].xyz;
	return MakeLWCVector3( (( InMatrix ).Tile), Offset);
}
FLWCVector4 LWCMultiply(float4 Position, FLWCMatrix InMatrix)
{
	float4 Offset = mul(Position, InMatrix.M);
	return MakeLWCVector4( (( InMatrix ).Tile), Offset);
}
float3 LWCMultiply(FLWCVector3 Position, FLWCInverseMatrix InMatrix)
{
	float3 LocalPosition = LWCToFloat(MakeLWCVector3( (( Position ).Tile) +  (( InMatrix ).Tile), Position.Offset));
	return (LocalPosition.xxx * InMatrix.M[0].xyz + LocalPosition.yyy * InMatrix.M[1].xyz + LocalPosition.zzz * InMatrix.M[2].xyz) + InMatrix.M[3].xyz;
}
float4 LWCMultiply(FLWCVector4 Position, FLWCInverseMatrix InMatrix)
{
	float4 LocalPosition = LWCToFloat(MakeLWCVector4( (( Position ).Tile) + float4( (( InMatrix ).Tile), 0), Position.Offset));
	return mul(LocalPosition, InMatrix.M);
}
FLWCMatrix LWCMultiply(float4x4 Lhs, FLWCMatrix Rhs)
{
	float4x4 ResultMatrix = mul(Lhs, Rhs.M);
	return MakeLWCMatrix( (( Rhs ).Tile), ResultMatrix);
}
FLWCInverseMatrix LWCMultiply(FLWCInverseMatrix Lhs, float4x4 Rhs)
{
	float4x4 ResultMatrix = mul(Lhs.M, Rhs);
	return MakeLWCInverseMatrix(- (( Lhs ).Tile), ResultMatrix);
}
float4x4 LWCMultiply(FLWCMatrix Lhs, FLWCInverseMatrix Rhs)
{
	float4x4 Result = Lhs.M;
	Result = mul(Result, MakeTranslationMatrix(( (( Lhs ).Tile) +  (( Rhs ).Tile)) * 2097152.00f));
	Result = mul(Result, Rhs.M);
	return Result;
}
FLWCScalar LWCSubtract(FLWCScalar Lhs, FLWCScalar Rhs) { return MakeLWCScalar( (( Lhs ).Tile) -  (( Rhs ).Tile), Lhs.Offset - Rhs.Offset); }
FLWCScalar LWCSubtract(float Lhs, FLWCScalar Rhs) { return MakeLWCScalar(- (( Rhs ).Tile), Lhs - Rhs.Offset); }
FLWCScalar LWCSubtract(FLWCScalar Lhs, float Rhs) { return MakeLWCScalar( (( Lhs ).Tile), Lhs.Offset - Rhs); }
FLWCScalar LWCMultiply(FLWCScalar Lhs, FLWCScalar Rhs)
{
	return MakeLWCScalar( (( Lhs ).Tile) * ( (( Rhs ).Tile) * 2097152.00f + Rhs.Offset) +  (( Rhs ).Tile) * Lhs.Offset, Lhs.Offset * Rhs.Offset);
}
FLWCScalar LWCMultiply(float Lhs, FLWCScalar Rhs) { return MakeLWCScalar( (( Rhs ).Tile) * Lhs, Lhs * Rhs.Offset); }
FLWCScalar LWCMultiply(FLWCScalar Lhs, float Rhs) { return MakeLWCScalar( (( Lhs ).Tile) * Rhs, Lhs.Offset * Rhs); }
FLWCVector2 LWCSubtract(FLWCVector2 Lhs, FLWCVector2 Rhs) { return MakeLWCVector2( (( Lhs ).Tile) -  (( Rhs ).Tile), Lhs.Offset - Rhs.Offset); }
FLWCVector2 LWCSubtract(float2 Lhs, FLWCVector2 Rhs) { return MakeLWCVector2(- (( Rhs ).Tile), Lhs - Rhs.Offset); }
FLWCVector2 LWCSubtract(FLWCVector2 Lhs, float2 Rhs) { return MakeLWCVector2( (( Lhs ).Tile), Lhs.Offset - Rhs); }
FLWCVector2 LWCMultiply(FLWCVector2 Lhs, FLWCVector2 Rhs)
{
	return MakeLWCVector2( (( Lhs ).Tile) * ( (( Rhs ).Tile) * 2097152.00f + Rhs.Offset) +  (( Rhs ).Tile) * Lhs.Offset, Lhs.Offset * Rhs.Offset);
}
FLWCVector2 LWCMultiply(float2 Lhs, FLWCVector2 Rhs) { return MakeLWCVector2( (( Rhs ).Tile) * Lhs, Lhs * Rhs.Offset); }
FLWCVector2 LWCMultiply(FLWCVector2 Lhs, float2 Rhs) { return MakeLWCVector2( (( Lhs ).Tile) * Rhs, Lhs.Offset * Rhs); }
FLWCVector3 LWCSubtract(FLWCVector3 Lhs, FLWCVector3 Rhs) { return MakeLWCVector3( (( Lhs ).Tile) -  (( Rhs ).Tile), Lhs.Offset - Rhs.Offset); }
FLWCVector3 LWCSubtract(float3 Lhs, FLWCVector3 Rhs) { return MakeLWCVector3(- (( Rhs ).Tile), Lhs - Rhs.Offset); }
FLWCVector3 LWCSubtract(FLWCVector3 Lhs, float3 Rhs) { return MakeLWCVector3( (( Lhs ).Tile), Lhs.Offset - Rhs); }
FLWCVector3 LWCMultiply(FLWCVector3 Lhs, FLWCVector3 Rhs)
{
	return MakeLWCVector3( (( Lhs ).Tile) * ( (( Rhs ).Tile) * 2097152.00f + Rhs.Offset) +  (( Rhs ).Tile) * Lhs.Offset, Lhs.Offset * Rhs.Offset);
}
FLWCVector3 LWCMultiply(float3 Lhs, FLWCVector3 Rhs) { return MakeLWCVector3( (( Rhs ).Tile) * Lhs, Lhs * Rhs.Offset); }
FLWCVector3 LWCMultiply(FLWCVector3 Lhs, float3 Rhs) { return MakeLWCVector3( (( Lhs ).Tile) * Rhs, Lhs.Offset * Rhs); }
FLWCVector4 LWCSubtract(FLWCVector4 Lhs, FLWCVector4 Rhs) { return MakeLWCVector4( (( Lhs ).Tile) -  (( Rhs ).Tile), Lhs.Offset - Rhs.Offset); }
FLWCVector4 LWCSubtract(float4 Lhs, FLWCVector4 Rhs) { return MakeLWCVector4(- (( Rhs ).Tile), Lhs - Rhs.Offset); }
FLWCVector4 LWCSubtract(FLWCVector4 Lhs, float4 Rhs) { return MakeLWCVector4( (( Lhs ).Tile), Lhs.Offset - Rhs); }
FLWCVector4 LWCMultiply(FLWCVector4 Lhs, FLWCVector4 Rhs)
{
	return MakeLWCVector4( (( Lhs ).Tile) * ( (( Rhs ).Tile) * 2097152.00f + Rhs.Offset) +  (( Rhs ).Tile) * Lhs.Offset, Lhs.Offset * Rhs.Offset);
}
FLWCVector4 LWCMultiply(float4 Lhs, FLWCVector4 Rhs) { return MakeLWCVector4( (( Rhs ).Tile) * Lhs, Lhs * Rhs.Offset); }
FLWCVector4 LWCMultiply(FLWCVector4 Lhs, float4 Rhs) { return MakeLWCVector4( (( Lhs ).Tile) * Rhs, Lhs.Offset * Rhs); }
FLWCScalar DFToTileOffset( FDFScalar In)																								{ float Tile =  MakePrecise( round(In.High / 2097152.00f) ); float Offset =   MakePrecise( (   MakePrecise(  mad( ( Tile ) , ( -2097152.00f ) , ( In.High ) ) ) ) + ( In.Low ) );																																								return MakeLWCScalar (Tile, Offset);																						}
FLWCVector2 DFToTileOffset( FDFVector2 In)																								{ float2 Tile =  MakePrecise( round(In.High / 2097152.00f) ); float2 Offset =   MakePrecise( (   MakePrecise(  mad( ( Tile ) , ( -2097152.00f ) , ( In.High ) ) ) ) + ( In.Low ) );																																								return MakeLWCVector2 (Tile, Offset);																						}
FLWCVector3 DFToTileOffset( FDFVector3 In)																								{ float3 Tile =  MakePrecise( round(In.High / 2097152.00f) ); float3 Offset =   MakePrecise( (   MakePrecise(  mad( ( Tile ) , ( -2097152.00f ) , ( In.High ) ) ) ) + ( In.Low ) );																																								return MakeLWCVector3 (Tile, Offset);																						}
FLWCVector4 DFToTileOffset( FDFVector4 In)																								{ float4 Tile =  MakePrecise( round(In.High / 2097152.00f) ); float4 Offset =   MakePrecise( (   MakePrecise(  mad( ( Tile ) , ( -2097152.00f ) , ( In.High ) ) ) ) + ( In.Low ) );																																								return MakeLWCVector4 (Tile, Offset);																						}
FLWCScalar DFFastToTileOffset( FDFScalar In)																							{ float Tile = In.High * (1 / 2097152.00f); float Offset = In.Low; 																																																									return MakeLWCScalar (Tile, Offset);																						}
FLWCVector2 DFFastToTileOffset( FDFVector2 In)																							{ float2 Tile = In.High * (1 / 2097152.00f); float2 Offset = In.Low; 																																																									return MakeLWCVector2 (Tile, Offset);																						}
FLWCVector3 DFFastToTileOffset( FDFVector3 In)																							{ float3 Tile = In.High * (1 / 2097152.00f); float3 Offset = In.Low; 																																																									return MakeLWCVector3 (Tile, Offset);																						}
FLWCVector4 DFFastToTileOffset( FDFVector4 In)																							{ float4 Tile = In.High * (1 / 2097152.00f); float4 Offset = In.Low; 																																																									return MakeLWCVector4 (Tile, Offset);																						}
FLWCMatrix DFToTileOffset(FDFMatrix In)
{
	FLWCVector3 PosHigh = DFToTileOffset(MakeDFVector3(In.PostTranslation, 0));
	float4x4 M = MultiplyTranslation(In.M, PosHigh.Offset);
	float3 Tile = PosHigh.Tile;
	return MakeLWCMatrix(Tile, M);
}
FLWCMatrix DFFastToTileOffset(FDFMatrix In)
{
	float4x4 M = In.M;
	float3 Tile = In.PostTranslation / 2097152.00f;
	return MakeLWCMatrix(Tile, M);
}
FLWCInverseMatrix DFToTileOffset(FDFInverseMatrix In)
{
	FLWCVector3 PosHigh = DFToTileOffset(MakeDFVector3(In.PreTranslation, 0));
	float4x4 M = MultiplyTranslation(-PosHigh.Offset, In.M);
	float3 Tile = PosHigh.Tile;
	return MakeLWCInverseMatrix(Tile, M);
}
FLWCInverseMatrix DFFastToTileOffset(FDFInverseMatrix In)
{
	float4x4 M = In.M;
	float3 Tile = In.PreTranslation / 2097152.00f;
	return MakeLWCInverseMatrix(Tile, M);
}
FDFScalar DFFromTileOffset(FLWCScalar In)
{
	float TileOffset = In.Tile * 2097152.00f;
	return DFFastTwoSum(TileOffset, In.Offset);
}
FDFVector2 DFFromTileOffset(FLWCVector2 In)
{
	float2 TileOffset = In.Tile * 2097152.00f;
	return DFFastTwoSum(TileOffset, In.Offset);
}
FDFVector3 DFFromTileOffset(FLWCVector3 In)
{
	float3 TileOffset = In.Tile * 2097152.00f;
	return DFFastTwoSum(TileOffset, In.Offset);
}
FDFVector4 DFFromTileOffset(FLWCVector4 In)
{
	float4 TileOffset = In.Tile * 2097152.00f;
	return DFFastTwoSum(TileOffset, In.Offset);
}
FDFMatrix DFFromTileOffset(FLWCMatrix In)
{
	float4x4 M = In.M;
	float3 PostTranslation = In.Tile * 2097152.00f;
	return MakeDFMatrix(PostTranslation, M);
}
FDFInverseMatrix DFFromTileOffset(FLWCInverseMatrix In)
{
	float4x4 M = In.M;
	float3 PreTranslation = -In.Tile * 2097152.00f;
	return MakeDFInverseMatrix(PreTranslation, M);
}
float LWCToFloat(FDFScalar Value)   { return DFDemote(Value); }
float2 LWCToFloat(FDFVector2 Value) { return DFDemote(Value); }
float3 LWCToFloat(FDFVector3 Value) { return DFDemote(Value); }
float4 LWCToFloat(FDFVector4 Value) { return DFDemote(Value); }
float4x4 LWCToFloat(FDFMatrix Value) { return DFDemote(Value); }
float4x4 LWCToFloat(FDFInverseMatrix Value) { return DFDemote(Value); }
FLWCMatrix WaveReadLaneAt(FLWCMatrix In, uint SrcIndex)
{
	FLWCMatrix Result;
	Result.M[0] = WaveReadLaneAt(In.M[0], SrcIndex);
	Result.M[1] = WaveReadLaneAt(In.M[1], SrcIndex);
	Result.M[2] = WaveReadLaneAt(In.M[2], SrcIndex);
	Result.M[3] = WaveReadLaneAt(In.M[3], SrcIndex);
	Result.Tile = WaveReadLaneAt(In.Tile, SrcIndex);
	return Result;
}
FLWCInverseMatrix WaveReadLaneAt(FLWCInverseMatrix In, uint SrcIndex)
{
	FLWCInverseMatrix Result;
	Result.M[0] = WaveReadLaneAt(In.M[0], SrcIndex);
	Result.M[1] = WaveReadLaneAt(In.M[1], SrcIndex);
	Result.M[2] = WaveReadLaneAt(In.M[2], SrcIndex);
	Result.M[3] = WaveReadLaneAt(In.M[3], SrcIndex);
	Result.Tile = WaveReadLaneAt(In.Tile, SrcIndex);
	return Result;
}
struct FViewConstants {
	 float4x4    TranslatedWorldToClip ;
	 float4x4    RelativeWorldToClip ;
	 float4x4    ClipToRelativeWorld ;
	 float4x4    TranslatedWorldToView ;
	 float4x4    ViewToTranslatedWorld ;
	 float4x4    TranslatedWorldToCameraView ;
	 float4x4    CameraViewToTranslatedWorld ;
	 float4x4    ViewToClip ;
	 float4x4    ViewToClipNoAA ;
	 float4x4    ClipToView ;
	 float4x4    ClipToTranslatedWorld ;
	 float4x4    SVPositionToTranslatedWorld ;
	 float4x4    ScreenToRelativeWorld ;
	 float4x4    ScreenToTranslatedWorld ;
	 float4x4    MobileMultiviewShadowTransform ;
	 float3    ViewOriginHigh ;
	 float    Padding972 ;
	 float3    ViewForward ;
	 float    Padding988 ;
	 float3    ViewUp ;
	 float    Padding1004 ;
	 float3    ViewRight ;
	 float    Padding1020 ;
	 float3    HMDViewNoRollUp ;
	 float    Padding1036 ;
	 float3    HMDViewNoRollRight ;
	 float    Padding1052 ;
	 float4    InvDeviceZToWorldZTransform ;
	 float4    ScreenPositionScaleBias ;
	 float3    ViewOriginLow ;
	 float    Padding1100 ;
	 float3    TranslatedWorldCameraOrigin ;
	 float    Padding1116 ;
	 float3    WorldViewOriginHigh ;
	 float    Padding1132 ;
	 float3    WorldViewOriginLow ;
	 float    Padding1148 ;
	 float3    PreViewTranslationHigh ;
	 float    Padding1164 ;
	 float3    PreViewTranslationLow ;
	 float    Padding1180 ;
	 float4x4    PrevViewToClip ;
	 float4x4    PrevClipToView ;
	 float4x4    PrevTranslatedWorldToClip ;
	 float4x4    PrevTranslatedWorldToView ;
	 float4x4    PrevViewToTranslatedWorld ;
	 float4x4    PrevTranslatedWorldToCameraView ;
	 float4x4    PrevCameraViewToTranslatedWorld ;
	 float3    PrevTranslatedWorldCameraOrigin ;
	 float    Padding1644 ;
	 float3    PrevWorldCameraOriginHigh ;
	 float    Padding1660 ;
	 float3    PrevWorldCameraOriginLow ;
	 float    Padding1676 ;
	 float3    PrevWorldViewOriginHigh ;
	 float    Padding1692 ;
	 float3    PrevWorldViewOriginLow ;
	 float    Padding1708 ;
	 float3    PrevPreViewTranslationHigh ;
	 float    Padding1724 ;
	 float3    PrevPreViewTranslationLow ;
	 float    Padding1740 ;
	 float3    ViewTilePosition ;
	 float    Padding1756 ;
	 float3    RelativeWorldCameraOriginTO ;
	 float    Padding1772 ;
	 float3    RelativeWorldViewOriginTO ;
	 float    Padding1788 ;
	 float3    RelativePreViewTranslationTO ;
	 float    Padding1804 ;
	 float3    PrevRelativeWorldCameraOriginTO ;
	 float    Padding1820 ;
	 float3    PrevRelativeWorldViewOriginTO ;
	 float    Padding1836 ;
	 float3    RelativePrevPreViewTranslationTO ;
	 float    Padding1852 ;
	 float4x4    PrevClipToRelativeWorld ;
	 float4x4    PrevScreenToTranslatedWorld ;
	 float4x4    ClipToPrevClip ;
	 float4x4    ClipToPrevClipWithAA ;
	 float4    TemporalAAJitter ;
	 float4    GlobalClippingPlane ;
	 float2    FieldOfViewWideAngles ;
	 float2    PrevFieldOfViewWideAngles ;
	 float4    ViewRectMin ;
	 float4    ViewSizeAndInvSize ;
	 uint4    ViewRectMinAndSize ;
	 float4    LightProbeSizeRatioAndInvSizeRatio ;
	 float4    BufferSizeAndInvSize ;
	 float4    BufferBilinearUVMinMax ;
	 float4    ScreenToViewSpace ;
	 float2    BufferToSceneTextureScale ;
	 float2    ResolutionFractionAndInv ;
	 int    NumSceneColorMSAASamples ;
	 float    ProjectionDepthThicknessScale ;
	 float    PreExposure ;
	 float    OneOverPreExposure ;
	 float4    DiffuseOverrideParameter ;
	 float4    SpecularOverrideParameter ;
	 float4    NormalOverrideParameter ;
	 float2    RoughnessOverrideParameter ;
	 float    PrevFrameGameTime ;
	 float    PrevFrameRealTime ;
	 float    OutOfBoundsMask ;
	 float    Padding2372 ;
	 float    Padding2376 ;
	 float    Padding2380 ;
	 float3    WorldCameraMovementSinceLastFrame ;
	 float    CullingSign ;
	 float    NearPlane ;
	 float    GameTime ;
	 float    RealTime ;
	 float    DeltaTime ;
	 float    MaterialTextureMipBias ;
	 float    MaterialTextureDerivativeMultiply ;
	 uint    Random ;
	 uint    FrameNumber ;
	 uint    FrameCounter ;
	 uint    StateFrameIndexMod8 ;
	 uint    StateFrameIndex ;
	 uint    DebugViewModeMask ;
	 uint    WorldIsPaused ;
	 float    CameraCut ;
	 float    UnlitViewmodeMask ;
	 float    Padding2460 ;
	 float4    DirectionalLightColor ;
	 float3    DirectionalLightDirection ;
	 float    Padding2492 ;
	 float4    TranslucencyLightingVolumeMin[2] ;
	 float4    TranslucencyLightingVolumeInvSize[2] ;
	 float4    TemporalAAParams ;
	 float4    CircleDOFParams ;
	 float    DepthOfFieldSensorWidth ;
	 float    DepthOfFieldFocalDistance ;
	 float    DepthOfFieldScale ;
	 float    DepthOfFieldFocalLength ;
	 float    DepthOfFieldFocalRegion ;
	 float    DepthOfFieldNearTransitionRegion ;
	 float    DepthOfFieldFarTransitionRegion ;
	 float    MotionBlurNormalizedToPixel ;
	 float    GeneralPurposeTweak ;
	 float    GeneralPurposeTweak2 ;
	 float    DemosaicVposOffset ;
	 float    DecalDepthBias ;
	 float3    IndirectLightingColorScale ;
	 float    Padding2652 ;
	 float3    PrecomputedIndirectLightingColorScale ;
	 float    Padding2668 ;
	 float3    PrecomputedIndirectSpecularColorScale ;
	 float    Padding2684 ;
	 float4    AtmosphereLightDirection[2] ;
	 float4    AtmosphereLightIlluminanceOnGroundPostTransmittance[2] ;
	 float4    AtmosphereLightIlluminanceOuterSpace[2] ;
	 float4    AtmosphereLightDiscLuminance[2] ;
	 float4    AtmosphereLightDiscCosHalfApexAngle_PPTrans[2] ;
	 float4    SkyViewLutSizeAndInvSize ;
	 float3    SkyCameraTranslatedWorldOrigin ;
	 float    Padding2876 ;
	 float4    SkyPlanetTranslatedWorldCenterAndViewHeight ;
	 float4x4    SkyViewLutReferential ;
	 float4    SkyAtmosphereSkyLuminanceFactor ;
	 float    SkyAtmospherePresentInScene ;
	 float    SkyAtmosphereHeightFogContribution ;
	 float    SkyAtmosphereBottomRadiusKm ;
	 float    SkyAtmosphereTopRadiusKm ;
	 float4    SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize ;
	 float    SkyAtmosphereAerialPerspectiveStartDepthKm ;
	 float    SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution ;
	 float    SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv ;
	 float    SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm ;
	 float    SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv ;
	 float    SkyAtmosphereApplyCameraAerialPerspectiveVolume ;
	 float    Padding3032 ;
	 float    Padding3036 ;
	 float3    NormalCurvatureToRoughnessScaleBias ;
	 float    RenderingReflectionCaptureMask ;
	 float    RealTimeReflectionCapture ;
	 float    RealTimeReflectionCapturePreExposure ;
	 float    Padding3064 ;
	 float    Padding3068 ;
	 float4    AmbientCubemapTint ;
	 float    AmbientCubemapIntensity ;
	 float    SkyLightApplyPrecomputedBentNormalShadowingFlag ;
	 float    SkyLightAffectReflectionFlag ;
	 float    SkyLightAffectGlobalIlluminationFlag ;
	 float4    SkyLightColor ;
	 float    SkyLightVolumetricScatteringIntensity ;
	 float    Padding3124 ;
	 float    Padding3128 ;
	 float    Padding3132 ;
	 float4    MobileSkyIrradianceEnvironmentMap[8] ;
	 float    MobilePreviewMode ;
	 float    HMDEyePaddingOffset ;
	 float    ReflectionCubemapMaxMip ;
	 float    ShowDecalsMask ;
	 uint    DistanceFieldAOSpecularOcclusionMode ;
	 float    IndirectCapsuleSelfShadowingIntensity ;
	 float    Padding3288 ;
	 float    Padding3292 ;
	 float3    ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight ;
	 int    StereoPassIndex ;
	 float4    GlobalVolumeTranslatedCenterAndExtent[6] ;
	 float4    GlobalVolumeTranslatedWorldToUVAddAndMul[6] ;
	 float4    GlobalDistanceFieldMipTranslatedWorldToUVScale[6] ;
	 float4    GlobalDistanceFieldMipTranslatedWorldToUVBias[6] ;
	 float    GlobalDistanceFieldMipFactor ;
	 float    GlobalDistanceFieldMipTransition ;
	 int    GlobalDistanceFieldClipmapSizeInPages ;
	 int    Padding3708 ;
	 float3    GlobalDistanceFieldInvPageAtlasSize ;
	 float    Padding3724 ;
	 float3    GlobalDistanceFieldInvCoverageAtlasSize ;
	 float    GlobalVolumeDimension ;
	 float    GlobalVolumeTexelSize ;
	 float    MaxGlobalDFAOConeDistance ;
	 uint    NumGlobalSDFClipmaps ;
	 float    CoveredExpandSurfaceScale ;
	 float    NotCoveredExpandSurfaceScale ;
	 float    NotCoveredMinStepScale ;
	 float    DitheredTransparencyStepThreshold ;
	 float    DitheredTransparencyTraceThreshold ;
	 int2    CursorPosition ;
	 float    bCheckerboardSubsurfaceProfileRendering ;
	 float    Padding3788 ;
	 float3    VolumetricFogInvGridSize ;
	 float    Padding3804 ;
	 float3    VolumetricFogGridZParams ;
	 float    Padding3820 ;
	 float2    VolumetricFogSVPosToVolumeUV ;
	 float2    VolumetricFogViewGridUVToPrevViewRectUV ;
	 float2    VolumetricFogPrevViewGridRectUVToResourceUV ;
	 float2    VolumetricFogPrevUVMax ;
	 float2    VolumetricFogPrevUVMaxForTemporalBlend ;
	 float2    VolumetricFogScreenToResourceUV ;
	 float2    VolumetricFogUVMax ;
	 float    VolumetricFogMaxDistance ;
	 float    Padding3884 ;
	 float3    VolumetricLightmapWorldToUVScale ;
	 float    Padding3900 ;
	 float3    VolumetricLightmapWorldToUVAdd ;
	 float    Padding3916 ;
	 float3    VolumetricLightmapIndirectionTextureSize ;
	 float    VolumetricLightmapBrickSize ;
	 float3    VolumetricLightmapBrickTexelSize ;
	 float    IndirectLightingCacheShowFlag ;
	 float    EyeToPixelSpreadAngle ;
	 float    Padding3956 ;
	 float    Padding3960 ;
	 float    Padding3964 ;
	 float4    XRPassthroughCameraUVs[2] ;
	 float    GlobalVirtualTextureMipBias ;
	 uint    VirtualTextureFeedbackShift ;
	 uint    VirtualTextureFeedbackMask ;
	 uint    VirtualTextureFeedbackStride ;
	 uint    VirtualTextureFeedbackJitterOffset ;
	 uint    VirtualTextureFeedbackSampleOffset ;
	 uint    Padding4024 ;
	 uint    Padding4028 ;
	 float4    RuntimeVirtualTextureMipLevel ;
	 float2    RuntimeVirtualTexturePackHeight ;
	 float    Padding4056 ;
	 float    Padding4060 ;
	 float4    RuntimeVirtualTextureDebugParams ;
	 int    FarShadowStaticMeshLODBias ;
	 float    MinRoughness ;
	 float    Padding4088 ;
	 float    Padding4092 ;
	 float4    HairRenderInfo ;
	 uint    EnableSkyLight ;
	 uint    HairRenderInfoBits ;
	 uint    HairComponents ;
	 float    bSubsurfacePostprocessEnabled ;
	 float4    SSProfilesTextureSizeAndInvSize ;
	 float4    SSProfilesPreIntegratedTextureSizeAndInvSize ;
	 float4    SpecularProfileTextureSizeAndInvSize ;
	 float3    PhysicsFieldClipmapCenter ;
	 float    PhysicsFieldClipmapDistance ;
	 int    PhysicsFieldClipmapResolution ;
	 int    PhysicsFieldClipmapExponent ;
	 int    PhysicsFieldClipmapCount ;
	 int    PhysicsFieldTargetCount ;
	 int4    PhysicsFieldTargets[32] ;
	 uint    GPUSceneViewId ;
	 float    ViewResolutionFraction ;
	 float    SubSurfaceColorAsTransmittanceAtDistanceInMeters ;
	 float    Padding4732 ;
	 float4    TanAndInvTanHalfFOV ;
	 float4    PrevTanAndInvTanHalfFOV ;
	 float2    WorldDepthToPixelWorldRadius ;
	 float    Padding4776 ;
	 float    Padding4780 ;
	 float4    ScreenRayLengthMultiplier ;
	 float4    GlintLUTParameters0 ;
	 float4    GlintLUTParameters1 ;
	 int4    EnvironmentComponentsFlags ;
	 uint    BindlessSampler_MaterialTextureBilinearWrapedSampler ;
	 uint    Padding4852 ;
	 uint    BindlessSampler_MaterialTextureBilinearClampedSampler ;
	 uint    Padding4860 ;
	 uint    BindlessSRV_VolumetricLightmapIndirectionTexture ;
	 uint    Padding4868 ;
	 uint    BindlessSRV_VolumetricLightmapBrickAmbientVector ;
	 uint    Padding4876 ;
	 uint    BindlessSRV_VolumetricLightmapBrickSHCoefficients0 ;
	 uint    Padding4884 ;
	 uint    BindlessSRV_VolumetricLightmapBrickSHCoefficients1 ;
	 uint    Padding4892 ;
	 uint    BindlessSRV_VolumetricLightmapBrickSHCoefficients2 ;
	 uint    Padding4900 ;
	 uint    BindlessSRV_VolumetricLightmapBrickSHCoefficients3 ;
	 uint    Padding4908 ;
	 uint    BindlessSRV_VolumetricLightmapBrickSHCoefficients4 ;
	 uint    Padding4916 ;
	 uint    BindlessSRV_VolumetricLightmapBrickSHCoefficients5 ;
	 uint    Padding4924 ;
	 uint    BindlessSRV_SkyBentNormalBrickTexture ;
	 uint    Padding4932 ;
	 uint    BindlessSRV_DirectionalLightShadowingBrickTexture ;
	 uint    Padding4940 ;
	 uint    BindlessSampler_VolumetricLightmapBrickAmbientVectorSampler ;
	 uint    Padding4948 ;
	 uint    BindlessSampler_VolumetricLightmapTextureSampler0 ;
	 uint    Padding4956 ;
	 uint    BindlessSampler_VolumetricLightmapTextureSampler1 ;
	 uint    Padding4964 ;
	 uint    BindlessSampler_VolumetricLightmapTextureSampler2 ;
	 uint    Padding4972 ;
	 uint    BindlessSampler_VolumetricLightmapTextureSampler3 ;
	 uint    Padding4980 ;
	 uint    BindlessSampler_VolumetricLightmapTextureSampler4 ;
	 uint    Padding4988 ;
	 uint    BindlessSampler_VolumetricLightmapTextureSampler5 ;
	 uint    Padding4996 ;
	 uint    BindlessSampler_SkyBentNormalTextureSampler ;
	 uint    Padding5004 ;
	 uint    BindlessSampler_DirectionalLightShadowingTextureSampler ;
	 uint    Padding5012 ;
	 uint    BindlessSRV_GlobalDistanceFieldPageAtlasTexture ;
	 uint    Padding5020 ;
	 uint    BindlessSRV_GlobalDistanceFieldCoverageAtlasTexture ;
	 uint    Padding5028 ;
	 uint    BindlessSRV_GlobalDistanceFieldPageTableTexture ;
	 uint    Padding5036 ;
	 uint    BindlessSRV_GlobalDistanceFieldMipTexture ;
	 uint    Padding5044 ;
	 uint    BindlessSampler_GlobalDistanceFieldPageAtlasTextureSampler ;
	 uint    Padding5052 ;
	 uint    BindlessSampler_GlobalDistanceFieldCoverageAtlasTextureSampler ;
	 uint    Padding5060 ;
	 uint    BindlessSampler_GlobalDistanceFieldMipTextureSampler ;
	 uint    Padding5068 ;
	 uint    BindlessSRV_AtmosphereTransmittanceTexture ;
	 uint    Padding5076 ;
	 uint    BindlessSampler_AtmosphereTransmittanceTextureSampler ;
	 uint    Padding5084 ;
	 uint    BindlessSRV_AtmosphereIrradianceTexture ;
	 uint    Padding5092 ;
	 uint    BindlessSampler_AtmosphereIrradianceTextureSampler ;
	 uint    Padding5100 ;
	 uint    BindlessSRV_AtmosphereInscatterTexture ;
	 uint    Padding5108 ;
	 uint    BindlessSampler_AtmosphereInscatterTextureSampler ;
	 uint    Padding5116 ;
	 uint    BindlessSRV_PerlinNoiseGradientTexture ;
	 uint    Padding5124 ;
	 uint    BindlessSampler_PerlinNoiseGradientTextureSampler ;
	 uint    Padding5132 ;
	 uint    BindlessSRV_PerlinNoise3DTexture ;
	 uint    Padding5140 ;
	 uint    BindlessSampler_PerlinNoise3DTextureSampler ;
	 uint    Padding5148 ;
	 uint    BindlessSRV_SobolSamplingTexture ;
	 uint    Padding5156 ;
	 uint    BindlessSampler_SharedPointWrappedSampler ;
	 uint    Padding5164 ;
	 uint    BindlessSampler_SharedPointClampedSampler ;
	 uint    Padding5172 ;
	 uint    BindlessSampler_SharedBilinearWrappedSampler ;
	 uint    Padding5180 ;
	 uint    BindlessSampler_SharedBilinearClampedSampler ;
	 uint    Padding5188 ;
	 uint    BindlessSampler_SharedBilinearAnisoClampedSampler ;
	 uint    Padding5196 ;
	 uint    BindlessSampler_SharedTrilinearWrappedSampler ;
	 uint    Padding5204 ;
	 uint    BindlessSampler_SharedTrilinearClampedSampler ;
	 uint    Padding5212 ;
	 uint    BindlessSRV_PreIntegratedBRDF ;
	 uint    Padding5220 ;
	 uint    BindlessSampler_PreIntegratedBRDFSampler ;
	 uint    Padding5228 ;
	 uint    BindlessSRV_SkyIrradianceEnvironmentMap ;
	 uint    Padding5236 ;
	 uint    BindlessSRV_TransmittanceLutTexture ;
	 uint    Padding5244 ;
	 uint    BindlessSampler_TransmittanceLutTextureSampler ;
	 uint    Padding5252 ;
	 uint    BindlessSRV_SkyViewLutTexture ;
	 uint    Padding5260 ;
	 uint    BindlessSampler_SkyViewLutTextureSampler ;
	 uint    Padding5268 ;
	 uint    BindlessSRV_DistantSkyLightLutTexture ;
	 uint    Padding5276 ;
	 uint    BindlessSampler_DistantSkyLightLutTextureSampler ;
	 uint    Padding5284 ;
	 uint    BindlessSRV_CameraAerialPerspectiveVolume ;
	 uint    Padding5292 ;
	 uint    BindlessSampler_CameraAerialPerspectiveVolumeSampler ;
	 uint    Padding5300 ;
	 uint    BindlessSRV_CameraAerialPerspectiveVolumeMieOnly ;
	 uint    Padding5308 ;
	 uint    BindlessSampler_CameraAerialPerspectiveVolumeMieOnlySampler ;
	 uint    Padding5316 ;
	 uint    BindlessSRV_CameraAerialPerspectiveVolumeRayOnly ;
	 uint    Padding5324 ;
	 uint    BindlessSampler_CameraAerialPerspectiveVolumeRayOnlySampler ;
	 uint    Padding5332 ;
	 uint    BindlessSRV_HairScatteringLUTTexture ;
	 uint    Padding5340 ;
	 uint    BindlessSampler_HairScatteringLUTSampler ;
	 uint    Padding5348 ;
	 uint    BindlessSRV_GGXLTCMatTexture ;
	 uint    Padding5356 ;
	 uint    BindlessSampler_GGXLTCMatSampler ;
	 uint    Padding5364 ;
	 uint    BindlessSRV_GGXLTCAmpTexture ;
	 uint    Padding5372 ;
	 uint    BindlessSampler_GGXLTCAmpSampler ;
	 uint    Padding5380 ;
	 uint    BindlessSRV_SheenLTCTexture ;
	 uint    Padding5388 ;
	 uint    BindlessSampler_SheenLTCSampler ;
	 uint    Padding5396 ;
	 uint    bShadingEnergyConservation ;
	 uint    bShadingEnergyPreservation ;
	 uint    BindlessSRV_ShadingEnergyGGXSpecTexture ;
	 uint    Padding5412 ;
	 uint    BindlessSRV_ShadingEnergyGGXGlassTexture ;
	 uint    Padding5420 ;
	 uint    BindlessSRV_ShadingEnergyClothSpecTexture ;
	 uint    Padding5428 ;
	 uint    BindlessSRV_ShadingEnergyDiffuseTexture ;
	 uint    Padding5436 ;
	 uint    BindlessSampler_ShadingEnergySampler ;
	 uint    Padding5444 ;
	 uint    BindlessSRV_GlintTexture ;
	 uint    Padding5452 ;
	 uint    BindlessSampler_GlintSampler ;
	 uint    Padding5460 ;
	 uint    BindlessSRV_SimpleVolumeTexture ;
	 uint    Padding5468 ;
	 uint    BindlessSampler_SimpleVolumeTextureSampler ;
	 uint    Padding5476 ;
	 uint    BindlessSRV_SimpleVolumeEnvTexture ;
	 uint    Padding5484 ;
	 uint    BindlessSampler_SimpleVolumeEnvTextureSampler ;
	 uint    Padding5492 ;
	 uint    BindlessSRV_SSProfilesTexture ;
	 uint    Padding5500 ;
	 uint    BindlessSampler_SSProfilesSampler ;
	 uint    Padding5508 ;
	 uint    BindlessSampler_SSProfilesTransmissionSampler ;
	 uint    Padding5516 ;
	 uint    BindlessSRV_SSProfilesPreIntegratedTexture ;
	 uint    Padding5524 ;
	 uint    BindlessSampler_SSProfilesPreIntegratedSampler ;
	 uint    Padding5532 ;
	 uint    BindlessSRV_SpecularProfileTexture ;
	 uint    Padding5540 ;
	 uint    BindlessSampler_SpecularProfileSampler ;
	 uint    Padding5548 ;
	 uint    BindlessSRV_WaterIndirection ;
	 uint    Padding5556 ;
	 uint    BindlessSRV_WaterData ;
	 uint    Padding5564 ;
	 float4    RectLightAtlasSizeAndInvSize ;
	 float    RectLightAtlasMaxMipLevel ;
	 float    Padding5588 ;
	 uint    BindlessSRV_RectLightAtlasTexture ;
	 uint    Padding5596 ;
	 uint    BindlessSampler_RectLightAtlasSampler ;
	 uint    Padding5604 ;
	 uint    Padding5608 ;
	 uint    Padding5612 ;
	 float4    IESAtlasSizeAndInvSize ;
	 uint    BindlessSRV_IESAtlasTexture ;
	 uint    Padding5636 ;
	 uint    BindlessSampler_IESAtlasSampler ;
	 uint    Padding5644 ;
	 uint    BindlessSampler_LandscapeWeightmapSampler ;
	 uint    Padding5652 ;
	 uint    BindlessSRV_LandscapeIndirection ;
	 uint    Padding5660 ;
	 uint    BindlessSRV_LandscapePerComponentData ;
	 uint    Padding5668 ;
	 uint    BindlessUAV_VTFeedbackBuffer ;
	 uint    Padding5676 ;
	 uint    BindlessSRV_PhysicsFieldClipmapBuffer ;
	 uint    Padding5684 ;
	 uint    Padding5688 ;
	 uint    Padding5692 ;
	 float3    TLASPreViewTranslationHigh ;
	 float    Padding5708 ;
	 float3    TLASPreViewTranslationLow ;
 };
ConstantBuffer<FViewConstants> View;
SamplerState  View_MaterialTextureBilinearWrapedSampler;
struct FPrimitiveConstants {
	 uint    Flags ;
	 uint    InstanceSceneDataOffset ;
	 uint    NumInstanceSceneDataEntries ;
	 int    SingleCaptureIndex ;
	 float3    PositionHigh ;
	 uint    PrimitiveComponentId ;
	 float4x4    LocalToRelativeWorld ;
	 float4x4    RelativeWorldToLocal ;
	 float4x4    PreviousLocalToRelativeWorld ;
	 float4x4    PreviousRelativeWorldToLocal ;
	 float4x4    WorldToPreviousWorld ;
	 float3    InvNonUniformScale ;
	 float    ObjectBoundsX ;
	 float4    ObjectWorldPositionHighAndRadius ;
	 float3    ObjectWorldPositionLow ;
	 float    MinMaterialDisplacement ;
	 float3    ActorWorldPositionHigh ;
	 float    MaxMaterialDisplacement ;
	 float3    ActorWorldPositionLow ;
	 uint    LightmapUVIndex ;
	 float3    ObjectOrientation ;
	 uint    LightmapDataIndex ;
	 float4    NonUniformScale ;
	 float3    PreSkinnedLocalBoundsMin ;
	 uint    NaniteResourceID ;
	 float3    PreSkinnedLocalBoundsMax ;
	 uint    NaniteHierarchyOffset ;
	 float3    LocalObjectBoundsMin ;
	 float    ObjectBoundsY ;
	 float3    LocalObjectBoundsMax ;
	 float    ObjectBoundsZ ;
	 float3    InstanceLocalBoundsCenter ;
	 uint    InstancePayloadDataOffset ;
	 float3    InstanceLocalBoundsExtent ;
	 uint    InstancePayloadDataStride ;
	 uint    InstancePayloadExtensionSize ;
	 uint    Padding564 ;
	 float2    WireframeAndPrimitiveColor ;
	 uint    PackedNaniteFlags ;
	 int    PersistentPrimitiveIndex ;
	 float2    InstanceDrawDistanceMinMaxSquared ;
	 float    InstanceWPODisableDistanceSquared ;
	 uint    NaniteRayTracingDataOffset ;
	 float    MaxWPOExtent ;
	 uint    CustomStencilValueAndMask ;
	 uint    VisibilityFlags ;
	 uint    Padding612 ;
	 uint    Padding616 ;
	 uint    Padding620 ;
	 float4    CustomPrimitiveData[9] ;
 };
ConstantBuffer<FPrimitiveConstants> Primitive;
struct FSceneConstants {
	 uint    BindlessSRV_GPUScene_GPUSceneInstanceSceneData ;
	 uint    Padding4 ;
	 uint    BindlessSRV_GPUScene_GPUSceneInstancePayloadData ;
	 uint    Padding12 ;
	 uint    BindlessSRV_GPUScene_GPUScenePrimitiveSceneData ;
	 uint    Padding20 ;
	 uint    BindlessSRV_GPUScene_GPUSceneLightmapData ;
	 uint    Padding28 ;
	 uint    BindlessSRV_GPUScene_GPUSceneLightData ;
	 uint    Padding36 ;
	 uint    GPUScene_InstanceDataSOAStride ;
	 uint    GPUScene_GPUSceneFrameNumber ;
	 int    GPUScene_NumInstances ;
	 int    GPUScene_NumScenePrimitives ;
	 float    Padding56 ;
	 float    Padding60 ;
	 uint    NaniteMaterials_PrimitiveMaterialElementStride ;
	 uint    Padding68 ;
	 uint    BindlessSRV_NaniteMaterials_PrimitiveMaterialData ;
	 uint    Padding76 ;
	 uint    BindlessSRV_NaniteMaterials_MaterialData ;
	 float    Padding84 ;
	 float    Padding88 ;
	 float    Padding92 ;
	 float2    SplineMesh_SplineTextureInvExtent ;
	 uint    BindlessSRV_SplineMesh_SplinePosTexture ;
	 uint    Padding108 ;
	 uint    BindlessSRV_SplineMesh_SplineRotTexture ;
	 uint    Padding116 ;
	 uint    BindlessSampler_SplineMesh_SplineSampler ;
 };
ConstantBuffer<FSceneConstants> Scene;
StructuredBuffer<float4>  Scene_GPUScene_GPUSceneInstanceSceneData;
StructuredBuffer<float4>  Scene_GPUScene_GPUSceneInstancePayloadData;
StructuredBuffer<float4>  Scene_GPUScene_GPUScenePrimitiveSceneData;
ByteAddressBuffer  Scene_NaniteMaterials_PrimitiveMaterialData;
ByteAddressBuffer  Scene_NaniteMaterials_MaterialData;
struct FVirtualShadowMapConstants {
	 uint    NumFullShadowMaps ;
	 uint    NumSinglePageShadowMaps ;
	 uint    MaxPhysicalPages ;
	 uint    NumShadowMapSlots ;
	 uint    StaticCachedArrayIndex ;
	 uint    PhysicalPageRowMask ;
	 uint    PhysicalPageRowShift ;
	 uint    PackedShadowMaskMaxLightCount ;
	 float4    RecPhysicalPoolSize ;
	 int2    PhysicalPoolSize ;
	 int2    PhysicalPoolSizePages ;
	 uint    bExcludeNonNaniteFromCoarsePages ;
	 float    CoarsePagePixelThresholdDynamic ;
	 float    CoarsePagePixelThresholdStatic ;
	 float    CoarsePagePixelThresholdDynamicNanite ;
	 uint    SceneFrameNumber ;
	 uint    bClipmapGreedyLevelSelection ;
	 float    GlobalResolutionLodBias ;
	 float    Padding92 ;
	 uint    BindlessSRV_ProjectionData ;
	 uint    Padding100 ;
	 uint    BindlessSRV_PageTable ;
	 uint    Padding108 ;
	 uint    BindlessSRV_PageFlags ;
	 uint    Padding116 ;
	 uint    BindlessSRV_PageRectBounds ;
	 uint    Padding124 ;
	 uint    BindlessSRV_PhysicalPagePool ;
	 uint    Padding132 ;
	 uint    BindlessSRV_CachePrimitiveAsDynamic ;
	 uint    Padding140 ;
	 uint    BindlessSRV_LightGridData ;
	 uint    Padding148 ;
	 uint    BindlessSRV_NumCulledLightsGrid ;
 };
ConstantBuffer<FVirtualShadowMapConstants> VirtualShadowMap;
StructuredBuffer<uint>  VirtualShadowMap_PageTable;
struct FMaterialConstants {
	 float4    PreshaderBuffer[11] ;
	 uint    BindlessSRV_Texture2D_0 ;
	 uint    Padding180 ;
	 uint    BindlessSampler_Texture2D_0Sampler ;
	 uint    Padding188 ;
	 uint    BindlessSRV_Texture2D_1 ;
	 uint    Padding196 ;
	 uint    BindlessSampler_Texture2D_1Sampler ;
	 uint    Padding204 ;
	 uint    BindlessSRV_Texture2D_2 ;
	 uint    Padding212 ;
	 uint    BindlessSampler_Texture2D_2Sampler ;
	 uint    Padding220 ;
	 uint    BindlessSRV_Texture2D_3 ;
	 uint    Padding228 ;
	 uint    BindlessSampler_Texture2D_3Sampler ;
	 uint    Padding236 ;
	 uint    BindlessSRV_Texture2D_4 ;
	 uint    Padding244 ;
	 uint    BindlessSampler_Texture2D_4Sampler ;
	 uint    Padding252 ;
	 uint    BindlessSRV_Texture2D_5 ;
	 uint    Padding260 ;
	 uint    BindlessSampler_Texture2D_5Sampler ;
	 uint    Padding268 ;
	 uint    BindlessSRV_Texture2D_6 ;
	 uint    Padding276 ;
	 uint    BindlessSampler_Texture2D_6Sampler ;
	 uint    Padding284 ;
	 uint    BindlessSRV_Texture2D_7 ;
	 uint    Padding292 ;
	 uint    BindlessSampler_Texture2D_7Sampler ;
	 uint    Padding300 ;
	 uint    BindlessSRV_Texture2D_8 ;
	 uint    Padding308 ;
	 uint    BindlessSampler_Texture2D_8Sampler ;
	 uint    Padding316 ;
	 uint    BindlessSRV_Texture2D_9 ;
	 uint    Padding324 ;
	 uint    BindlessSampler_Texture2D_9Sampler ;
	 uint    Padding332 ;
	 uint    BindlessSRV_Texture2D_10 ;
	 uint    Padding340 ;
	 uint    BindlessSampler_Texture2D_10Sampler ;
	 uint    Padding348 ;
	 uint    BindlessSRV_Texture2D_11 ;
	 uint    Padding356 ;
	 uint    BindlessSampler_Texture2D_11Sampler ;
	 uint    Padding364 ;
	 uint    BindlessSRV_Texture2D_12 ;
	 uint    Padding372 ;
	 uint    BindlessSampler_Texture2D_12Sampler ;
	 uint    Padding380 ;
	 uint    BindlessSampler_Wrap_WorldGroupSettings ;
	 uint    Padding388 ;
	 uint    BindlessSampler_Clamp_WorldGroupSettings ;
 };
ConstantBuffer<FMaterialConstants> Material;
Texture2D  Material_Texture2D_0;
SamplerState  Material_Texture2D_0Sampler;
Texture2D  Material_Texture2D_1;
SamplerState  Material_Texture2D_1Sampler;
Texture2D  Material_Texture2D_2;
SamplerState  Material_Texture2D_2Sampler;
Texture2D  Material_Texture2D_3;
SamplerState  Material_Texture2D_3Sampler;
Texture2D  Material_Texture2D_4;
SamplerState  Material_Texture2D_4Sampler;
Texture2D  Material_Texture2D_5;
SamplerState  Material_Texture2D_5Sampler;
Texture2D  Material_Texture2D_6;
SamplerState  Material_Texture2D_6Sampler;
Texture2D  Material_Texture2D_7;
SamplerState  Material_Texture2D_7Sampler;
Texture2D  Material_Texture2D_8;
SamplerState  Material_Texture2D_8Sampler;
Texture2D  Material_Texture2D_9;
SamplerState  Material_Texture2D_9Sampler;
Texture2D  Material_Texture2D_10;
SamplerState  Material_Texture2D_10Sampler;
Texture2D  Material_Texture2D_11;
SamplerState  Material_Texture2D_11Sampler;
Texture2D  Material_Texture2D_12;
SamplerState  Material_Texture2D_12Sampler;
struct ViewStateTileOffsetData
{
	FLWCVector3 WorldCameraOrigin;
	FLWCVector3 WorldViewOrigin;
	FLWCVector3 PrevWorldCameraOrigin;
	FLWCVector3 PrevWorldViewOrigin;
	FLWCVector3 PreViewTranslation;
	FLWCVector3 PrevPreViewTranslation;
};
struct ViewState
{
	float4x4 TranslatedWorldToClip;
	float4x4 RelativeWorldToClip;
	float4x4 ClipToRelativeWorld;
	float4x4 TranslatedWorldToView;
	float4x4 ViewToTranslatedWorld;
	float4x4 TranslatedWorldToCameraView;
	float4x4 CameraViewToTranslatedWorld;
	float4x4 ViewToClip;
	float4x4 ViewToClipNoAA;
	float4x4 ClipToView;
	float4x4 ClipToTranslatedWorld;
	float4x4 SVPositionToTranslatedWorld;
	float4x4 ScreenToRelativeWorld;
	float4x4 ScreenToTranslatedWorld;
	float4x4 MobileMultiviewShadowTransform;
	float3 ViewOriginHigh;
	float3 ViewForward;
	float3 ViewUp;
	float3 ViewRight;
	float3 HMDViewNoRollUp;
	float3 HMDViewNoRollRight;
	float4 InvDeviceZToWorldZTransform;
	float4 ScreenPositionScaleBias;
	float3 ViewOriginLow;
	float3 TranslatedWorldCameraOrigin;
	float3 WorldViewOriginHigh;
	float3 WorldViewOriginLow;
	float3 PreViewTranslationHigh;
	float3 PreViewTranslationLow;
	float4x4 PrevViewToClip;
	float4x4 PrevClipToView;
	float4x4 PrevTranslatedWorldToClip;
	float4x4 PrevTranslatedWorldToView;
	float4x4 PrevViewToTranslatedWorld;
	float4x4 PrevTranslatedWorldToCameraView;
	float4x4 PrevCameraViewToTranslatedWorld;
	float3 PrevTranslatedWorldCameraOrigin;
	float3 PrevWorldCameraOriginHigh;
	float3 PrevWorldCameraOriginLow;
	float3 PrevWorldViewOriginHigh;
	float3 PrevWorldViewOriginLow;
	float3 PrevPreViewTranslationHigh;
	float3 PrevPreViewTranslationLow;
	float3 ViewTilePosition;
	float3 RelativeWorldCameraOriginTO;
	float3 RelativeWorldViewOriginTO;
	float3 RelativePreViewTranslationTO;
	float3 PrevRelativeWorldCameraOriginTO;
	float3 PrevRelativeWorldViewOriginTO;
	float3 RelativePrevPreViewTranslationTO;
	float4x4 PrevClipToRelativeWorld;
	float4x4 PrevScreenToTranslatedWorld;
	float4x4 ClipToPrevClip;
	float4x4 ClipToPrevClipWithAA;
	float4 TemporalAAJitter;
	float4 GlobalClippingPlane;
	float2 FieldOfViewWideAngles;
	float2 PrevFieldOfViewWideAngles;
	float4 ViewRectMin;
	float4 ViewSizeAndInvSize;
	uint4 ViewRectMinAndSize;
	float4 LightProbeSizeRatioAndInvSizeRatio;
	float4 BufferSizeAndInvSize;
	float4 BufferBilinearUVMinMax;
	float4 ScreenToViewSpace;
	float2 BufferToSceneTextureScale;
	float2 ResolutionFractionAndInv;
	int NumSceneColorMSAASamples;
	float ProjectionDepthThicknessScale;
	float PreExposure;
	float OneOverPreExposure;
	float4 DiffuseOverrideParameter;
	float4 SpecularOverrideParameter;
	float4 NormalOverrideParameter;
	float2 RoughnessOverrideParameter;
	float PrevFrameGameTime;
	float PrevFrameRealTime;
	float OutOfBoundsMask;
	float3 WorldCameraMovementSinceLastFrame;
	float CullingSign;
	float NearPlane;
	float GameTime;
	float RealTime;
	float DeltaTime;
	float MaterialTextureMipBias;
	float MaterialTextureDerivativeMultiply;
	uint Random;
	uint FrameNumber;
	uint FrameCounter;
	uint StateFrameIndexMod8;
	uint StateFrameIndex;
	uint DebugViewModeMask;
	uint WorldIsPaused;
	float CameraCut;
	float UnlitViewmodeMask;
	float4 DirectionalLightColor;
	float3 DirectionalLightDirection;
	float4 TranslucencyLightingVolumeMin[2];
	float4 TranslucencyLightingVolumeInvSize[2];
	float4 TemporalAAParams;
	float4 CircleDOFParams;
	float DepthOfFieldSensorWidth;
	float DepthOfFieldFocalDistance;
	float DepthOfFieldScale;
	float DepthOfFieldFocalLength;
	float DepthOfFieldFocalRegion;
	float DepthOfFieldNearTransitionRegion;
	float DepthOfFieldFarTransitionRegion;
	float MotionBlurNormalizedToPixel;
	float GeneralPurposeTweak;
	float GeneralPurposeTweak2;
	float DemosaicVposOffset;
	float DecalDepthBias;
	float3 IndirectLightingColorScale;
	float3 PrecomputedIndirectLightingColorScale;
	float3 PrecomputedIndirectSpecularColorScale;
	float4 AtmosphereLightDirection[2];
	float4 AtmosphereLightIlluminanceOnGroundPostTransmittance[2];
	float4 AtmosphereLightIlluminanceOuterSpace[2];
	float4 AtmosphereLightDiscLuminance[2];
	float4 AtmosphereLightDiscCosHalfApexAngle_PPTrans[2];
	float4 SkyViewLutSizeAndInvSize;
	float3 SkyCameraTranslatedWorldOrigin;
	float4 SkyPlanetTranslatedWorldCenterAndViewHeight;
	float4x4 SkyViewLutReferential;
	float4 SkyAtmosphereSkyLuminanceFactor;
	float SkyAtmospherePresentInScene;
	float SkyAtmosphereHeightFogContribution;
	float SkyAtmosphereBottomRadiusKm;
	float SkyAtmosphereTopRadiusKm;
	float4 SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize;
	float SkyAtmosphereAerialPerspectiveStartDepthKm;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	float SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	float3 NormalCurvatureToRoughnessScaleBias;
	float RenderingReflectionCaptureMask;
	float RealTimeReflectionCapture;
	float RealTimeReflectionCapturePreExposure;
	float4 AmbientCubemapTint;
	float AmbientCubemapIntensity;
	float SkyLightApplyPrecomputedBentNormalShadowingFlag;
	float SkyLightAffectReflectionFlag;
	float SkyLightAffectGlobalIlluminationFlag;
	float4 SkyLightColor;
	float SkyLightVolumetricScatteringIntensity;
	float4 MobileSkyIrradianceEnvironmentMap[8];
	float MobilePreviewMode;
	float HMDEyePaddingOffset;
	float ReflectionCubemapMaxMip;
	float ShowDecalsMask;
	uint DistanceFieldAOSpecularOcclusionMode;
	float IndirectCapsuleSelfShadowingIntensity;
	float3 ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	int StereoPassIndex;
	float4 GlobalVolumeTranslatedCenterAndExtent[6];
	float4 GlobalVolumeTranslatedWorldToUVAddAndMul[6];
	float4 GlobalDistanceFieldMipTranslatedWorldToUVScale[6];
	float4 GlobalDistanceFieldMipTranslatedWorldToUVBias[6];
	float GlobalDistanceFieldMipFactor;
	float GlobalDistanceFieldMipTransition;
	int GlobalDistanceFieldClipmapSizeInPages;
	float3 GlobalDistanceFieldInvPageAtlasSize;
	float3 GlobalDistanceFieldInvCoverageAtlasSize;
	float GlobalVolumeDimension;
	float GlobalVolumeTexelSize;
	float MaxGlobalDFAOConeDistance;
	uint NumGlobalSDFClipmaps;
	float CoveredExpandSurfaceScale;
	float NotCoveredExpandSurfaceScale;
	float NotCoveredMinStepScale;
	float DitheredTransparencyStepThreshold;
	float DitheredTransparencyTraceThreshold;
	int2 CursorPosition;
	float bCheckerboardSubsurfaceProfileRendering;
	float3 VolumetricFogInvGridSize;
	float3 VolumetricFogGridZParams;
	float2 VolumetricFogSVPosToVolumeUV;
	float2 VolumetricFogViewGridUVToPrevViewRectUV;
	float2 VolumetricFogPrevViewGridRectUVToResourceUV;
	float2 VolumetricFogPrevUVMax;
	float2 VolumetricFogPrevUVMaxForTemporalBlend;
	float2 VolumetricFogScreenToResourceUV;
	float2 VolumetricFogUVMax;
	float VolumetricFogMaxDistance;
	float3 VolumetricLightmapWorldToUVScale;
	float3 VolumetricLightmapWorldToUVAdd;
	float3 VolumetricLightmapIndirectionTextureSize;
	float VolumetricLightmapBrickSize;
	float3 VolumetricLightmapBrickTexelSize;
	float IndirectLightingCacheShowFlag;
	float EyeToPixelSpreadAngle;
	float4 XRPassthroughCameraUVs[2];
	float GlobalVirtualTextureMipBias;
	uint VirtualTextureFeedbackShift;
	uint VirtualTextureFeedbackMask;
	uint VirtualTextureFeedbackStride;
	uint VirtualTextureFeedbackJitterOffset;
	uint VirtualTextureFeedbackSampleOffset;
	float4 RuntimeVirtualTextureMipLevel;
	float2 RuntimeVirtualTexturePackHeight;
	float4 RuntimeVirtualTextureDebugParams;
	int FarShadowStaticMeshLODBias;
	float MinRoughness;
	float4 HairRenderInfo;
	uint EnableSkyLight;
	uint HairRenderInfoBits;
	uint HairComponents;
	float bSubsurfacePostprocessEnabled;
	float4 SSProfilesTextureSizeAndInvSize;
	float4 SSProfilesPreIntegratedTextureSizeAndInvSize;
	float4 SpecularProfileTextureSizeAndInvSize;
	float3 PhysicsFieldClipmapCenter;
	float PhysicsFieldClipmapDistance;
	int PhysicsFieldClipmapResolution;
	int PhysicsFieldClipmapExponent;
	int PhysicsFieldClipmapCount;
	int PhysicsFieldTargetCount;
	int4 PhysicsFieldTargets[32];
	uint GPUSceneViewId;
	float ViewResolutionFraction;
	float SubSurfaceColorAsTransmittanceAtDistanceInMeters;
	float4 TanAndInvTanHalfFOV;
	float4 PrevTanAndInvTanHalfFOV;
	float2 WorldDepthToPixelWorldRadius;
	float4 ScreenRayLengthMultiplier;
	float4 GlintLUTParameters0;
	float4 GlintLUTParameters1;
	int4 EnvironmentComponentsFlags;
	FDFInverseMatrix WorldToClip;
	FDFMatrix ClipToWorld;
	FDFMatrix ScreenToWorld;
	FDFMatrix PrevClipToWorld;
	FDFVector3 WorldCameraOrigin;
	FDFVector3 WorldViewOrigin;
	FDFVector3 PrevWorldCameraOrigin;
	FDFVector3 PrevWorldViewOrigin;
	FDFVector3 PreViewTranslation;
	FDFVector3 PrevPreViewTranslation;
	ViewStateTileOffsetData TileOffset;
};
void FinalizeViewState(inout ViewState InOutView);
ViewState GetPrimaryView()
{
	ViewState Result;
	Result.TranslatedWorldToClip = View.TranslatedWorldToClip;
	Result.RelativeWorldToClip = View.RelativeWorldToClip;
	Result.ClipToRelativeWorld = View.ClipToRelativeWorld;
	Result.TranslatedWorldToView = View.TranslatedWorldToView;
	Result.ViewToTranslatedWorld = View.ViewToTranslatedWorld;
	Result.TranslatedWorldToCameraView = View.TranslatedWorldToCameraView;
	Result.CameraViewToTranslatedWorld = View.CameraViewToTranslatedWorld;
	Result.ViewToClip = View.ViewToClip;
	Result.ViewToClipNoAA = View.ViewToClipNoAA;
	Result.ClipToView = View.ClipToView;
	Result.ClipToTranslatedWorld = View.ClipToTranslatedWorld;
	Result.SVPositionToTranslatedWorld = View.SVPositionToTranslatedWorld;
	Result.ScreenToRelativeWorld = View.ScreenToRelativeWorld;
	Result.ScreenToTranslatedWorld = View.ScreenToTranslatedWorld;
	Result.MobileMultiviewShadowTransform = View.MobileMultiviewShadowTransform;
	Result.ViewOriginHigh = View.ViewOriginHigh;
	Result.ViewForward = View.ViewForward;
	Result.ViewUp = View.ViewUp;
	Result.ViewRight = View.ViewRight;
	Result.HMDViewNoRollUp = View.HMDViewNoRollUp;
	Result.HMDViewNoRollRight = View.HMDViewNoRollRight;
	Result.InvDeviceZToWorldZTransform = View.InvDeviceZToWorldZTransform;
	Result.ScreenPositionScaleBias = View.ScreenPositionScaleBias;
	Result.ViewOriginLow = View.ViewOriginLow;
	Result.TranslatedWorldCameraOrigin = View.TranslatedWorldCameraOrigin;
	Result.WorldViewOriginHigh = View.WorldViewOriginHigh;
	Result.WorldViewOriginLow = View.WorldViewOriginLow;
	Result.PreViewTranslationHigh = View.PreViewTranslationHigh;
	Result.PreViewTranslationLow = View.PreViewTranslationLow;
	Result.PrevViewToClip = View.PrevViewToClip;
	Result.PrevClipToView = View.PrevClipToView;
	Result.PrevTranslatedWorldToClip = View.PrevTranslatedWorldToClip;
	Result.PrevTranslatedWorldToView = View.PrevTranslatedWorldToView;
	Result.PrevViewToTranslatedWorld = View.PrevViewToTranslatedWorld;
	Result.PrevTranslatedWorldToCameraView = View.PrevTranslatedWorldToCameraView;
	Result.PrevCameraViewToTranslatedWorld = View.PrevCameraViewToTranslatedWorld;
	Result.PrevTranslatedWorldCameraOrigin = View.PrevTranslatedWorldCameraOrigin;
	Result.PrevWorldCameraOriginHigh = View.PrevWorldCameraOriginHigh;
	Result.PrevWorldCameraOriginLow = View.PrevWorldCameraOriginLow;
	Result.PrevWorldViewOriginHigh = View.PrevWorldViewOriginHigh;
	Result.PrevWorldViewOriginLow = View.PrevWorldViewOriginLow;
	Result.PrevPreViewTranslationHigh = View.PrevPreViewTranslationHigh;
	Result.PrevPreViewTranslationLow = View.PrevPreViewTranslationLow;
	Result.ViewTilePosition = View.ViewTilePosition;
	Result.RelativeWorldCameraOriginTO = View.RelativeWorldCameraOriginTO;
	Result.RelativeWorldViewOriginTO = View.RelativeWorldViewOriginTO;
	Result.RelativePreViewTranslationTO = View.RelativePreViewTranslationTO;
	Result.PrevRelativeWorldCameraOriginTO = View.PrevRelativeWorldCameraOriginTO;
	Result.PrevRelativeWorldViewOriginTO = View.PrevRelativeWorldViewOriginTO;
	Result.RelativePrevPreViewTranslationTO = View.RelativePrevPreViewTranslationTO;
	Result.PrevClipToRelativeWorld = View.PrevClipToRelativeWorld;
	Result.PrevScreenToTranslatedWorld = View.PrevScreenToTranslatedWorld;
	Result.ClipToPrevClip = View.ClipToPrevClip;
	Result.ClipToPrevClipWithAA = View.ClipToPrevClipWithAA;
	Result.TemporalAAJitter = View.TemporalAAJitter;
	Result.GlobalClippingPlane = View.GlobalClippingPlane;
	Result.FieldOfViewWideAngles = View.FieldOfViewWideAngles;
	Result.PrevFieldOfViewWideAngles = View.PrevFieldOfViewWideAngles;
	Result.ViewRectMin = View.ViewRectMin;
	Result.ViewSizeAndInvSize = View.ViewSizeAndInvSize;
	Result.ViewRectMinAndSize = View.ViewRectMinAndSize;
	Result.LightProbeSizeRatioAndInvSizeRatio = View.LightProbeSizeRatioAndInvSizeRatio;
	Result.BufferSizeAndInvSize = View.BufferSizeAndInvSize;
	Result.BufferBilinearUVMinMax = View.BufferBilinearUVMinMax;
	Result.ScreenToViewSpace = View.ScreenToViewSpace;
	Result.BufferToSceneTextureScale = View.BufferToSceneTextureScale;
	Result.ResolutionFractionAndInv = View.ResolutionFractionAndInv;
	Result.NumSceneColorMSAASamples = View.NumSceneColorMSAASamples;
	Result.ProjectionDepthThicknessScale = View.ProjectionDepthThicknessScale;
	Result.PreExposure = View.PreExposure;
	Result.OneOverPreExposure = View.OneOverPreExposure;
	Result.DiffuseOverrideParameter = View.DiffuseOverrideParameter;
	Result.SpecularOverrideParameter = View.SpecularOverrideParameter;
	Result.NormalOverrideParameter = View.NormalOverrideParameter;
	Result.RoughnessOverrideParameter = View.RoughnessOverrideParameter;
	Result.PrevFrameGameTime = View.PrevFrameGameTime;
	Result.PrevFrameRealTime = View.PrevFrameRealTime;
	Result.OutOfBoundsMask = View.OutOfBoundsMask;
	Result.WorldCameraMovementSinceLastFrame = View.WorldCameraMovementSinceLastFrame;
	Result.CullingSign = View.CullingSign;
	Result.NearPlane = View.NearPlane;
	Result.GameTime = View.GameTime;
	Result.RealTime = View.RealTime;
	Result.DeltaTime = View.DeltaTime;
	Result.MaterialTextureMipBias = View.MaterialTextureMipBias;
	Result.MaterialTextureDerivativeMultiply = View.MaterialTextureDerivativeMultiply;
	Result.Random = View.Random;
	Result.FrameNumber = View.FrameNumber;
	Result.FrameCounter = View.FrameCounter;
	Result.StateFrameIndexMod8 = View.StateFrameIndexMod8;
	Result.StateFrameIndex = View.StateFrameIndex;
	Result.DebugViewModeMask = View.DebugViewModeMask;
	Result.WorldIsPaused = View.WorldIsPaused;
	Result.CameraCut = View.CameraCut;
	Result.UnlitViewmodeMask = View.UnlitViewmodeMask;
	Result.DirectionalLightColor = View.DirectionalLightColor;
	Result.DirectionalLightDirection = View.DirectionalLightDirection;
	Result.TranslucencyLightingVolumeMin = View.TranslucencyLightingVolumeMin;
	Result.TranslucencyLightingVolumeInvSize = View.TranslucencyLightingVolumeInvSize;
	Result.TemporalAAParams = View.TemporalAAParams;
	Result.CircleDOFParams = View.CircleDOFParams;
	Result.DepthOfFieldSensorWidth = View.DepthOfFieldSensorWidth;
	Result.DepthOfFieldFocalDistance = View.DepthOfFieldFocalDistance;
	Result.DepthOfFieldScale = View.DepthOfFieldScale;
	Result.DepthOfFieldFocalLength = View.DepthOfFieldFocalLength;
	Result.DepthOfFieldFocalRegion = View.DepthOfFieldFocalRegion;
	Result.DepthOfFieldNearTransitionRegion = View.DepthOfFieldNearTransitionRegion;
	Result.DepthOfFieldFarTransitionRegion = View.DepthOfFieldFarTransitionRegion;
	Result.MotionBlurNormalizedToPixel = View.MotionBlurNormalizedToPixel;
	Result.GeneralPurposeTweak = View.GeneralPurposeTweak;
	Result.GeneralPurposeTweak2 = View.GeneralPurposeTweak2;
	Result.DemosaicVposOffset = View.DemosaicVposOffset;
	Result.DecalDepthBias = View.DecalDepthBias;
	Result.IndirectLightingColorScale = View.IndirectLightingColorScale;
	Result.PrecomputedIndirectLightingColorScale = View.PrecomputedIndirectLightingColorScale;
	Result.PrecomputedIndirectSpecularColorScale = View.PrecomputedIndirectSpecularColorScale;
	Result.AtmosphereLightDirection = View.AtmosphereLightDirection;
	Result.AtmosphereLightIlluminanceOnGroundPostTransmittance = View.AtmosphereLightIlluminanceOnGroundPostTransmittance;
	Result.AtmosphereLightIlluminanceOuterSpace = View.AtmosphereLightIlluminanceOuterSpace;
	Result.AtmosphereLightDiscLuminance = View.AtmosphereLightDiscLuminance;
	Result.AtmosphereLightDiscCosHalfApexAngle_PPTrans = View.AtmosphereLightDiscCosHalfApexAngle_PPTrans;
	Result.SkyViewLutSizeAndInvSize = View.SkyViewLutSizeAndInvSize;
	Result.SkyCameraTranslatedWorldOrigin = View.SkyCameraTranslatedWorldOrigin;
	Result.SkyPlanetTranslatedWorldCenterAndViewHeight = View.SkyPlanetTranslatedWorldCenterAndViewHeight;
	Result.SkyViewLutReferential = View.SkyViewLutReferential;
	Result.SkyAtmosphereSkyLuminanceFactor = View.SkyAtmosphereSkyLuminanceFactor;
	Result.SkyAtmospherePresentInScene = View.SkyAtmospherePresentInScene;
	Result.SkyAtmosphereHeightFogContribution = View.SkyAtmosphereHeightFogContribution;
	Result.SkyAtmosphereBottomRadiusKm = View.SkyAtmosphereBottomRadiusKm;
	Result.SkyAtmosphereTopRadiusKm = View.SkyAtmosphereTopRadiusKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize = View.SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize;
	Result.SkyAtmosphereAerialPerspectiveStartDepthKm = View.SkyAtmosphereAerialPerspectiveStartDepthKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution = View.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv = View.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm = View.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv = View.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	Result.SkyAtmosphereApplyCameraAerialPerspectiveVolume = View.SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	Result.NormalCurvatureToRoughnessScaleBias = View.NormalCurvatureToRoughnessScaleBias;
	Result.RenderingReflectionCaptureMask = View.RenderingReflectionCaptureMask;
	Result.RealTimeReflectionCapture = View.RealTimeReflectionCapture;
	Result.RealTimeReflectionCapturePreExposure = View.RealTimeReflectionCapturePreExposure;
	Result.AmbientCubemapTint = View.AmbientCubemapTint;
	Result.AmbientCubemapIntensity = View.AmbientCubemapIntensity;
	Result.SkyLightApplyPrecomputedBentNormalShadowingFlag = View.SkyLightApplyPrecomputedBentNormalShadowingFlag;
	Result.SkyLightAffectReflectionFlag = View.SkyLightAffectReflectionFlag;
	Result.SkyLightAffectGlobalIlluminationFlag = View.SkyLightAffectGlobalIlluminationFlag;
	Result.SkyLightColor = View.SkyLightColor;
	Result.SkyLightVolumetricScatteringIntensity = View.SkyLightVolumetricScatteringIntensity;
	Result.MobileSkyIrradianceEnvironmentMap = View.MobileSkyIrradianceEnvironmentMap;
	Result.MobilePreviewMode = View.MobilePreviewMode;
	Result.HMDEyePaddingOffset = View.HMDEyePaddingOffset;
	Result.ReflectionCubemapMaxMip = View.ReflectionCubemapMaxMip;
	Result.ShowDecalsMask = View.ShowDecalsMask;
	Result.DistanceFieldAOSpecularOcclusionMode = View.DistanceFieldAOSpecularOcclusionMode;
	Result.IndirectCapsuleSelfShadowingIntensity = View.IndirectCapsuleSelfShadowingIntensity;
	Result.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight = View.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	Result.StereoPassIndex = View.StereoPassIndex;
	Result.GlobalVolumeTranslatedCenterAndExtent = View.GlobalVolumeTranslatedCenterAndExtent;
	Result.GlobalVolumeTranslatedWorldToUVAddAndMul = View.GlobalVolumeTranslatedWorldToUVAddAndMul;
	Result.GlobalDistanceFieldMipTranslatedWorldToUVScale = View.GlobalDistanceFieldMipTranslatedWorldToUVScale;
	Result.GlobalDistanceFieldMipTranslatedWorldToUVBias = View.GlobalDistanceFieldMipTranslatedWorldToUVBias;
	Result.GlobalDistanceFieldMipFactor = View.GlobalDistanceFieldMipFactor;
	Result.GlobalDistanceFieldMipTransition = View.GlobalDistanceFieldMipTransition;
	Result.GlobalDistanceFieldClipmapSizeInPages = View.GlobalDistanceFieldClipmapSizeInPages;
	Result.GlobalDistanceFieldInvPageAtlasSize = View.GlobalDistanceFieldInvPageAtlasSize;
	Result.GlobalDistanceFieldInvCoverageAtlasSize = View.GlobalDistanceFieldInvCoverageAtlasSize;
	Result.GlobalVolumeDimension = View.GlobalVolumeDimension;
	Result.GlobalVolumeTexelSize = View.GlobalVolumeTexelSize;
	Result.MaxGlobalDFAOConeDistance = View.MaxGlobalDFAOConeDistance;
	Result.NumGlobalSDFClipmaps = View.NumGlobalSDFClipmaps;
	Result.CoveredExpandSurfaceScale = View.CoveredExpandSurfaceScale;
	Result.NotCoveredExpandSurfaceScale = View.NotCoveredExpandSurfaceScale;
	Result.NotCoveredMinStepScale = View.NotCoveredMinStepScale;
	Result.DitheredTransparencyStepThreshold = View.DitheredTransparencyStepThreshold;
	Result.DitheredTransparencyTraceThreshold = View.DitheredTransparencyTraceThreshold;
	Result.CursorPosition = View.CursorPosition;
	Result.bCheckerboardSubsurfaceProfileRendering = View.bCheckerboardSubsurfaceProfileRendering;
	Result.VolumetricFogInvGridSize = View.VolumetricFogInvGridSize;
	Result.VolumetricFogGridZParams = View.VolumetricFogGridZParams;
	Result.VolumetricFogSVPosToVolumeUV = View.VolumetricFogSVPosToVolumeUV;
	Result.VolumetricFogViewGridUVToPrevViewRectUV = View.VolumetricFogViewGridUVToPrevViewRectUV;
	Result.VolumetricFogPrevViewGridRectUVToResourceUV = View.VolumetricFogPrevViewGridRectUVToResourceUV;
	Result.VolumetricFogPrevUVMax = View.VolumetricFogPrevUVMax;
	Result.VolumetricFogPrevUVMaxForTemporalBlend = View.VolumetricFogPrevUVMaxForTemporalBlend;
	Result.VolumetricFogScreenToResourceUV = View.VolumetricFogScreenToResourceUV;
	Result.VolumetricFogUVMax = View.VolumetricFogUVMax;
	Result.VolumetricFogMaxDistance = View.VolumetricFogMaxDistance;
	Result.VolumetricLightmapWorldToUVScale = View.VolumetricLightmapWorldToUVScale;
	Result.VolumetricLightmapWorldToUVAdd = View.VolumetricLightmapWorldToUVAdd;
	Result.VolumetricLightmapIndirectionTextureSize = View.VolumetricLightmapIndirectionTextureSize;
	Result.VolumetricLightmapBrickSize = View.VolumetricLightmapBrickSize;
	Result.VolumetricLightmapBrickTexelSize = View.VolumetricLightmapBrickTexelSize;
	Result.IndirectLightingCacheShowFlag = View.IndirectLightingCacheShowFlag;
	Result.EyeToPixelSpreadAngle = View.EyeToPixelSpreadAngle;
	Result.XRPassthroughCameraUVs = View.XRPassthroughCameraUVs;
	Result.GlobalVirtualTextureMipBias = View.GlobalVirtualTextureMipBias;
	Result.VirtualTextureFeedbackShift = View.VirtualTextureFeedbackShift;
	Result.VirtualTextureFeedbackMask = View.VirtualTextureFeedbackMask;
	Result.VirtualTextureFeedbackStride = View.VirtualTextureFeedbackStride;
	Result.VirtualTextureFeedbackJitterOffset = View.VirtualTextureFeedbackJitterOffset;
	Result.VirtualTextureFeedbackSampleOffset = View.VirtualTextureFeedbackSampleOffset;
	Result.RuntimeVirtualTextureMipLevel = View.RuntimeVirtualTextureMipLevel;
	Result.RuntimeVirtualTexturePackHeight = View.RuntimeVirtualTexturePackHeight;
	Result.RuntimeVirtualTextureDebugParams = View.RuntimeVirtualTextureDebugParams;
	Result.FarShadowStaticMeshLODBias = View.FarShadowStaticMeshLODBias;
	Result.MinRoughness = View.MinRoughness;
	Result.HairRenderInfo = View.HairRenderInfo;
	Result.EnableSkyLight = View.EnableSkyLight;
	Result.HairRenderInfoBits = View.HairRenderInfoBits;
	Result.HairComponents = View.HairComponents;
	Result.bSubsurfacePostprocessEnabled = View.bSubsurfacePostprocessEnabled;
	Result.SSProfilesTextureSizeAndInvSize = View.SSProfilesTextureSizeAndInvSize;
	Result.SSProfilesPreIntegratedTextureSizeAndInvSize = View.SSProfilesPreIntegratedTextureSizeAndInvSize;
	Result.SpecularProfileTextureSizeAndInvSize = View.SpecularProfileTextureSizeAndInvSize;
	Result.PhysicsFieldClipmapCenter = View.PhysicsFieldClipmapCenter;
	Result.PhysicsFieldClipmapDistance = View.PhysicsFieldClipmapDistance;
	Result.PhysicsFieldClipmapResolution = View.PhysicsFieldClipmapResolution;
	Result.PhysicsFieldClipmapExponent = View.PhysicsFieldClipmapExponent;
	Result.PhysicsFieldClipmapCount = View.PhysicsFieldClipmapCount;
	Result.PhysicsFieldTargetCount = View.PhysicsFieldTargetCount;
	Result.PhysicsFieldTargets = View.PhysicsFieldTargets;
	Result.GPUSceneViewId = View.GPUSceneViewId;
	Result.ViewResolutionFraction = View.ViewResolutionFraction;
	Result.SubSurfaceColorAsTransmittanceAtDistanceInMeters = View.SubSurfaceColorAsTransmittanceAtDistanceInMeters;
	Result.TanAndInvTanHalfFOV = View.TanAndInvTanHalfFOV;
	Result.PrevTanAndInvTanHalfFOV = View.PrevTanAndInvTanHalfFOV;
	Result.WorldDepthToPixelWorldRadius = View.WorldDepthToPixelWorldRadius;
	Result.ScreenRayLengthMultiplier = View.ScreenRayLengthMultiplier;
	Result.GlintLUTParameters0 = View.GlintLUTParameters0;
	Result.GlintLUTParameters1 = View.GlintLUTParameters1;
	Result.EnvironmentComponentsFlags = View.EnvironmentComponentsFlags;
	FinalizeViewState(Result);
	return Result;
}
void FinalizeViewState(inout ViewState InOutView)
{
	InOutView.WorldToClip = MakeDFInverseMatrix(InOutView.ViewOriginHigh, InOutView.RelativeWorldToClip);
	InOutView.ClipToWorld = MakeDFMatrix(InOutView.ViewOriginHigh, InOutView.ClipToRelativeWorld);
	InOutView.ScreenToWorld = MakeDFMatrix(InOutView.ViewOriginHigh, InOutView.ScreenToRelativeWorld);
	InOutView.PrevClipToWorld = MakeDFMatrix(InOutView.ViewOriginHigh, InOutView.PrevClipToRelativeWorld);
	InOutView.WorldCameraOrigin = MakeDFVector3(InOutView.ViewOriginHigh, InOutView.ViewOriginLow);
	InOutView.WorldViewOrigin = MakeDFVector3(InOutView.WorldViewOriginHigh, InOutView.WorldViewOriginLow);
	InOutView.PrevWorldCameraOrigin = MakeDFVector3(InOutView.PrevWorldCameraOriginHigh, InOutView.PrevWorldCameraOriginLow);
	InOutView.PrevWorldViewOrigin = MakeDFVector3(InOutView.PrevWorldViewOriginHigh, InOutView.PrevWorldViewOriginLow);
	InOutView.PreViewTranslation = MakeDFVector3(InOutView.PreViewTranslationHigh, InOutView.PreViewTranslationLow);
	InOutView.PrevPreViewTranslation = MakeDFVector3(InOutView.PrevPreViewTranslationHigh, InOutView.PrevPreViewTranslationLow);
	InOutView.TileOffset.WorldCameraOrigin = MakeLWCVector3(InOutView.ViewTilePosition, InOutView.RelativeWorldCameraOriginTO);
	InOutView.TileOffset.WorldViewOrigin = MakeLWCVector3(InOutView.ViewTilePosition, InOutView.RelativeWorldViewOriginTO);
	InOutView.TileOffset.PrevWorldCameraOrigin = MakeLWCVector3(InOutView.ViewTilePosition, InOutView.PrevRelativeWorldCameraOriginTO);
	InOutView.TileOffset.PrevWorldViewOrigin = MakeLWCVector3(InOutView.ViewTilePosition, InOutView.PrevRelativeWorldViewOriginTO);
	InOutView.TileOffset.PreViewTranslation = MakeLWCVector3(-InOutView.ViewTilePosition, InOutView.RelativePreViewTranslationTO);
	InOutView.TileOffset.PrevPreViewTranslation = MakeLWCVector3(-InOutView.ViewTilePosition, InOutView.RelativePrevPreViewTranslationTO);
}
static ViewState ResolvedView = (ViewState)0.0f;
ViewState ResolveView()
{
	return GetPrimaryView();
}
static float GlobalTextureMipBias = 0;
float ComputeRayConeLod(Texture2D Tex)
{
    return 0.0f;
}
float4 Texture2DSample(Texture2D Tex, SamplerState Sampler, float2 UV)
{
	return Tex.SampleLevel(Sampler, UV, ComputeRayConeLod(Tex) + GlobalTextureMipBias);
}
float4 Texture2DSample(Texture2D Tex, SamplerState Sampler, FloatDeriv2 UV)
{
	return Tex.SampleLevel(Sampler, UV.Value, ComputeRayConeLod(Tex) + GlobalTextureMipBias);
}
float4 Texture2DSampleGrad(Texture2D Tex, SamplerState Sampler, float2 UV, float2 DDX, float2 DDY)
{
	return Tex.SampleGrad(Sampler, UV, DDX, DDY);
}
float PositiveClampedPow(float Base, float Exponent)
{
	return (Base <= 2.980233e-8f) ? 0.0f : pow(Base, Exponent);
}
float2 PositiveClampedPow(float2 Base, float2 Exponent)
{
	return float2(PositiveClampedPow(Base.x, Exponent.x), PositiveClampedPow(Base.y, Exponent.y)); 
}
float3 PositiveClampedPow(float3 Base, float3 Exponent)
{
	return float3(PositiveClampedPow(Base.xy, Exponent.xy), PositiveClampedPow(Base.z, Exponent.z)); 
}
float4 PositiveClampedPow(float4 Base, float4 Exponent)
{
	return float4(PositiveClampedPow(Base.xy, Exponent.xy), PositiveClampedPow(Base.zw, Exponent.zw)); 
}
float DDX(float Input)
{
	return 0;
}
float2 DDX(float2 Input)
{
	return 0;
}
float3 DDX(float3 Input)
{
	return 0;
}
float4 DDX(float4 Input)
{
	return 0;
}
float DDY(float Input)
{
	return 0;
}
float2 DDY(float2 Input)
{
	return 0;
}
float3 DDY(float3 Input)
{
	return 0;
}
float4 DDY(float4 Input)
{
	return 0;
}
uint3 Rand3DPCG32(int3 p)
{
	uint3 v = uint3(p);
	v = v * 1664525u + 1013904223u;
	v.x += v.y*v.z;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	v ^= v >> 16u;
	v.x += v.y*v.z;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	return v;
}
float Pow2( float x )
{
	return x*x;
}
float2 Pow2( float2 x )
{
	return x*x;
}
float3 Pow2( float3 x )
{
	return x*x;
}
float4 Pow2( float4 x )
{
	return x*x;
}
bool IsOrthoProjection(float4x4 ViewToClip)
{
	return ViewToClip._44 >= 1.0f;
}
bool IsOrthoProjection(ViewState InView)
{
	return IsOrthoProjection(InView.ViewToClip);
}
bool IsOrthoProjection()
{
	return IsOrthoProjection(View.ViewToClip);
}
float2 ScreenPositionToBufferUV(float4 ScreenPosition)
{
	return float2(ScreenPosition.xy / ScreenPosition.w * ResolvedView.ScreenPositionScaleBias.xy + ResolvedView.ScreenPositionScaleBias.wz);
}
void SvPositionToResolvedScreenPositionDeriv(float4 SvPosition, float2 PPZ_DDX_DDY, float2 W_DDX_DDY, inout float4 ScreenPosition, inout float4 ScreenPositionDDX, inout float4 ScreenPositionDDY)
{
	float2 PixelPos = SvPosition.xy - ResolvedView.ViewRectMin.xy;
	float4 NDCPos = float4((PixelPos * ResolvedView.ViewSizeAndInvSize.zw - 0.5f) * float2(2, -2), SvPosition.z, 1.0f);
	float4 NDCPosDDX = float4(ResolvedView.ViewSizeAndInvSize.z * 2.0f, 0.0f, PPZ_DDX_DDY.x, 0.0f);
	float4 NDCPosDDY = float4(ResolvedView.ViewSizeAndInvSize.w * 2.0f, 0.0f, PPZ_DDX_DDY.y, 0.0f);
	ScreenPosition = NDCPos * SvPosition.w;
	ScreenPositionDDX = NDCPos * W_DDX_DDY.x + NDCPosDDX * SvPosition.w;
	ScreenPositionDDY = NDCPos * W_DDX_DDY.y + NDCPosDDY * SvPosition.w;
}
float4 UnpackNormalMap( float4 TextureSample )
{
		float2 NormalXY = TextureSample.rg;
	NormalXY = NormalXY * float2(2.0f,2.0f) - float2(1.0f,1.0f);
	float NormalZ = sqrt( saturate( 1.0f - dot( NormalXY, NormalXY ) ) );
	return float4( NormalXY.xy, NormalZ, 1.0f );
}
float3 TransformTangentVectorToWorld(float3x3 TangentToWorld, float3 InTangentVector)
{
	return mul(InTangentVector, TangentToWorld);
}
float3 HemiOctahedronToUnitVector( float2 Oct )
{
	Oct = float2( Oct.x + Oct.y, Oct.x - Oct.y );
	float3 N = float3( Oct, 2.0 - dot( 1, abs(Oct) ) );
	return normalize(N);
}
bool WaveReadLaneAt(bool In, uint SrcIndex)
{
	return (bool)WaveReadLaneAt((uint)In, SrcIndex);
}
float4x4 WaveReadLaneAtMatrix(float4x4 In, uint SrcIndex)
{
	float4x4 Result;
	Result[0] = WaveReadLaneAt(In[0], SrcIndex);
	Result[1] = WaveReadLaneAt(In[1], SrcIndex);
	Result[2] = WaveReadLaneAt(In[2], SrcIndex);
	Result[3] = WaveReadLaneAt(In[3], SrcIndex);
	return Result;
}
float3x3 WaveReadLaneAtMatrix(float3x3 In, uint SrcIndex)
{
	float3x3 Result;
	Result[0] = WaveReadLaneAt(In[0], SrcIndex);
	Result[1] = WaveReadLaneAt(In[1], SrcIndex);
	Result[2] = WaveReadLaneAt(In[2], SrcIndex);
	return Result;
}
static const uint InstanceTransformSizeFloat4Count = 2u;
struct FPrimitiveSceneData
{
	uint		Flags;
	uint		VisibilityFlags;
	int			InstanceSceneDataOffset; 
	int			NumInstanceSceneDataEntries;
	int			PersistentPrimitiveIndex;
	uint		SingleCaptureIndex; 
	float3		PositionHigh;
	uint		PrimitiveComponentId; 
	FDFMatrix	LocalToWorld;
	FDFInverseMatrix WorldToLocal;
	FDFMatrix	PreviousLocalToWorld;
	FDFInverseMatrix PreviousWorldToLocal;
	float4x4	WorldToPreviousWorld; 
	float3		InvNonUniformScale;
	float		ObjectBoundsX;
	FDFVector3	ObjectWorldPosition;
	FDFVector3	ActorWorldPosition;
	float		MinMaterialDisplacement;
	float		MaxMaterialDisplacement;
	FLWCVector3	ObjectWorldPositionTO;
	FLWCVector3	ActorWorldPositionTO;
	float		ObjectRadius;
	uint		LightmapUVIndex;   
	float3		ObjectOrientation; 
	uint		LightmapDataIndex; 
	float4		NonUniformScale;
	float3		PreSkinnedLocalBoundsMin;
	uint		NaniteResourceID;
	float3		PreSkinnedLocalBoundsMax;
	uint		NaniteHierarchyOffset;
	float3		LocalObjectBoundsMin;
	float		ObjectBoundsY;
	float3		LocalObjectBoundsMax;
	float		ObjectBoundsZ;
	uint		InstancePayloadDataOffset;
	uint		InstancePayloadDataStride;
	uint		InstancePayloadExtensionSize;
	float3		InstanceLocalBoundsCenter;
	float3		InstanceLocalBoundsExtent;
	float3		WireframeColor; 
	float3		PrimitiveColor; 
	uint		PackedNaniteFlags;
	float2 		InstanceDrawDistanceMinMaxSquared;
	float		InstanceWPODisableDistanceSquared;
	uint		NaniteRayTracingDataOffset;
	float		MaxWPOExtent;
	uint		CustomStencilValueAndMask;
	float4		CustomPrimitiveData[9u]; 
};
float3 UnpackColorRGB24(float PackedColorFloat)
{
	uint PackedColor = asuint(PackedColorFloat);
	return float3
	(
		float((PackedColor >> 24u) & 0xFF),
		float((PackedColor >> 16u) & 0xFF),
		float((PackedColor >>  8u) & 0xFF)
	) * (1.0f / 255.0f);
}
struct FInstanceSceneEditorData
{
	float3 HitProxyId;
	uint   HitProxyPacked;
	bool bIsSelected;
};
struct FInstanceSceneData
{
	FDFMatrix LocalToWorld;
	FDFMatrix PrevLocalToWorld;
	FDFInverseMatrix WorldToLocal;
	float4   NonUniformScale;
	float3   InvNonUniformScale;
	float    DeterminantSign;
	float3   LocalBoundsCenter;
	uint     PrimitiveId;
	uint     RelativeId;
	uint     PayloadDataOffset;
	uint     PayloadExtensionOffset;
	uint     PayloadExtensionSize;
	float3   LocalBoundsExtent;
	uint     LastUpdateSceneFrameNumber;
	uint     NaniteRuntimeResourceID;
	uint     NaniteHierarchyOffset;
	float    RandomID;
	float4   LightMapAndShadowMapUVBias;
	bool     ValidInstance;
	uint     Flags;
	FInstanceSceneEditorData EditorData;
};
FInstanceSceneData WaveReadLaneAt(FInstanceSceneData In, uint SrcIndex)
{
	FInstanceSceneData Result;
	Result.LocalToWorld					= WaveReadLaneAt(In.LocalToWorld, SrcIndex);
	Result.PrevLocalToWorld				= WaveReadLaneAt(In.PrevLocalToWorld, SrcIndex);
	Result.WorldToLocal					= WaveReadLaneAt(In.WorldToLocal, SrcIndex);
	Result.NonUniformScale				= WaveReadLaneAt(In.NonUniformScale, SrcIndex);
	Result.InvNonUniformScale			= WaveReadLaneAt(In.InvNonUniformScale, SrcIndex);
	Result.DeterminantSign				= WaveReadLaneAt(In.DeterminantSign, SrcIndex);
	Result.LocalBoundsCenter			= WaveReadLaneAt(In.LocalBoundsCenter, SrcIndex);
	Result.PrimitiveId					= WaveReadLaneAt(In.PrimitiveId, SrcIndex);
	Result.RelativeId					= WaveReadLaneAt(In.RelativeId, SrcIndex);
	Result.PayloadDataOffset			= WaveReadLaneAt(In.PayloadDataOffset, SrcIndex);
	Result.PayloadExtensionOffset		= WaveReadLaneAt(In.PayloadExtensionOffset, SrcIndex);
	Result.PayloadExtensionSize			= WaveReadLaneAt(In.PayloadExtensionSize, SrcIndex);
	Result.LocalBoundsExtent			= WaveReadLaneAt(In.LocalBoundsExtent, SrcIndex);
	Result.LocalBoundsCenter			= WaveReadLaneAt(In.LocalBoundsCenter, SrcIndex);
	Result.PrimitiveId					= WaveReadLaneAt(In.PrimitiveId, SrcIndex);
	Result.RelativeId					= WaveReadLaneAt(In.RelativeId, SrcIndex);
	Result.PayloadDataOffset			= WaveReadLaneAt(In.PayloadDataOffset, SrcIndex);
	Result.PayloadExtensionOffset		= WaveReadLaneAt(In.PayloadExtensionOffset, SrcIndex);
	Result.PayloadExtensionSize			= WaveReadLaneAt(In.PayloadExtensionSize, SrcIndex);
	Result.LocalBoundsExtent			= WaveReadLaneAt(In.LocalBoundsExtent, SrcIndex);
	Result.LastUpdateSceneFrameNumber	= WaveReadLaneAt(In.LastUpdateSceneFrameNumber, SrcIndex);
	Result.NaniteRuntimeResourceID		= WaveReadLaneAt(In.NaniteRuntimeResourceID, SrcIndex);
	Result.NaniteHierarchyOffset		= WaveReadLaneAt(In.NaniteHierarchyOffset, SrcIndex);
	Result.RandomID						= WaveReadLaneAt(In.RandomID, SrcIndex);
	Result.LightMapAndShadowMapUVBias	= WaveReadLaneAt(In.LightMapAndShadowMapUVBias, SrcIndex);
	Result.ValidInstance				= WaveReadLaneAt(In.ValidInstance, SrcIndex);
	Result.Flags						= WaveReadLaneAt(In.Flags, SrcIndex);
	return Result;
}
float4 LoadPrimitivePrimitiveSceneDataElement(uint PrimitiveIndex, uint ItemIndex)
{
	uint TargetIdx = PrimitiveIndex + ItemIndex;
	 { };
	return Scene_GPUScene_GPUScenePrimitiveSceneData[TargetIdx];
}
FPrimitiveSceneData GetPrimitiveData(uint PrimitiveId)
{
	FPrimitiveSceneData PrimitiveData = (FPrimitiveSceneData)0;
	uint PrimitiveIndex = PrimitiveId * 42;
	float3 PositionHigh = LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 1).xyz;
	const float4x4 LocalToWorld = transpose(float4x4(
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 2),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 3),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 4),
		float4(0, 0, 0, 1)
	));
	const float4x4 PreviousLocalToWorld = transpose(float4x4(
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 8),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 9),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 10),
		float4(0, 0, 0, 1)
	));
	const float4x4 WorldToLocal = transpose(float4x4(
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 5),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 6),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 7),
		float4(0, 0, 0, 1)
	));
	const float4x4 PreviousWorldToLocal = transpose(float4x4(
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 11),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 12),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 13),
		float4(0, 0, 0, 1)
	));
	const float4x4 WorldToPreviousWorld = transpose(float4x4(
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 14),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 15),
		LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 16),
		float4(0, 0, 0, 1)
	));
	float4 ObjectWorldPositionHighAndRadius	= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 18);
	float4 ObjectWorldPositionLow			= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 19);
	float4 ActorWorldPositionHigh	= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 20);
	float4 ActorWorldPositionLow	= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 21);
	PrimitiveData.Flags									= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 0).x);
	PrimitiveData.InstanceSceneDataOffset				= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 0).y);
	PrimitiveData.NumInstanceSceneDataEntries			= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 0).z);
	PrimitiveData.SingleCaptureIndex					= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 0).w) & 0xFFFFu;
	PrimitiveData.VisibilityFlags						= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 0).w) >> 16u;
	PrimitiveData.PositionHigh							= PositionHigh; 
	PrimitiveData.PrimitiveComponentId					= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 1).w);
	PrimitiveData.LocalToWorld							= MakeDFMatrix4x3(PositionHigh, LocalToWorld);
	PrimitiveData.WorldToLocal							= MakeDFInverseMatrix4x3(PositionHigh, WorldToLocal);
	PrimitiveData.PreviousLocalToWorld					= MakeDFMatrix4x3(PositionHigh, PreviousLocalToWorld);
	PrimitiveData.PreviousWorldToLocal					= MakeDFInverseMatrix4x3(PositionHigh, PreviousWorldToLocal);
	PrimitiveData.WorldToPreviousWorld					= WorldToPreviousWorld;
	PrimitiveData.InvNonUniformScale					= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 17).xyz;
	PrimitiveData.ObjectBoundsX							= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 17).w;
	PrimitiveData.ObjectRadius							= ObjectWorldPositionHighAndRadius.w;
	PrimitiveData.ObjectWorldPositionTO					= MakeLWCVector3(ObjectWorldPositionHighAndRadius.xyz, ObjectWorldPositionLow.xyz);
	PrimitiveData.ActorWorldPositionTO					= MakeLWCVector3(ActorWorldPositionHigh.xyz, ActorWorldPositionLow.xyz);
	PrimitiveData.ObjectWorldPosition					= DFFromTileOffset(PrimitiveData.ObjectWorldPositionTO);
	PrimitiveData.ActorWorldPosition					= DFFromTileOffset(PrimitiveData.ActorWorldPositionTO);
	PrimitiveData.MinMaterialDisplacement				= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 19).w;
	PrimitiveData.MaxMaterialDisplacement				= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 20).w;
	PrimitiveData.LightmapUVIndex						= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 21).w);
	PrimitiveData.ObjectOrientation						= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 22).xyz;
	PrimitiveData.LightmapDataIndex						= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 22).w);
	PrimitiveData.NonUniformScale						= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 23);
	PrimitiveData.PreSkinnedLocalBoundsMin				= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 24).xyz;
	PrimitiveData.NaniteResourceID						= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 24).w);
	PrimitiveData.PreSkinnedLocalBoundsMax				= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 25).xyz;
	PrimitiveData.NaniteHierarchyOffset					= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 25).w);
	PrimitiveData.LocalObjectBoundsMin					= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 26).xyz;
	PrimitiveData.ObjectBoundsY							= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 26).w;
	PrimitiveData.LocalObjectBoundsMax					= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 27).xyz;
	PrimitiveData.ObjectBoundsZ							= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 27).w;
	PrimitiveData.InstanceLocalBoundsCenter				= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 28).xyz;
	PrimitiveData.InstancePayloadDataOffset				= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 28).w);
	PrimitiveData.InstanceLocalBoundsExtent				= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 29).xyz;
	PrimitiveData.InstancePayloadDataStride				= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 29).w) & 0x00FFFFFFu;
	PrimitiveData.InstancePayloadExtensionSize			= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 29).w) >> 24;
	PrimitiveData.WireframeColor						= UnpackColorRGB24(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 30).x);
	PrimitiveData.PrimitiveColor						= UnpackColorRGB24(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 30).y);
	PrimitiveData.PackedNaniteFlags						= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 30).z);
	PrimitiveData.PersistentPrimitiveIndex				= asint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 30).w);
	PrimitiveData.InstanceDrawDistanceMinMaxSquared		= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 31).xy;
	PrimitiveData.InstanceWPODisableDistanceSquared		= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 31).z;
	PrimitiveData.NaniteRayTracingDataOffset			= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 31).w);
	PrimitiveData.MaxWPOExtent							= LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 32).x;
	PrimitiveData.CustomStencilValueAndMask				= asuint(LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex, 32).y);
	[unroll]
	for (int DataIndex = 0; DataIndex < 9u; ++DataIndex)
	{
		PrimitiveData.CustomPrimitiveData[DataIndex] = LoadPrimitivePrimitiveSceneDataElement(PrimitiveIndex,  33 + DataIndex);
	}
	return PrimitiveData;
}
float3 UnpackHitProxyId(uint HitProxyPacked)
{
	return float3
	(
		float((HitProxyPacked       ) & 0xFF),
		float((HitProxyPacked >>  8u) & 0xFF),
		float((HitProxyPacked >> 16u) & 0xFF)
	) * (1.0f / 255.0f);
}
struct FInstancePayloadDataOffsets
{
	uint HierarchyOffset;
	uint EditorData;
	uint LocalBounds;
	uint DynamicData;
	uint LightShadowUVBias;
	uint PayloadExtension;
	uint CustomData;
};
uint GetGPUSceneFrameNumber()
{
	return Scene.GPUScene_GPUSceneFrameNumber;
}
float4 LoadInstanceSceneDataElement(uint Index)
{
	return Scene_GPUScene_GPUSceneInstanceSceneData[Index];
}
float4 LoadInstancePayloadDataElement(uint Index)
{
	return Scene_GPUScene_GPUSceneInstancePayloadData[Index];
}
void GetHemiOrthoBasis( inout float3 BasisX, inout float3 BasisY, float3 BasisZ )
{
	float A = 1.0f / ( 1.0f + BasisZ.z );
	float B = -BasisZ.x * BasisZ.y * A;
	BasisX = float3( 1.0f - BasisZ.x * BasisZ.x * A, B, -BasisZ.x );
	BasisY = float3( B, 1.0f - BasisZ.y * BasisZ.y * A, -BasisZ.y );
}
float4x4 DecodeTransform( uint4 RotationScale, float3 Translation, inout float3 Scale )
{
	float4x4 M = 0.0;
	M[3].xyz = Translation;
	M[3].w = 1.0;
	{
		float3 Rotation =
		{
			( RotationScale[0] >>  0 ) & 0xffff,
			( RotationScale[0] >> 16 ) & 0xffff,
			( RotationScale[1] >>  0 ) & 0x7fff
		};
		float2 OctZ  = ( Rotation.xy - 32768 ) * (1.0f / 32767.0f);
		float Spin0  = ( Rotation.z  - 16384 ) * (0.70710678f / 16383.0f);	
		bool bSpinIsX = RotationScale[1] & 0x8000;
		M[2].xyz = HemiOctahedronToUnitVector( OctZ );
		float3 BasisX, BasisY;
		GetHemiOrthoBasis( BasisX, BasisY, M[2].xyz );
		float Spin1 = sqrt( 1.0f - Spin0 * Spin0 );
		float X = bSpinIsX ? Spin0 : Spin1;
		float Y = bSpinIsX ? Spin1 : Spin0;
		M[0].xyz = BasisX * X + BasisY * Y;
		M[1].xyz = cross( M[2].xyz, M[0].xyz );
	}
	{
		const uint SignMantissaBits	= 16;
		const uint SignMantissaMask	= (1u << SignMantissaBits) - 1;
		const uint MantissaBits		= SignMantissaBits - 1;
		uint SharedExp = RotationScale[3] >> 16;
		float ExpScale = asfloat( ( SharedExp - MantissaBits ) << 23 );
		uint3 Mantissa =
		{
			RotationScale[2] >> 0,
			RotationScale[2] >> 16,
			RotationScale[3] >> 0
		};
		Mantissa &= SignMantissaMask;
		Scale = Mantissa;
		Scale -= 1u << MantissaBits;
		Scale *= ExpScale;
		M[0] *= Scale[0];
		M[1] *= Scale[1];
		M[2] *= Scale[2];
	}
	return M;
}
void UnpackPrimitiveIdAndInstanceFlags(uint PackedPrimitiveIdAndFlags, inout uint OutPrimitiveId, inout uint OutInstanceFlags)
{
	OutPrimitiveId		= BitFieldExtractU32(PackedPrimitiveIdAndFlags, (20u),  0);
	OutInstanceFlags	= BitFieldExtractU32(PackedPrimitiveIdAndFlags, (12u), (20u));	
}
void LoadInstancePrimitiveIdAndFlags(uint InstanceId, uint SOAStride, inout uint OutPrimitiveId, inout uint OutInstanceFlags)
{
	const uint PackedPrimitiveIdAndFlags = asuint(LoadInstanceSceneDataElement(0 * SOAStride + InstanceId).x);
	UnpackPrimitiveIdAndInstanceFlags(PackedPrimitiveIdAndFlags, OutPrimitiveId, OutInstanceFlags);
}
void UnpackInstanceRelativeIdAndCustomDataCount(uint PackedRelativeIdAndCustomDataCount, inout uint OutRelativeId, inout uint OutCustomDataCount)
{
	OutRelativeId		= BitFieldExtractU32(PackedRelativeIdAndCustomDataCount, (24u),  0);
	OutCustomDataCount	= BitFieldExtractU32(PackedRelativeIdAndCustomDataCount, (8u), (24u));
}
void LoadInstanceRelativeIdAndCustomDataCount(uint InstanceId, uint SOAStride, inout uint OutPrimitiveId, inout uint OutInstanceFlags)
{
	const uint PackedRelativeIdAndCustomDataCount = asuint(LoadInstanceSceneDataElement(0 * SOAStride + InstanceId).y);
	UnpackInstanceRelativeIdAndCustomDataCount(PackedRelativeIdAndCustomDataCount, OutPrimitiveId, OutInstanceFlags);
}
float GetInstanceDeterminantSignFromFlags(uint Flags)
{
	return CondMask(Flags & 0x1, -1.0f, 1.0f);
}
FInstancePayloadDataOffsets GetInstancePayloadDataOffsets(uint PrimitiveId, uint Flags, uint InstanceRelativeId)
{
	FPrimitiveSceneData PrimitiveData = GetPrimitiveData(PrimitiveId);
	const uint PayloadDataRelativeOffset	= InstanceRelativeId * PrimitiveData.InstancePayloadDataStride;
	const uint PayloadDataGlobalOffset		= PayloadDataRelativeOffset + PrimitiveData.InstancePayloadDataOffset;
	const bool bHasHierarchyOffset			= (Flags & 0x20) != 0u;
	const bool bHasLocalBounds				= (Flags & 0x40) != 0u;
	const bool bHasDynamicData				= (Flags & 0x8) != 0u;
	const bool bHasLightShadowUVBias		= (Flags & 0x10) != 0u;
	const bool bHasCustomData				= (Flags & 0x4) != 0u;
	const bool bHasPayloadExtension			= (Flags & 0x80) != 0u;
	const bool bHasEditorData				= (Flags & 0x100) != 0u;
	uint CurOffset = PayloadDataGlobalOffset;
	FInstancePayloadDataOffsets Offsets;
	Offsets.HierarchyOffset 	= (0xFFFFFFFFu);
	Offsets.EditorData 			= (0xFFFFFFFFu);
	Offsets.LocalBounds 		= (0xFFFFFFFFu);
	Offsets.DynamicData 		= (0xFFFFFFFFu);
	Offsets.LightShadowUVBias 	= (0xFFFFFFFFu);
	Offsets.PayloadExtension	= (0xFFFFFFFFu);
	Offsets.CustomData			= (0xFFFFFFFFu);
	if (bHasHierarchyOffset)
	{
		Offsets.HierarchyOffset = CurOffset;
	}
	if (bHasEditorData)
	{
		Offsets.EditorData = CurOffset;
	}
	if (bHasLocalBounds)
	{
		Offsets.LocalBounds = CurOffset;
	}
	CurOffset += CondMask(bHasLocalBounds, 2u, CondMask(bHasHierarchyOffset || bHasEditorData, 1u, 0u));
	if (bHasDynamicData)
	{
		Offsets.DynamicData = CurOffset;
		CurOffset += InstanceTransformSizeFloat4Count;
	}
	if (bHasLightShadowUVBias)
	{
		Offsets.LightShadowUVBias = CurOffset;
		++CurOffset;
	}
	if (bHasPayloadExtension)
	{
		Offsets.PayloadExtension = CurOffset;
		CurOffset += PrimitiveData.InstancePayloadExtensionSize;
	}
	if (bHasCustomData)
	{
		Offsets.CustomData = CurOffset;
	}
	return Offsets;
}
void ComputeInstanceDerivedData(inout FInstanceSceneData InstanceData, float3 PositionHigh, float4x4 LocalToRelativeWorld)
{
	InstanceData.NonUniformScale.w							= max3( InstanceData.NonUniformScale.x, InstanceData.NonUniformScale.y, InstanceData.NonUniformScale.z );
	InstanceData.DeterminantSign							= GetInstanceDeterminantSignFromFlags(InstanceData.Flags);
	float4x4 RelativeWorldToLocal							= LocalToRelativeWorld;
	RelativeWorldToLocal[0].xyz							   *= Pow2(InstanceData.InvNonUniformScale.x);
	RelativeWorldToLocal[1].xyz					           *= Pow2(InstanceData.InvNonUniformScale.y);
	RelativeWorldToLocal[2].xyz					           *= Pow2(InstanceData.InvNonUniformScale.z);
	RelativeWorldToLocal[3].xyz						        = 0.0f;
	RelativeWorldToLocal								    = transpose(RelativeWorldToLocal);
	RelativeWorldToLocal[3].xyz						        = mul(float4(-LocalToRelativeWorld[3].xyz, 0.0f), RelativeWorldToLocal).xyz;
	InstanceData.WorldToLocal								= MakeDFInverseMatrix(PositionHigh, RelativeWorldToLocal);
}
FInstanceSceneData GetInstanceSceneData(uint InstanceId, uint SOAStride, bool bCheckValid = true)
{
	FInstanceSceneData InstanceData = (FInstanceSceneData)0;
	LoadInstancePrimitiveIdAndFlags(InstanceId, SOAStride, InstanceData.PrimitiveId, InstanceData.Flags);
	InstanceData.ValidInstance = InstanceData.PrimitiveId != ((1u << (20u)) - 1u) &&
								 ((InstanceData.Flags & 0x200) == 0u);
	[branch]
	if (!bCheckValid || InstanceData.ValidInstance)
	{
		uint CustomDataCount;
		LoadInstanceRelativeIdAndCustomDataCount(InstanceId, SOAStride, InstanceData.RelativeId, CustomDataCount);
		FInstancePayloadDataOffsets Offsets 	= GetInstancePayloadDataOffsets(InstanceData.PrimitiveId, InstanceData.Flags, InstanceData.RelativeId);
		InstanceData.LastUpdateSceneFrameNumber	= asuint(LoadInstanceSceneDataElement(0 * SOAStride + InstanceId).z);
		InstanceData.RandomID					= LoadInstanceSceneDataElement(0 * SOAStride + InstanceId).w;
		FPrimitiveSceneData PrimitiveData		= GetPrimitiveData(InstanceData.PrimitiveId);
		float3 PositionHigh 									= PrimitiveData.PositionHigh;
		uint4  RotationScale									= asuint(LoadInstanceSceneDataElement(1 * SOAStride + InstanceId));
		float3 Translation										= LoadInstanceSceneDataElement(2 * SOAStride + InstanceId).xyz;
		float3 Scale = 0;
		float4x4 LocalToRelativeWorld							= DecodeTransform( RotationScale, Translation, Scale );
		InstanceData.NonUniformScale.xyz						= abs(Scale);
		InstanceData.InvNonUniformScale							= rcp(InstanceData.NonUniformScale.xyz);
		InstanceData.LocalToWorld	= MakeDFMatrix(PositionHigh, LocalToRelativeWorld);
		ComputeInstanceDerivedData(InstanceData, PositionHigh, LocalToRelativeWorld);
		InstanceData.NaniteRuntimeResourceID	= PrimitiveData.NaniteResourceID;
		InstanceData.NaniteHierarchyOffset		= PrimitiveData.NaniteHierarchyOffset;
		[branch]
		if (Offsets.HierarchyOffset != (0xFFFFFFFFu))
		{
			const uint HierarchyRootOffset = asuint(LoadInstancePayloadDataElement(Offsets.HierarchyOffset)).x;
			InstanceData.NaniteHierarchyOffset += HierarchyRootOffset;
		}
		[branch]
		if (Offsets.EditorData != (0xFFFFFFFFu))
		{
			const uint PackedEditorData = asuint(LoadInstancePayloadDataElement(Offsets.EditorData)).y;
			InstanceData.EditorData.bIsSelected    = (PackedEditorData >> 24u) != 0;
			InstanceData.EditorData.HitProxyPacked =  PackedEditorData & 0x00FFFFFFu;
			InstanceData.EditorData.HitProxyId = UnpackHitProxyId(InstanceData.EditorData.HitProxyPacked);
		}
		[branch]
		if (Offsets.LocalBounds != (0xFFFFFFFFu))
		{
			InstanceData.LocalBoundsCenter = float3(LoadInstancePayloadDataElement(Offsets.LocalBounds + 0).zw, LoadInstancePayloadDataElement(Offsets.LocalBounds + 1).x);
			InstanceData.LocalBoundsExtent = LoadInstancePayloadDataElement(Offsets.LocalBounds + 1).yzw;
		}
		else
		{
			InstanceData.LocalBoundsCenter = PrimitiveData.InstanceLocalBoundsCenter;
			InstanceData.LocalBoundsExtent = PrimitiveData.InstanceLocalBoundsExtent;
		}
		[branch]
		if (Offsets.DynamicData != (0xFFFFFFFFu))
		{
			uint4  PrevRotationScale			= asuint(LoadInstancePayloadDataElement(Offsets.DynamicData + 0));
			float3 PrevTranslation				= LoadInstancePayloadDataElement(Offsets.DynamicData + 1).xyz;
			float3 PrevScale					= 0;
			float4x4 PrevLocalToRelativeWorld	= DecodeTransform(PrevRotationScale, PrevTranslation, PrevScale);
			InstanceData.PrevLocalToWorld		= MakeDFMatrix(PositionHigh, PrevLocalToRelativeWorld);
		}
		else
		{
			InstanceData.PrevLocalToWorld = MakeDFMatrix(PositionHigh, mul(LocalToRelativeWorld, PrimitiveData.WorldToPreviousWorld));
		}
		[branch]
		if (Offsets.LightShadowUVBias != (0xFFFFFFFFu))
		{
			InstanceData.LightMapAndShadowMapUVBias = LoadInstancePayloadDataElement(Offsets.LightShadowUVBias);
		}
		InstanceData.PayloadExtensionOffset = Offsets.PayloadExtension;
		InstanceData.PayloadExtensionSize = PrimitiveData.InstancePayloadExtensionSize;
	}
	return InstanceData;
}
struct FSceneDataIntermediates
{
	uint PrimitiveId;
	uint InstanceId;
	uint ViewIndex;
	uint CullingFlags;
	uint InstanceIdLoadIndex;
	FInstanceSceneData InstanceData;
	FPrimitiveSceneData Primitive;
};
struct FRasterTri
{
	int2	MinPixel;
	int2	MaxPixel;
	float2	Edge01;
	float2	Edge12;
	float2	Edge20;
	float	C0;
	float	C1;
	float	C2;
	float3	DepthPlane;
	float3	InvW;
	float3	Barycentrics_dx;
	float3	Barycentrics_dy;
	bool	bIsValid;
	bool	bBackFace;
};
template< uint SubpixelSamples, bool bBackFaceCull >
FRasterTri SetupTriangle( int4 ScissorRect, float4 Verts[3] )
{
	FRasterTri Tri;
	Tri.bIsValid = true;
	Tri.InvW = float3( Verts[0].w, Verts[1].w, Verts[2].w );
	float3 v01 = Verts[1].xyz - Verts[0].xyz;
	float3 v02 = Verts[2].xyz - Verts[0].xyz;
	float DetXY = v01.x * v02.y - v01.y * v02.x;
	const bool bBackFace = (DetXY >= 0.0f);
	Tri.bBackFace = bBackFace;
	if( bBackFaceCull )
		Tri.bIsValid = !bBackFace;
	float2 Vert0 = Verts[0].xy;
	float2 Vert1 = Verts[1].xy;
	float2 Vert2 = Verts[2].xy;
	const float2 MinSubpixel = min3( Vert0, Vert1, Vert2 );
	const float2 MaxSubpixel = max3( Vert0, Vert1, Vert2 );
	Tri.MinPixel = (int2)floor( ( MinSubpixel + (SubpixelSamples / 2) - 1 ) * (1.0 / SubpixelSamples) );
	Tri.MaxPixel = (int2)floor( ( MaxSubpixel - (SubpixelSamples / 2) - 1 ) * (1.0 / SubpixelSamples) );	
	Tri.MinPixel = max( Tri.MinPixel, ScissorRect.xy );
	Tri.MaxPixel = min( Tri.MaxPixel, ScissorRect.zw - 1 );
	Tri.MaxPixel = min(Tri.MaxPixel, Tri.MinPixel + 63);
	if( any( Tri.MinPixel > Tri.MaxPixel ) )
		Tri.bIsValid = false;
	Tri.Edge01 = -v01.xy;
	Tri.Edge12 = Vert1 - Vert2;
	Tri.Edge20 = v02.xy;
	[branch]
	if( !bBackFaceCull && bBackFace )
	{
		Tri.Edge01 *= -1.0f;
		Tri.Edge12 *= -1.0f;
		Tri.Edge20 *= -1.0f;
	}
	const float2 BaseSubpixel = (float2)Tri.MinPixel * SubpixelSamples + (SubpixelSamples / 2);
	Vert0 -= BaseSubpixel;
	Vert1 -= BaseSubpixel;
	Vert2 -= BaseSubpixel;
	Tri.C0 = Tri.Edge12.y * Vert1.x - Tri.Edge12.x * Vert1.y;
	Tri.C1 = Tri.Edge20.y * Vert2.x - Tri.Edge20.x * Vert2.y;
	Tri.C2 = Tri.Edge01.y * Vert0.x - Tri.Edge01.x * Vert0.y;
	Tri.C0 -= saturate( Tri.Edge12.y + saturate( 1.0f - Tri.Edge12.x ) );
	Tri.C1 -= saturate( Tri.Edge20.y + saturate( 1.0f - Tri.Edge20.x ) );
	Tri.C2 -= saturate( Tri.Edge01.y + saturate( 1.0f - Tri.Edge01.x ) );
	Tri.C0 *= (1.0f / SubpixelSamples);
	Tri.C1 *= (1.0f / SubpixelSamples);
	Tri.C2 *= (1.0f / SubpixelSamples);
	const float ScaleToUnit = 1.0f / ( Tri.C0 + Tri.C1 + Tri.C2 );
	Tri.Barycentrics_dx = float3( -Tri.Edge12.y, -Tri.Edge20.y, -Tri.Edge01.y ) * ScaleToUnit;
	Tri.Barycentrics_dy = float3(  Tri.Edge12.x,  Tri.Edge20.x,  Tri.Edge01.x ) * ScaleToUnit;
	Tri.DepthPlane.x = Verts[0].z;
	Tri.DepthPlane.y = Verts[1].z - Verts[0].z;
	Tri.DepthPlane.z = Verts[2].z - Verts[0].z;
	Tri.DepthPlane.yz /= Tri.C0 + Tri.C1 + Tri.C2;
	return Tri;
}
template< typename FWritePixel >
void RasterizeTri_Rect( FRasterTri Tri, FWritePixel WritePixel )
{
	float CY0 = Tri.C0;
	float CY1 = Tri.C1;
	float CY2 = Tri.C2;
	int y = Tri.MinPixel.y;
	while (true)
	{
		int x = Tri.MinPixel.x;
		if (min3(CY0, CY1, CY2) >= 0)
		{
			WritePixel( uint2(x,y), float3(CY0, CY1, CY2), Tri );
		}
		if (x < Tri.MaxPixel.x)
		{
			float CX0 = CY0 - Tri.Edge12.y;
			float CX1 = CY1 - Tri.Edge20.y;
			float CX2 = CY2 - Tri.Edge01.y;
			x++;
			while (true)
			{
				if (min3(CX0, CX1, CX2) >= 0)
				{
					WritePixel( int2(x,y), float3(CX0, CX1, CX2), Tri );
				}
				if (x >= Tri.MaxPixel.x)
					break;
				CX0 -= Tri.Edge12.y;
				CX1 -= Tri.Edge20.y;
				CX2 -= Tri.Edge01.y;
				x++;
			}
		}
		if (y >= Tri.MaxPixel.y)
			break;
		CY0 += Tri.Edge12.x;
		CY1 += Tri.Edge20.x;
		CY2 += Tri.Edge01.x;
		y++;
	}
}
uint4 UnpackToUint4(uint Value, int4 NumComponentBits)
{
	return uint4(BitFieldExtractU32(Value, NumComponentBits.x, 0),
				 BitFieldExtractU32(Value, NumComponentBits.y, NumComponentBits.x),
				 BitFieldExtractU32(Value, NumComponentBits.z, NumComponentBits.x + NumComponentBits.y),
				 BitFieldExtractU32(Value, NumComponentBits.w, NumComponentBits.x + NumComponentBits.y + NumComponentBits.z));
}
struct FBitStreamReaderState
{
	uint	AlignedByteAddress;
	int		BitOffsetFromAddress;
	uint4	BufferBits;
	int		BufferOffset;
	int		CompileTimeMinBufferBits;
	int		CompileTimeMinDwordBits;
	int		CompileTimeMaxRemainingBits;
};
FBitStreamReaderState BitStreamReader_Create_Aligned(uint AlignedByteAddress, uint BitOffset, uint CompileTimeMaxRemainingBits)
{
	FBitStreamReaderState State;
	State.AlignedByteAddress = AlignedByteAddress;
	State.BitOffsetFromAddress = BitOffset;
	State.BufferBits = 0;
	State.BufferOffset = 0;
	State.CompileTimeMinBufferBits = 0;
	State.CompileTimeMinDwordBits = 0;
	State.CompileTimeMaxRemainingBits = CompileTimeMaxRemainingBits;
	return State;
}
uint    BitStreamReader_Read_RO 
	(ByteAddressBuffer InputBuffer, inout FBitStreamReaderState State, int NumBits, int CompileTimeMaxBits)
{
	if (CompileTimeMaxBits > State.CompileTimeMinBufferBits)
	{
		State.BitOffsetFromAddress += State.BufferOffset;	
		uint Address = State.AlignedByteAddress + ((State.BitOffsetFromAddress >> 5) << 2);
		uint4 Data = InputBuffer.Load4(Address);
		State.BufferBits.x												= BitAlignU32(Data.y,	Data.x,	State.BitOffsetFromAddress); 
		if (State.CompileTimeMaxRemainingBits > 32) State.BufferBits.y	= BitAlignU32(Data.z,	Data.y,	State.BitOffsetFromAddress); 
		if (State.CompileTimeMaxRemainingBits > 64) State.BufferBits.z	= BitAlignU32(Data.w,	Data.z,	State.BitOffsetFromAddress); 
		if (State.CompileTimeMaxRemainingBits > 96) State.BufferBits.w	= BitAlignU32(0,		Data.w,	State.BitOffsetFromAddress); 
		State.BufferOffset = 0;
		State.CompileTimeMinDwordBits	= min(32, State.CompileTimeMaxRemainingBits);
		State.CompileTimeMinBufferBits	= min(97, State.CompileTimeMaxRemainingBits);	
	}
	else if (CompileTimeMaxBits > State.CompileTimeMinDwordBits)
	{
		State.BitOffsetFromAddress += State.BufferOffset;
		const bool bOffset32 = State.CompileTimeMinDwordBits == 0 && State.BufferOffset == 32;
		State.BufferBits.x											= bOffset32 ? State.BufferBits.y :	BitAlignU32(State.BufferBits.y, State.BufferBits.x, State.BufferOffset);
		if (State.CompileTimeMinBufferBits > 32) State.BufferBits.y	= bOffset32 ? State.BufferBits.z :	BitAlignU32(State.BufferBits.z, State.BufferBits.y, State.BufferOffset);
		if (State.CompileTimeMinBufferBits > 64) State.BufferBits.z	= bOffset32 ? State.BufferBits.w :	BitAlignU32(State.BufferBits.w, State.BufferBits.z, State.BufferOffset);
		if (State.CompileTimeMinBufferBits > 96) State.BufferBits.w	= bOffset32 ? 0u :					BitAlignU32(0,					State.BufferBits.w, State.BufferOffset);
		State.BufferOffset = 0;
		State.CompileTimeMinDwordBits = min(32, State.CompileTimeMaxRemainingBits);
	}
	const uint Result = BitFieldExtractU32(State.BufferBits.x, NumBits, State.BufferOffset); 
	State.BufferOffset += NumBits;
	State.CompileTimeMinBufferBits    -= CompileTimeMaxBits;
	State.CompileTimeMinDwordBits     -= CompileTimeMaxBits;
	State.CompileTimeMaxRemainingBits -= CompileTimeMaxBits;
	return Result;
}
uint2    BitStreamReader_Read2_RO 
	(ByteAddressBuffer InputBuffer, inout FBitStreamReaderState State, int2 NumBits, int2 CompileTimeMaxBits)
{
	uint ResultX =    BitStreamReader_Read_RO (InputBuffer, State, NumBits.x, CompileTimeMaxBits.x);
	uint ResultY =    BitStreamReader_Read_RO (InputBuffer, State, NumBits.y, CompileTimeMaxBits.y);
	return uint2(ResultX, ResultY);
}
uint4    BitStreamReader_Read4_RO 
	(ByteAddressBuffer InputBuffer, inout FBitStreamReaderState State, int4 NumBits, int4 CompileTimeMaxBits)
{
	uint ResultX =    BitStreamReader_Read_RO (InputBuffer, State, NumBits.x, CompileTimeMaxBits.x);
	uint ResultY =    BitStreamReader_Read_RO (InputBuffer, State, NumBits.y, CompileTimeMaxBits.y);
	uint ResultZ =    BitStreamReader_Read_RO (InputBuffer, State, NumBits.z, CompileTimeMaxBits.z);
	uint ResultW =    BitStreamReader_Read_RO (InputBuffer, State, NumBits.w, CompileTimeMaxBits.w);
	return uint4(ResultX, ResultY, ResultZ, ResultW);
}
uint ReadBits(uint4 Data, inout uint Position, uint NumBits)
{
	uint DwordIndex = Position >> 5;
	uint BitIndex = Position & 31;
	uint Value = Data[DwordIndex] >> BitIndex;
	if (BitIndex + NumBits > 32)
	{
		Value |= Data[DwordIndex + 1] << (32 - BitIndex);
	}
	Position += NumBits;
	uint Mask = ((1u << NumBits) - 1u);
	return Value & Mask;
}
struct FNaniteRasterBinMeta
{
	uint BinSWCount;
	uint BinHWCount;
	uint ClusterOffset;
	uint MaterialFlags;
	float MaterialDisplacementCenter;
	float MaterialDisplacementMagnitude;
};
struct FVisibleCluster
{
	uint	Flags;
	uint	ViewId;
	uint	InstanceId;
	uint	PageIndex;
	uint	ClusterIndex;
	uint2	vPage;
	uint2	vPageEnd;		
};
struct FPageHeader
{
	uint	NumClusters;
};
struct FCluster
{
	uint	PageBaseAddress;
	uint	NumVerts;
	uint	PositionOffset;
	uint	NumTris;
	uint	IndexOffset;
	int3	PosStart;
	uint	BitsPerIndex;
	int		PosPrecision;
	uint3	PosBits;
	uint	NormalPrecision;
	uint	TangentPrecision;
	float4	LODBounds;
	float3	BoxBoundsCenter;
	float	LODError;
	float	EdgeLength;
	float3	BoxBoundsExtent;
	uint	Flags;
	uint	AttributeOffset;
	uint	BitsPerAttribute;
	uint	DecodeInfoOffset;
	bool	bHasTangents;
	uint	NumUVs;
	uint	ColorMode;
	uint	UVBitOffsets;
	uint	ColorMin;
	uint	ColorBits;
	uint	GroupIndex;		
	uint	MaterialTableOffset;
	uint	MaterialTableLength;
	uint	VertReuseBatchCountTableOffset;	
	uint	VertReuseBatchCountTableSize;	
	uint	Material0Length;
	uint	Material0Index;
	uint 	Material1Length;
	uint	Material1Index;
	uint	Material2Index;
	uint4	VertReuseBatchInfo;
};
struct FInstanceDynamicData
{
	float4x4	LocalToTranslatedWorld;
	float4x4	PrevLocalToTranslatedWorld;
	bool		bHasMoved;
};
struct FNaniteView
{
	float4x4	SVPositionToTranslatedWorld;
	float4x4	ViewToTranslatedWorld;
	float4x4	TranslatedWorldToView;
	float4x4	TranslatedWorldToClip;
	float4x4	ViewToClip;
	FDFMatrix	ClipToWorld;
	float4x4	PrevTranslatedWorldToView;
	float4x4	PrevTranslatedWorldToClip;
	float4x4	PrevViewToClip;
	FDFMatrix	PrevClipToWorld;
	float4		TranslatedGlobalClipPlane;
	int4		ViewRect;
	float4		ViewSizeAndInvSize;
	float4		ClipSpaceScaleOffset;
	FDFVector3	PreViewTranslation;
	FDFVector3	PrevPreViewTranslation;
	FDFVector3	WorldCameraOrigin;
	float3		CullingViewOriginTranslatedWorld;
	float3		ViewForward;
	float3		ViewOriginHigh;
	float		NearPlane;
	float		LODScale;
	float		LODScaleHW;
	float		MinBoundsRadiusSq;
	uint		StreamingPriorityCategory;
	uint		Flags;
	int			TargetLayerIndex;
	int			TargetMipLevel;
	int			TargetNumMipLevels;
	int			TargetPrevLayerIndex;
	float		RangeBasedCullingDistance;
	int4		HZBTestViewRect;
	float		CullingViewScreenMultiple;
	uint		InstanceOcclusionQueryMask;
	uint		LightingChannelMask;
};
uint4 							PageConstants;
ByteAddressBuffer 				ClusterPageData;
ByteAddressBuffer				VisibleClustersSWHW;
FInstanceDynamicData WaveReadLaneAt(FInstanceDynamicData In, uint SrcIndex)
{
	FInstanceDynamicData Result;
	Result.LocalToTranslatedWorld		= WaveReadLaneAtMatrix(In.LocalToTranslatedWorld, SrcIndex);
	Result.PrevLocalToTranslatedWorld	= WaveReadLaneAtMatrix(In.PrevLocalToTranslatedWorld, SrcIndex);
	Result.bHasMoved					= WaveReadLaneAt(In.bHasMoved, SrcIndex);
	return Result;
}
float ClipZFromLinearZ(FNaniteView NaniteView, float LinearZ)
{
	return LinearZ * NaniteView.ViewToClip[2][2] + NaniteView.ViewToClip[3][2]; 
}
void UnpackPoolClusterRef(uint PackedClusterRef, inout uint PageIndex, inout uint ClusterIndex)
{
	const uint MaxStreamingPages = PageConstants.y;
	const uint MaxStreamingClusters = MaxStreamingPages << (17 - 9);
	if (PackedClusterRef < MaxStreamingClusters)
	{
		PageIndex		= PackedClusterRef >> (17 - 9);
		ClusterIndex	= PackedClusterRef & ((1u << (17 - 9)) - 1u);
	}
	else
	{
		PackedClusterRef -= MaxStreamingClusters;
		PageIndex		= MaxStreamingPages + (PackedClusterRef >> (15 - 9));
		ClusterIndex	= PackedClusterRef & ((1u << (15 - 9)) - 1u);
	}
}
FVisibleCluster UnpackVisibleCluster(uint4 RawData, bool bHasPageData = false)
{
	uint BitPos = 0;
	FVisibleCluster VisibleCluster;
	VisibleCluster.Flags		= ReadBits( RawData, BitPos, 4 );
	VisibleCluster.ViewId		= ReadBits( RawData, BitPos, 12 );
	VisibleCluster.InstanceId	= ReadBits( RawData, BitPos, 24 );
	const uint PackedClusterRef = ReadBits( RawData, BitPos, (32 - 9) );
	UnpackPoolClusterRef( PackedClusterRef, VisibleCluster.PageIndex, VisibleCluster.ClusterIndex );
	if( bHasPageData )
	{
		VisibleCluster.vPage.x		= ReadBits( RawData, BitPos, 13 );
		VisibleCluster.vPage.y		= ReadBits( RawData, BitPos, 13 );
		VisibleCluster.vPageEnd.x	= ReadBits( RawData, BitPos, 3 );
		VisibleCluster.vPageEnd.y	= ReadBits( RawData, BitPos, 3 );
		VisibleCluster.vPageEnd		+= VisibleCluster.vPage;
	}
	else
	{
		VisibleCluster.vPage = 0;
	}
	return VisibleCluster;
}
FVisibleCluster GetVisibleCluster( ByteAddressBuffer VisibleClusters, uint ClusterIdx, bool bHasPageData = false )
{
	uint4 RawData;
	if( bHasPageData )
		RawData = uint4( VisibleClusters.Load3( ClusterIdx * 12 ), 0 );
	else
		RawData = uint4( VisibleClusters.Load2( ClusterIdx * 8 ), 0, 0 );
	return UnpackVisibleCluster(RawData, bHasPageData);
}
FVisibleCluster GetVisibleCluster( uint ClusterIdx, bool bHasPageData )
{
	return GetVisibleCluster( VisibleClustersSWHW, ClusterIdx, bHasPageData );
}
FVisibleCluster GetVisibleCluster( uint ClusterIndex )
{
	FVisibleCluster VisibleCluster;
	{
		VisibleCluster = GetVisibleCluster( ClusterIndex, false );
	}
	return VisibleCluster;
}
FInstanceSceneData GetInstanceSceneData( inout FVisibleCluster VisibleCluster, bool bCheckValid = true )
{
	FInstanceSceneData InstanceData = GetInstanceSceneData( VisibleCluster.InstanceId, Scene.GPUScene_InstanceDataSOAStride, bCheckValid );
	return InstanceData;
}
FInstanceDynamicData CalculateInstanceDynamicData( FNaniteView NaniteView, FInstanceSceneData InstanceData )
{
	float4x4 LocalToTranslatedWorld = DFFastToTranslatedWorld(InstanceData.LocalToWorld, NaniteView.PreViewTranslation);
	float4x4 PrevLocalToTranslatedWorld = DFFastToTranslatedWorld(InstanceData.PrevLocalToWorld, NaniteView.PrevPreViewTranslation);
	FInstanceDynamicData DynamicData;
	DynamicData.LocalToTranslatedWorld = LocalToTranslatedWorld;
	DynamicData.PrevLocalToTranslatedWorld = PrevLocalToTranslatedWorld;
	DynamicData.bHasMoved = GetGPUSceneFrameNumber() == InstanceData.LastUpdateSceneFrameNumber;
	return DynamicData;
}
FInstanceSceneData GetInstanceSceneData( uint InstanceId, bool bCheckValid = true )
{
	return GetInstanceSceneData( InstanceId, Scene.GPUScene_InstanceDataSOAStride, bCheckValid );
}
FCluster UnpackCluster(uint4 ClusterData[7])
{
	FCluster Cluster;
	Cluster.PageBaseAddress		= 0;
	Cluster.NumVerts			= BitFieldExtractU32(ClusterData[0].x, 9, 0);
	Cluster.PositionOffset		= BitFieldExtractU32(ClusterData[0].x, 23, 9);
	Cluster.NumTris				= BitFieldExtractU32(ClusterData[0].y, 8, 0);
	Cluster.IndexOffset			= BitFieldExtractU32(ClusterData[0].y, 24, 8);
	Cluster.ColorMin			= ClusterData[0].z;
	Cluster.ColorBits			= BitFieldExtractU32(ClusterData[0].w, 16, 0);
	Cluster.GroupIndex			= BitFieldExtractU32(ClusterData[0].w, 16, 16);			
	Cluster.PosStart			= ClusterData[1].xyz;
	Cluster.BitsPerIndex		= BitFieldExtractU32(ClusterData[1].w, 3, 0) + 1;
	Cluster.PosPrecision		= (int)BitFieldExtractU32(ClusterData[1].w, 6, 3) + -20;
	Cluster.PosBits.x			= BitFieldExtractU32(ClusterData[1].w, 5, 9);
	Cluster.PosBits.y			= BitFieldExtractU32(ClusterData[1].w, 5, 14);
	Cluster.PosBits.z			= BitFieldExtractU32(ClusterData[1].w, 5, 19);
	Cluster.NormalPrecision		= BitFieldExtractU32(ClusterData[1].w, 4, 24);
	Cluster.TangentPrecision	= BitFieldExtractU32(ClusterData[1].w, 4, 28);
	Cluster.LODBounds			= asfloat(ClusterData[2]);
	Cluster.BoxBoundsCenter		= asfloat(ClusterData[3].xyz);
	Cluster.LODError			= f16tof32(ClusterData[3].w);
	Cluster.EdgeLength			= f16tof32(ClusterData[3].w >> 16);
	Cluster.BoxBoundsExtent		= asfloat(ClusterData[4].xyz);
	Cluster.Flags				= ClusterData[4].w;
	Cluster.AttributeOffset		= BitFieldExtractU32(ClusterData[5].x, 22,  0);
	Cluster.BitsPerAttribute	= BitFieldExtractU32(ClusterData[5].x, 10, 22);
	Cluster.DecodeInfoOffset	= BitFieldExtractU32(ClusterData[5].y, 22,  0);
	Cluster.bHasTangents		= BitFieldExtractU32(ClusterData[5].y,  1, 22);
	Cluster.NumUVs				= BitFieldExtractU32(ClusterData[5].y,  3, 23);
	Cluster.ColorMode			= BitFieldExtractU32(ClusterData[5].y,  1, 26);
	Cluster.UVBitOffsets		= ClusterData[5].z;
	const uint MaterialEncoding = ClusterData[5].w;
	[branch]
	if (MaterialEncoding < 0xFE000000u)
	{
		Cluster.MaterialTableOffset	= 0;
		Cluster.MaterialTableLength	= 0;		
		Cluster.Material0Index		= BitFieldExtractU32(MaterialEncoding, 6, 0);
		Cluster.Material1Index		= BitFieldExtractU32(MaterialEncoding, 6, 6);
		Cluster.Material2Index		= BitFieldExtractU32(MaterialEncoding, 6, 12);
		Cluster.Material0Length		= BitFieldExtractU32(MaterialEncoding, 7, 18) + 1;
		Cluster.Material1Length		= BitFieldExtractU32(MaterialEncoding, 7, 25);
		Cluster.VertReuseBatchCountTableOffset = 0;
		Cluster.VertReuseBatchCountTableSize = 0;
		Cluster.VertReuseBatchInfo	= ClusterData[6];
	}
	else
	{
		Cluster.MaterialTableOffset = BitFieldExtractU32(MaterialEncoding, 19, 0);
		Cluster.MaterialTableLength	= BitFieldExtractU32(MaterialEncoding, 6, 19) + 1;
		Cluster.Material0Index		= 0;
		Cluster.Material1Index		= 0;
		Cluster.Material2Index		= 0;
		Cluster.Material0Length		= 0;
		Cluster.Material1Length		= 0;
		Cluster.VertReuseBatchCountTableOffset = ClusterData[6].x;
		Cluster.VertReuseBatchCountTableSize = ClusterData[6].y;
		Cluster.VertReuseBatchInfo = 0;
	}
	return Cluster;
}
uint GPUPageIndexToGPUOffset(uint PageIndex)
{
	const uint MaxStreamingPages = PageConstants.y;
	return (min(PageIndex, MaxStreamingPages) << 17) + ((uint)max((int)PageIndex - (int)MaxStreamingPages, 0) << 15);
}
FPageHeader UnpackPageHeader(uint4 Data)
{
	FPageHeader Header;
	Header.NumClusters = Data.x;
	return Header;
}
FPageHeader GetPageHeader(ByteAddressBuffer InputBuffer, uint PageAddress)
{
	return UnpackPageHeader(InputBuffer.Load4(PageAddress));
}
FPageHeader GetPageHeader(RWByteAddressBuffer InputBuffer, uint PageAddress)
{
	return UnpackPageHeader(InputBuffer.Load4(PageAddress));
}
FCluster GetCluster(ByteAddressBuffer InputBuffer, uint SrcBaseOffset, uint ClusterIndex, uint NumPageClusters)
{
	const uint ClusterSOAStride = ( NumPageClusters << 4 );
	const uint ClusterBaseAddress = SrcBaseOffset + ( ClusterIndex << 4 );
	uint4 ClusterData[7];
	[unroll]
	for(int i = 0; i < 7; i++)
	{
		ClusterData[i] = InputBuffer.Load4( ClusterBaseAddress + i * ClusterSOAStride + 16 ); 
	}
	return UnpackCluster(ClusterData);
}
FCluster GetCluster(RWByteAddressBuffer InputBuffer, uint SrcBaseOffset, uint ClusterIndex, uint NumPageClusters)
{
	const uint ClusterSOAStride = (NumPageClusters << 4);
	const uint ClusterBaseAddress = SrcBaseOffset + (ClusterIndex << 4);
	uint4 ClusterData[7];
	[unroll]
	for (int i = 0; i < 7; i++)
	{
		ClusterData[i] = InputBuffer.Load4( ClusterBaseAddress + i * ClusterSOAStride + 16 );  
	}
	return UnpackCluster(ClusterData);
}
FCluster GetCluster(uint PageIndex, uint ClusterIndex)
{
	uint PageBaseAddress = GPUPageIndexToGPUOffset(PageIndex);
	FPageHeader Header = GetPageHeader(ClusterPageData, PageBaseAddress);
	FCluster Cluster = GetCluster(ClusterPageData, PageBaseAddress, ClusterIndex, Header.NumClusters);
	Cluster.PageBaseAddress = PageBaseAddress;
	return Cluster;
}
uint3 DecodeTriangleIndices(FCluster Cluster, uint TriIndex)
{
	const uint BitsPerTriangle = Cluster.BitsPerIndex + 2 * 5;
	FBitStreamReaderState BitStreamReader = BitStreamReader_Create_Aligned(Cluster.PageBaseAddress + Cluster.IndexOffset, TriIndex * BitsPerTriangle, 8 + 2*5);
	uint BaseIndex = BitStreamReader_Read_RO(ClusterPageData, BitStreamReader, Cluster.BitsPerIndex, 8);
	uint Delta0 = BitStreamReader_Read_RO(ClusterPageData, BitStreamReader, 5, 5);
	uint Delta1 = BitStreamReader_Read_RO(ClusterPageData, BitStreamReader, 5, 5);
	return BaseIndex + uint3(0, Delta0, Delta1);
}
void UnpackVisPixel(
	uint64_t Pixel,
	out uint DepthInt,
	out uint VisibleClusterIndex, 
	out uint TriIndex
	)
{
	const uint2 Unpacked = UnpackUlongType(Pixel);
	VisibleClusterIndex = Unpacked.x >> 7;
	TriIndex = Unpacked.x & 0x7F;
	DepthInt = Unpacked.y;
	VisibleClusterIndex--;
}
void UnpackVisPixel(
	uint64_t Pixel,
	out uint DepthInt,
	out uint VisibleClusterIndex, 
	out uint TriIndex,
	out bool bIsImposter
	)
{
	const uint2 Unpacked = UnpackUlongType(Pixel);
	VisibleClusterIndex = Unpacked.x >> 7;
	TriIndex = Unpacked.x & 0x7F;
	DepthInt = Unpacked.y;
	bIsImposter = false;
	VisibleClusterIndex--;
}
float3 UnpackPosition(uint2 Packed, FCluster Cluster)
{
	int3 Pos;
	Pos.x = BitFieldExtractU32(Packed.x, Cluster.PosBits.x, 0);
	Packed.x = BitAlignU32(Packed.y, Packed.x, Cluster.PosBits.x);
	Packed.y >>= Cluster.PosBits.x;
	Pos.y = BitFieldExtractU32(Packed.x, Cluster.PosBits.y, 0);
	Packed.x = BitAlignU32(Packed.y, Packed.x, Cluster.PosBits.y);
	Pos.z = BitFieldExtractU32(Packed.x, Cluster.PosBits.z, 0);
	const float Scale = asfloat(asint(1.0f) - (Cluster.PosPrecision << 23));
	return (Pos + Cluster.PosStart) * Scale;
}
uint2 GetPackedPosition(uint VertIndex, FCluster Cluster)
{
	const uint BitsPerVertex = Cluster.PosBits.x + Cluster.PosBits.y + Cluster.PosBits.z;
	const uint BitOffset = VertIndex * BitsPerVertex;	
	uint3 Data = ClusterPageData.Load3(Cluster.PageBaseAddress + Cluster.PositionOffset + ((BitOffset >> 5) << 2));
	return uint2(BitAlignU32(Data.y, Data.x, BitOffset), BitAlignU32(Data.z, Data.y, BitOffset));
}
float3 DecodePosition(uint VertIndex, FCluster Cluster)
{
	const uint2 PackedPos = GetPackedPosition(VertIndex, Cluster);
	return UnpackPosition(PackedPos, Cluster);
}
FNaniteView UnpackNaniteView(FPackedNaniteView PackedView)
{
	const float3 ViewOriginHigh =
	{
		PackedView.ViewOriginHighX,
		PackedView.ViewOriginHighY,
		PackedView.ViewOriginHighZ
	};
	FNaniteView NaniteView;
	NaniteView.SVPositionToTranslatedWorld	= PackedView.SVPositionToTranslatedWorld;
	NaniteView.ViewToTranslatedWorld		= PackedView.ViewToTranslatedWorld;
	NaniteView.ViewOriginHigh				= ViewOriginHigh;
	NaniteView.TranslatedWorldToView		= PackedView.TranslatedWorldToView;
	NaniteView.TranslatedWorldToClip		= PackedView.TranslatedWorldToClip;
	NaniteView.ViewToClip					= PackedView.ViewToClip;
	NaniteView.ClipToWorld					= MakeDFMatrix(ViewOriginHigh, PackedView.ClipToRelativeWorld);
	NaniteView.PrevTranslatedWorldToView	= PackedView.PrevTranslatedWorldToView;
	NaniteView.PrevTranslatedWorldToClip	= PackedView.PrevTranslatedWorldToClip;
	NaniteView.PrevViewToClip				= PackedView.PrevViewToClip;
	NaniteView.PrevClipToWorld				= MakeDFMatrix(ViewOriginHigh, PackedView.PrevClipToRelativeWorld);
	NaniteView.TranslatedGlobalClipPlane	= PackedView.TranslatedGlobalClipPlane;
	NaniteView.ViewRect						= PackedView.ViewRect;
	NaniteView.ViewSizeAndInvSize			= PackedView.ViewSizeAndInvSize;
	NaniteView.ClipSpaceScaleOffset			= PackedView.ClipSpaceScaleOffset;
	NaniteView.PreViewTranslation			= MakeDFVector3(PackedView.PreViewTranslationHigh, PackedView.PreViewTranslationLow);
	NaniteView.PrevPreViewTranslation		= MakeDFVector3(PackedView.PrevPreViewTranslationHigh, PackedView.PrevPreViewTranslationLow);
	NaniteView.WorldCameraOrigin			= MakeDFVector3(ViewOriginHigh, PackedView.ViewOriginLow);
	NaniteView.CullingViewOriginTranslatedWorld = PackedView.CullingViewOriginTranslatedWorld;
	NaniteView.ViewForward					= PackedView.ViewForward;
	NaniteView.NearPlane					= PackedView.NearPlane;
	NaniteView.LODScale						= PackedView.LODScales.x;
	NaniteView.LODScaleHW					= PackedView.LODScales.y;
	NaniteView.MinBoundsRadiusSq			= PackedView.MinBoundsRadiusSq;
	NaniteView.CullingViewScreenMultiple	= PackedView.CullingViewScreenMultiple;
	NaniteView.StreamingPriorityCategory	= PackedView.StreamingPriorityCategory_AndFlags & ((1 << 2) - 1);
	NaniteView.Flags						= PackedView.StreamingPriorityCategory_AndFlags >> 2;
	NaniteView.TargetLayerIndex				= PackedView.TargetLayerIdX_AndMipLevelY_AndNumMipLevelsZ.x;
	NaniteView.TargetMipLevel				= PackedView.TargetLayerIdX_AndMipLevelY_AndNumMipLevelsZ.y;
	NaniteView.TargetNumMipLevels			= PackedView.TargetLayerIdX_AndMipLevelY_AndNumMipLevelsZ.z;
	NaniteView.TargetPrevLayerIndex			= PackedView.TargetLayerIdX_AndMipLevelY_AndNumMipLevelsZ.w;
	NaniteView.RangeBasedCullingDistance	= PackedView.RangeBasedCullingDistance;
	NaniteView.HZBTestViewRect				= PackedView.HZBTestViewRect;
	NaniteView.InstanceOcclusionQueryMask	= PackedView.InstanceOcclusionQueryMask;
	NaniteView.LightingChannelMask	= PackedView.LightingChannelMask;
	return NaniteView;
}
StructuredBuffer< FPackedNaniteView > InViews;
FNaniteView GetNaniteView( uint ViewIndex )
{
	FPackedNaniteView PackedView = InViews[ViewIndex];
	FNaniteView NaniteView = UnpackNaniteView(PackedView);
	return NaniteView;
}
template< typename T >
struct TDual
{
	T Value;
	T Value_dx;
	T Value_dy;
	TDual<T> operator+(T B)
	{
		TDual<T> R;
		R.Value = Value + B;
		R.Value_dx = Value_dx;
		R.Value_dy = Value_dy;
		return R;
	}
	TDual<T> operator-(T B)
	{
		TDual<T> R;
		R.Value = Value - B;
		R.Value_dx = Value_dx;
		R.Value_dy = Value_dy;
		return R;
	}
	TDual<T> operator*(T B)
	{
		TDual<T> R;
		R.Value = Value * B;
		R.Value_dx = Value_dx * B;
		R.Value_dy = Value_dy * B;
		return R;
	}
	TDual<T> operator+(TDual<T> B)
	{
		TDual<T> R;
		R.Value = Value + B.Value;
		R.Value_dx = Value_dx + B.Value_dx;
		R.Value_dy = Value_dy + B.Value_dy;
		return R;
	}
	TDual<T> operator-(TDual<T> B)
	{
		TDual<T> R;
		R.Value = Value - B.Value;
		R.Value_dx = Value_dx - B.Value_dx;
		R.Value_dy = Value_dy - B.Value_dy;
		return R;
	}
	TDual<T> operator*(TDual<T> B)
	{
		TDual<T> R;
		R.Value = Value * B.Value;
		R.Value_dx = Value_dx * B.Value + Value * B.Value_dx;
		R.Value_dy = Value_dy * B.Value + Value * B.Value_dy;
		return R;
	}
	TDual<T> operator/(TDual<T> B)
	{
		TDual<T> R;
		R.Value = Value / B.Value;
		T Denom = rcp(B.Value * B.Value);
		T dFdA = B.Value * Denom;
		T dFdB = -Value * Denom;
		R.Value_dx = dFdA * Value_dx + dFdB * B.Value_dx;
		R.Value_dy = dFdA * Value_dy + dFdB * B.Value_dy;
		return R;
	}
};
typedef TDual< float3 > FBarycentrics;
template< typename T >
TDual<T> Lerp( T Value0, T Value1, T Value2, FBarycentrics Barycentrics )
{
	TDual<T> Result;
	Result.Value	= Value0 * Barycentrics.Value.x    + Value1 * Barycentrics.Value.y    + Value2 * Barycentrics.Value.z;
	Result.Value_dx	= Value0 * Barycentrics.Value_dx.x + Value1 * Barycentrics.Value_dx.y + Value2 * Barycentrics.Value_dx.z;
	Result.Value_dy	= Value0 * Barycentrics.Value_dy.x + Value1 * Barycentrics.Value_dy.y + Value2 * Barycentrics.Value_dy.z;
	Result.Value =  MakePrecise( Result.Value );
	return Result;
}
FBarycentrics CalculateTriangleBarycentrics(float2 PixelClip, float4 PointClip0, float4 PointClip1, float4 PointClip2, float2 ViewInvSize)
{
	FBarycentrics Barycentrics;
	const float3 RcpW = rcp(float3(PointClip0.w, PointClip1.w, PointClip2.w));
	const float3 Pos0 = PointClip0.xyz * RcpW.x;
	const float3 Pos1 = PointClip1.xyz * RcpW.y;
	const float3 Pos2 = PointClip2.xyz * RcpW.z;
	const float3 Pos120X = float3(Pos1.x, Pos2.x, Pos0.x);
	const float3 Pos120Y = float3(Pos1.y, Pos2.y, Pos0.y);
	const float3 Pos201X = float3(Pos2.x, Pos0.x, Pos1.x);
	const float3 Pos201Y = float3(Pos2.y, Pos0.y, Pos1.y);
	const float3 C_dx = Pos201Y - Pos120Y;
	const float3 C_dy = Pos120X - Pos201X;
	const float3 C = C_dx * (PixelClip.x - Pos120X) + C_dy * (PixelClip.y - Pos120Y);	
	const float3 G = C * RcpW;
	const float H = dot(C, RcpW);
	const float RcpH = rcp(H);
	Barycentrics.Value = G * RcpH;
	const float3 G_dx = C_dx * RcpW;
	const float3 G_dy = C_dy * RcpW;
	const float H_dx = dot(C_dx, RcpW);
	const float H_dy = dot(C_dy, RcpW);
	Barycentrics.Value_dx = (G_dx * H - G * H_dx) * (RcpH * RcpH) * ( 2.0f * ViewInvSize.x);
	Barycentrics.Value_dy = (G_dy * H - G * H_dy) * (RcpH * RcpH) * (-2.0f * ViewInvSize.y);
	return Barycentrics;
}
float3 ClosestPointBarycentrics( float3 p, float3 v0, float3 v1, float3 v2 )
{
	float3 Edge01 = v1 - v0;
	float3 Edge02 = v2 - v0;
	float3 Origin0 = p - v0;
	float3 TriNormal = cross( Edge02, Edge01 );
	float3 Dirx02 = cross( TriNormal, Edge02 );
	float InvDet = 1.0 / dot( Edge01, Dirx02 );
	float3 UVW;
	UVW.y = InvDet * dot( Origin0, Dirx02 );
	UVW.z = InvDet * dot( TriNormal, cross( Origin0, Edge01 ) );
	UVW.x = 1.0 - UVW.y - UVW.z;
	return UVW;
}
FBarycentrics CalculateTriangleBarycentrics(
	float3 PositionPixel,
	float3 PositionPixelX,
	float3 PositionPixelY,
	float3 Position0,
	float3 Position1,
	float3 Position2,
	float3 Normal0,
	float3 Normal1,
	float3 Normal2 )
{
	uint NumIterations = 2;
	for( uint j = 0; j < NumIterations; j++ )
	{
		float3 UVW = ClosestPointBarycentrics( PositionPixel, Position0, Position1, Position2 );
		UVW = max( 0, UVW );
		UVW /= dot( UVW, 1 );
		float3 ClosestPoint;
		ClosestPoint  = Position0 * UVW.x;
		ClosestPoint += Position1 * UVW.y;
		ClosestPoint += Position2 * UVW.z;
		float3 ClosestNormal;
		ClosestNormal  = Normal0 * UVW.x;
		ClosestNormal += Normal1 * UVW.y;
		ClosestNormal += Normal2 * UVW.z;
		float Displace = dot( PositionPixel - ClosestPoint, ClosestNormal ) / dot( ClosestNormal, ClosestNormal );
		Position0 += Normal0 * Displace;
		Position1 += Normal1 * Displace;
		Position2 += Normal2 * Displace;
	}
	FBarycentrics Barycentrics;
	Barycentrics.Value		= ClosestPointBarycentrics( PositionPixel,  Position0, Position1, Position2 );
	Barycentrics.Value_dx	= ClosestPointBarycentrics( PositionPixelX, Position0, Position1, Position2 ) - Barycentrics.Value;
	Barycentrics.Value_dy	= ClosestPointBarycentrics( PositionPixelY, Position0, Position1, Position2 ) - Barycentrics.Value;
	return Barycentrics;
}
struct FNaniteAttributeData
{
	TDual< float4 >	VertexColor;
	TDual< float2 >	TexCoords[4];
	float3x3 TangentToWorld;
	float UnMirrored;
};
struct FNaniteRawAttributeData
{
	float4 TangentX_AndSign;
	float3 TangentZ;
	float4 Color;
	float2 TexCoords[4];
};
FNaniteRawAttributeData WaveReadLaneAt(FNaniteRawAttributeData In, uint SrcIndex)
{
	FNaniteRawAttributeData Out;
	Out.TangentX_AndSign = WaveReadLaneAt(In.TangentX_AndSign, SrcIndex);
	Out.TangentZ = WaveReadLaneAt(In.TangentZ, SrcIndex);
	Out.Color = WaveReadLaneAt(In.Color, SrcIndex);
	[unroll]
	for (uint i = 0; i < 4; ++i)
	{
		Out.TexCoords[i] = WaveReadLaneAt(In.TexCoords[i], SrcIndex);
	}
	return Out;
}
struct FUVRange
{
	uint2	Min;
	uint2	NumBits;
	uint	NumMantissaBits;
};
FUVRange UnpackUVRange(uint2 Data)
{
	FUVRange Range;
	Range.NumBits.x			= BitFieldExtractU32(Data.x, 5, 0);
	Range.Min.x				= Data.x >> 5;
	Range.NumBits.y			= BitFieldExtractU32(Data.y, 5, 0);
	Range.Min.y				= Data.y >> 5;
	Range.NumMantissaBits	= 14;	
	return Range;
}
float DecodeUVFloat(uint EncodedValue, uint NumMantissaBits)
{
	const uint ExponentAndMantissaMask	= BitFieldMaskU32(5 + NumMantissaBits, 0);
	const bool bNeg						= (EncodedValue <= ExponentAndMantissaMask);
	const uint ExponentAndMantissa		= (bNeg ? ~EncodedValue : EncodedValue) & ExponentAndMantissaMask;
	float Result	= asfloat(0x3F000000u + (ExponentAndMantissa << (23 - NumMantissaBits)));
	Result			= min(Result * 2.0f - 1.0f, Result);		
	return bNeg ? -Result : Result;
}
float2 UnpackTexCoord(uint2 Packed, FUVRange UVRange)
{
	const uint2 GlobalUV = UVRange.Min + Packed;
	return float2(	DecodeUVFloat(GlobalUV.x, UVRange.NumMantissaBits),
					DecodeUVFloat(GlobalUV.y, UVRange.NumMantissaBits));
}
float3 UnpackNormal(uint Packed, uint Bits)
{
	uint Mask = BitFieldMaskU32(Bits, 0);
	float2 F = uint2(BitFieldExtractU32(Packed, Bits, 0), BitFieldExtractU32(Packed, Bits, Bits)) * (2.0f / Mask) - 1.0f;
	float3 N = float3(F.xy, 1.0 - abs(F.x) - abs(F.y));
	float T = saturate(-N.z);
	N.xy +=  select_internal( N.xy >= 0.0 , -T , T );
	return normalize(N);
}
uint CalculateMaxAttributeBits(uint NumTexCoordInterpolators)
{
	uint Size = 0u;
	Size += 2u * 15;
	Size += 1u + 12;
	Size += 4u * 8;
	Size += NumTexCoordInterpolators * (2u * (1 + 5 + 14));
	return Size;
}
void DecodeMaterialRange(uint EncodedRange, out uint TriStart, out uint TriLength, out uint MaterialIndex)
{
	TriStart = BitFieldExtractU32(EncodedRange, 8, 0);
	TriLength = BitFieldExtractU32(EncodedRange, 8, 8);
	MaterialIndex = BitFieldExtractU32(EncodedRange, 6, 16);
}
bool IsMaterialFastPath(FCluster InCluster)
{
	return (InCluster.Material0Length > 0);
}
uint GetRelativeMaterialIndex(FCluster InCluster, uint InTriIndex)
{
	uint MaterialIndex = 0xFFFFFFFF;
	[branch]
	if (IsMaterialFastPath(InCluster))
	{
		if (InTriIndex < InCluster.Material0Length)
		{
			MaterialIndex = InCluster.Material0Index;
		}
		else if (InTriIndex < (InCluster.Material0Length + InCluster.Material1Length))
		{
			MaterialIndex = InCluster.Material1Index;
		}
		else
		{
			MaterialIndex = InCluster.Material2Index;
		}
	}
	else
	{
		uint TableOffset = InCluster.PageBaseAddress + InCluster.MaterialTableOffset * 4;
		[loop] for (uint TableEntry = 0; TableEntry < InCluster.MaterialTableLength; ++TableEntry)
		{
			uint EncodedRange = ClusterPageData.Load(TableOffset);
			TableOffset += 4;
			uint TriStart;
			uint TriLength;
			uint TriMaterialIndex;
			DecodeMaterialRange(EncodedRange, TriStart, TriLength, TriMaterialIndex);
			if (InTriIndex >= TriStart && InTriIndex < (TriStart + TriLength))
			{
				MaterialIndex = TriMaterialIndex;
				break;
			}
		}
	}
	return MaterialIndex;
}
struct FNaniteMaterialPrimitiveData
{
	uint MaterialBufferOffset;
	uint MaterialMaxIndex;
	uint MeshPassMask;
	bool bHasUVDensities;
	uint HitProxyBufferOffset;
};
FNaniteMaterialPrimitiveData UnpackNaniteMaterialPrimitiveData(uint3 Data)
{
	FNaniteMaterialPrimitiveData Output;
	Output.MaterialBufferOffset	= Data.x;
	Output.MaterialMaxIndex		= BitFieldExtractU32(Data.y, 8u,  0u);
	Output.MeshPassMask			= BitFieldExtractU32(Data.y, 8u,  8u);
	Output.bHasUVDensities		= BitFieldExtractU32(Data.y, 1u, 16u);
	Output.HitProxyBufferOffset = Data.z;
	return Output;
}
FNaniteMaterialPrimitiveData LoadNaniteMaterialPrimitiveData(uint InPrimitiveIndex)
{
	const uint ElementStride = Scene.NaniteMaterials_PrimitiveMaterialElementStride;
	const uint Offset = InPrimitiveIndex * ElementStride;
	uint3 Data = (uint3)0xFFFFFFFFu;
	if (ElementStride / 4u >= 3u)
	{
		Data = Scene_NaniteMaterials_PrimitiveMaterialData.Load3(Offset);
	}
	else
	{
		 { };
		Data.xy = Scene_NaniteMaterials_PrimitiveMaterialData.Load2(InPrimitiveIndex * 2u * 4u);
	}
	return UnpackNaniteMaterialPrimitiveData(Data);
}
float4 LoadMaterialUVDensities(uint Offset)
{
	if (Offset == 0xFFFFFFFFu)
	{
		return (float4)1.0f;
	}
	return asfloat(Scene_NaniteMaterials_MaterialData.Load4(Offset));
}
uint GetMaterialUVDensitiesOffset(uint InRelativeMaterialIndex, uint InPrimitiveIndex)
{
	FNaniteMaterialPrimitiveData PrimitiveData = LoadNaniteMaterialPrimitiveData(InPrimitiveIndex);
	 { };
	if (!PrimitiveData.bHasUVDensities)
	{
		return 0xFFFFFFFFu;
	}
	const uint DwordsPerMaterialSlot = 2u;
	const uint DwordsPerUVDensities = 4u;
	const uint MaterialCount = PrimitiveData.MaterialMaxIndex + 1;
	const uint FirstUVDensitiesOffset = MaterialCount * countbits(PrimitiveData.MeshPassMask) * DwordsPerMaterialSlot;
	InRelativeMaterialIndex = min(InRelativeMaterialIndex, PrimitiveData.MaterialMaxIndex);
	return 4 * (
		PrimitiveData.MaterialBufferOffset +
		FirstUVDensitiesOffset +
		(InRelativeMaterialIndex * DwordsPerUVDensities)
	);
}
float4 LoadMaterialUVDensities(uint InRelativeMaterialIndex, uint InPrimitiveIndex)
{
	return LoadMaterialUVDensities(GetMaterialUVDensitiesOffset(InRelativeMaterialIndex, InPrimitiveIndex));
}
float4 GetMaterialUVDensities(
	FCluster InCluster,
	uint InPrimitiveIndex,
	uint InTriIndex)
{
	const uint RelativeMaterialIndex = GetRelativeMaterialIndex(InCluster, InTriIndex);
	return LoadMaterialUVDensities(RelativeMaterialIndex, InPrimitiveIndex);
}
float3 UnpackTangentX(float3 TangentZ, uint TangentAngleBits, uint NumTangentBits)
{
	const bool bSwapXZ = (abs(TangentZ.z) > abs(TangentZ.x));
	if (bSwapXZ) TangentZ.xz = TangentZ.zx;
	const float3 TangentRefX = float3(-TangentZ.y, TangentZ.x, 0.0f);
	const float3 TangentRefY = cross(TangentZ, TangentRefX);
	const float Scale = rsqrt(dot(TangentRefX.xy, TangentRefX.xy));
	const float TangentAngle = float(TangentAngleBits) * ((2.0f * PI) / (1u << NumTangentBits));
	float3 TangentX = TangentRefX * (cos(TangentAngle) * Scale) + TangentRefY * (sin(TangentAngle) * Scale);
	if (bSwapXZ) TangentX.xz = TangentX.zx;
	return TangentX;
}
void GetRawAttributeDataN(inout FNaniteRawAttributeData RawAttributeData[3],
	FCluster Cluster,
	uint3 TriIndices,
	uint CompileTimeN,
	uint CompileTimeMaxTexCoords
)
{
	CompileTimeMaxTexCoords = max(1, min(4, CompileTimeMaxTexCoords));
	const uint DecodeInfoOffset = Cluster.PageBaseAddress + Cluster.DecodeInfoOffset;
	const uint AttributeDataOffset = Cluster.PageBaseAddress + Cluster.AttributeOffset;
	float2 TexCoords[4];
	uint i;
	[unroll]
	for (i = 0; i < CompileTimeN; i++)
	{
		RawAttributeData[i] = (FNaniteRawAttributeData)0;
		TexCoords[i] = 0.0f;
	}
	const uint CompileTimeMaxAttributeBits = CalculateMaxAttributeBits(CompileTimeMaxTexCoords);
	uint4 ColorMin = uint4(UnpackByte0(Cluster.ColorMin), UnpackByte1(Cluster.ColorMin), UnpackByte2(Cluster.ColorMin), UnpackByte3(Cluster.ColorMin));
	const uint4 NumComponentBits = UnpackToUint4(Cluster.ColorBits, 4);
	FBitStreamReaderState AttributeStream[3];
	[unroll]
	for (i = 0; i < CompileTimeN; i++)
	{
		AttributeStream[i] = BitStreamReader_Create_Aligned(AttributeDataOffset, TriIndices[i] * Cluster.BitsPerAttribute, CompileTimeMaxAttributeBits);
		const uint NormalBits = BitStreamReader_Read_RO(ClusterPageData, AttributeStream[i], 2 * Cluster.NormalPrecision, 2 * 15);
		const float3 TangentZ = UnpackNormal(NormalBits, Cluster.NormalPrecision);
		RawAttributeData[i].TangentZ = TangentZ;
		const uint NumTangentBits = Cluster.bHasTangents ? (Cluster.TangentPrecision + 1) : 0u;
		const uint TangentAngleAndSignBits = BitStreamReader_Read_RO(ClusterPageData, AttributeStream[i], NumTangentBits, 12 + 1);
		[branch]
		if (Cluster.bHasTangents)
		{
			const bool bTangentYSign = (TangentAngleAndSignBits & (1u << Cluster.TangentPrecision)) != 0;
			const uint TangentAngleBits = BitFieldExtractU32(TangentAngleAndSignBits, Cluster.TangentPrecision, 0);
			RawAttributeData[i].TangentX_AndSign = float4(UnpackTangentX(TangentZ, TangentAngleBits, Cluster.TangentPrecision), bTangentYSign ? -1.0f : 1.0f);
		}
		else
		{
			RawAttributeData[i].TangentX_AndSign = 0.0f;
		}
		const uint4 ColorDelta = BitStreamReader_Read4_RO(ClusterPageData, AttributeStream[i], NumComponentBits, 8);
		RawAttributeData[i].Color = float4(ColorMin + ColorDelta) * (1.0f / 255.0f);
	}
	[unroll]
	for (uint TexCoordIndex = 0; TexCoordIndex < CompileTimeMaxTexCoords; ++TexCoordIndex)
	{
		uint2 UVRangeData = 0u;
		if (TexCoordIndex < Cluster.NumUVs)
		{
			UVRangeData = ClusterPageData.Load2(DecodeInfoOffset + TexCoordIndex * 8);
		}
		const FUVRange UVRange = UnpackUVRange(UVRangeData);
		uint2 UVBits[3];
		[unroll]
		for (uint i = 0; i < CompileTimeN; i++)
		{
			UVBits[i] = BitStreamReader_Read2_RO(ClusterPageData, AttributeStream[i], UVRange.NumBits, (1 + 5 + 14));
		}
		[branch]
		if (TexCoordIndex < Cluster.NumUVs)
		{
			[unroll]
			for (uint i = 0; i < CompileTimeN; i++)
			{
				TexCoords[i] = UnpackTexCoord(UVBits[i], UVRange);
			}
		}
		[unroll]
		for (uint j = 0; j < CompileTimeN; j++)
		{
			RawAttributeData[j].TexCoords[TexCoordIndex] = TexCoords[j];
		}
	}
}
void GetRawAttributeData3(inout FNaniteRawAttributeData RawAttributeData[3],
	FCluster Cluster,
	uint3 VertexIndices,
	uint CompileTimeMaxTexCoords
	)
{
	GetRawAttributeDataN(RawAttributeData, Cluster, VertexIndices, 3, CompileTimeMaxTexCoords);
}
FNaniteRawAttributeData GetRawAttributeData(
	FCluster Cluster,
	uint VertexIndex,
	uint CompileTimeMaxTexCoords
	)
{
	FNaniteRawAttributeData RawAttributeData[3];
	GetRawAttributeDataN(RawAttributeData, Cluster, VertexIndex, 1, CompileTimeMaxTexCoords);
	return RawAttributeData[0];
}
float3x3 NaniteTangentToLocal(float4 TangentX_AndSign, float3 UnnormalizedTangentZ)
{
	const float3 TangentY = cross(UnnormalizedTangentZ.xyz, TangentX_AndSign.xyz) * TangentX_AndSign.w;
	return float3x3(TangentX_AndSign.xyz, TangentY, UnnormalizedTangentZ);
}
FNaniteAttributeData GetAttributeData(
	FCluster Cluster,
	float3 PointLocal0,
	float3 PointLocal1,
	float3 PointLocal2,
	FNaniteRawAttributeData RawAttributeData0,
	FNaniteRawAttributeData RawAttributeData1,
	FNaniteRawAttributeData RawAttributeData2,
	FBarycentrics Barycentrics,
	FInstanceSceneData InstanceData,
	uint CompileTimeMaxTexCoords,
	float3x3 TangentRot
)
{
	FNaniteAttributeData AttributeData = (FNaniteAttributeData)0;
	CompileTimeMaxTexCoords = max(1, min(4, CompileTimeMaxTexCoords));
	const float3 UnnormalizedTangentZ = Lerp( RawAttributeData0.TangentZ, RawAttributeData1.TangentZ, RawAttributeData2.TangentZ, Barycentrics ).Value;
	const float3 TangentZ = normalize(UnnormalizedTangentZ);
	AttributeData.UnMirrored = 1.0f;
	AttributeData.VertexColor.Value = RawAttributeData0.Color;
	if (Cluster.ColorMode == 1)
	{
		AttributeData.VertexColor = Lerp( RawAttributeData0.Color, RawAttributeData1.Color, RawAttributeData2.Color, Barycentrics );
	}
	TDual< float2 > TexCoord = (TDual< float2 >)0;
	[unroll]
	for (uint TexCoordIndex = 0; TexCoordIndex < CompileTimeMaxTexCoords; ++TexCoordIndex)
	{
		if (TexCoordIndex < Cluster.NumUVs)
		{
			TexCoord = Lerp( RawAttributeData0.TexCoords[TexCoordIndex], RawAttributeData1.TexCoords[TexCoordIndex], RawAttributeData2.TexCoords[TexCoordIndex], Barycentrics );
			if (TexCoordIndex == 0)
			{
				float3x3 TangentToLocal;
				[branch]
				if (Cluster.bHasTangents)
				{
					float4 TangentX_AndSign = Lerp( RawAttributeData0.TangentX_AndSign, RawAttributeData1.TangentX_AndSign, RawAttributeData2.TangentX_AndSign, Barycentrics ).Value;
					TangentToLocal = NaniteTangentToLocal(TangentX_AndSign, UnnormalizedTangentZ);
					AttributeData.UnMirrored = TangentX_AndSign.w;
				}
				else
				{
					float3 PointLocal10 = PointLocal1 - PointLocal0;
					float3 PointLocal20 = PointLocal2 - PointLocal0;
					float2 TexCoord10 = RawAttributeData1.TexCoords[0] - RawAttributeData0.TexCoords[0];
					float2 TexCoord20 = RawAttributeData2.TexCoords[0] - RawAttributeData0.TexCoords[0];
					bool TangentXValid = abs(TexCoord10.x) + abs(TexCoord20.x) > 1e-6;
					float3 TangentX;
					float3 TangentY;
					[branch]
					if (TangentXValid)
					{
						float3 Perp2 = cross(TangentZ, PointLocal20);
						float3 Perp1 = cross(PointLocal10, TangentZ);
						float3 TangentU = Perp2 * TexCoord10.x + Perp1 * TexCoord20.x;
						float3 TangentV = Perp2 * TexCoord10.y + Perp1 * TexCoord20.y;
						TangentX = normalize(TangentU);
						TangentY = cross(TangentZ, TangentX);
						AttributeData.UnMirrored = dot(TangentV, TangentY) < 0.0f ? -1.0f : 1.0f;
						TangentY *= AttributeData.UnMirrored;
					}
					else
					{
						const float Sign = TangentZ.z >= 0 ? 1 : -1;
						const float a = -rcp( Sign + TangentZ.z );
						const float b = TangentZ.x * TangentZ.y * a;
						TangentX = float3(1 + Sign * a * Pow2(TangentZ.x), Sign * b, -Sign * TangentZ.x);
						TangentY = float3(b,  Sign + a * Pow2(TangentZ.y), -TangentZ.y);
						AttributeData.UnMirrored = 1;
					}
					TangentToLocal = float3x3(TangentX, TangentY, TangentZ);
				}
				TangentToLocal = mul(TangentToLocal, TangentRot);
				float3x3 LocalToWorldNoScale = DFToFloat3x3(InstanceData.LocalToWorld);
				float3 InvScale = InstanceData.InvNonUniformScale;
				LocalToWorldNoScale[0] *= InvScale.x;
				LocalToWorldNoScale[1] *= InvScale.y;
				LocalToWorldNoScale[2] *= InvScale.z;
				AttributeData.TangentToWorld = mul(TangentToLocal, LocalToWorldNoScale);
			}
		}
		else
		{
			if (TexCoordIndex == 0)
			{
				AttributeData.TangentToWorld = float3x3(float3(0, 0, 0), float3(0, 0, 0), DFMultiplyVector(TangentZ * InstanceData.InvNonUniformScale.z, InstanceData.LocalToWorld));
			}
		}
		AttributeData.TexCoords[TexCoordIndex] = TexCoord;
	}
	return AttributeData;
}
FNaniteAttributeData GetAttributeData(
	FCluster Cluster,
	float3 PointLocal0,
	float3 PointLocal1,
	float3 PointLocal2,
	FNaniteRawAttributeData RawAttributeData0,
	FNaniteRawAttributeData RawAttributeData1,
	FNaniteRawAttributeData RawAttributeData2,
	FBarycentrics Barycentrics,
	FInstanceSceneData InstanceData,
	uint CompileTimeMaxTexCoords
)
{
	const float3x3 TangentRot =
	{
		1, 0, 0,
		0, 1, 0,
		0, 0, 1
	};
	return GetAttributeData(
		Cluster,
		PointLocal0,
		PointLocal1,
		PointLocal2,
		RawAttributeData0,
		RawAttributeData1,
		RawAttributeData2,
		Barycentrics,
		InstanceData,
		CompileTimeMaxTexCoords,
		TangentRot
	);
}
bool IsSinglePageVirtualShadowMap(int VirtualShadowMapId)
{
	return VirtualShadowMapId < (1024U * 8U);
}
uint CalcLog2LevelDimsPages(uint Level)
{
	return 7 - Level;	
}
uint CalcLevelOffsets(uint Level)
{
	uint NumBits = Level << 1;
	uint StartBit = (2 * 7 + 2) - NumBits;
	uint Mask = ((1u << NumBits) - 1u) << StartBit;
	return 0x55555555u & Mask;
}
struct FVirtualSMLevelOffset
{
	bool bIsSinglePageSM;
	uint LevelOffset;
};
uint CalcFullPageTableLevelOffset(uint VirtualShadowMapId, uint Level)
{
	 { };
	return (1024U * 8U) + (VirtualShadowMapId - (1024U * 8U)) * 21845 + CalcLevelOffsets(Level);
}
uint CalcPageOffsetInFullLevel(uint Level, uint2 PageAddress)
{
	return PageAddress.x + (PageAddress.y << CalcLog2LevelDimsPages(Level));
}
uint CalcPageOffset(FVirtualSMLevelOffset LevelOffset, uint Level, uint2 PageAddress)
{
	 { };
	uint Result = LevelOffset.LevelOffset;
	if (!LevelOffset.bIsSinglePageSM)
	{
		Result += CalcPageOffsetInFullLevel(Level, PageAddress);
	}
	return Result;
}
uint CalcPageOffset(uint VirtualShadowMapId, uint Level, uint2 PageAddress)
{
	if (IsSinglePageVirtualShadowMap(VirtualShadowMapId))
	{
		return VirtualShadowMapId;
	}
	return CalcFullPageTableLevelOffset(VirtualShadowMapId, Level) + CalcPageOffsetInFullLevel(Level, PageAddress);
}
struct FShadowPhysicalPage
{
	uint2 PhysicalAddress;	
	uint LODOffset;			
	bool bAnyLODValid;		
	bool bThisLODValid;		
};
FShadowPhysicalPage ShadowDecodePageTable(uint Value)
{
	FShadowPhysicalPage Result;
	Result.PhysicalAddress = uint2(Value & 0x3FF, (Value >> 10) & 0x3FF);
	Result.LODOffset = (Value >> 20) & 0x3F;
	Result.bAnyLODValid = (Value & 0x80000000) != 0;
	Result.bThisLODValid = Result.bAnyLODValid && Result.LODOffset == 0;
	return Result;
}
FShadowPhysicalPage ShadowGetPhysicalPage(uint PageOffset)
{
	return ShadowDecodePageTable(VirtualShadowMap_PageTable[PageOffset]);
}
uint GetVirtualShadowMapStaticArrayIndex()
{
	return VirtualShadowMap.StaticCachedArrayIndex;
}
RWTexture2D<uint>		OutDepthBuffer;
RWTexture2DArray<uint>	OutDepthBufferArray;
void WritePixel(
	RWTexture2D<uint64_t> OutBuffer,
	uint PixelValue,
	uint2 PixelPos,
	uint DepthInt
)
{
	InterlockedMax( OutDepthBuffer[ PixelPos ], DepthInt );
}
struct FVisBufferPixel
{
	uint2	Position;
	uint	Value;
	uint2	VisualizeValues;
	float	Depth;
	uint3	PhysicalPosition;
	bool EarlyDepthTest()
	{
		Depth = saturate( Depth );
		const uint DepthInt = asuint( Depth );
		return OutDepthBufferArray[ PhysicalPosition ] < DepthInt;
	}
	void WriteOverdraw()
	{
		InterlockedAdd(OutDepthBufferArray[uint3(PhysicalPosition.xy, 2)], VisualizeValues.y);
	}
	void Write()
	{
		Depth = saturate( Depth );
		const uint DepthInt = asuint( Depth );
		InterlockedMax( OutDepthBufferArray[ PhysicalPosition ], DepthInt );
	}
};
FVisBufferPixel CreateVisBufferPixel(
	uint2	Position,
	uint	Value,
	float	Depth
)
{
	FVisBufferPixel Pixel = (FVisBufferPixel)0;
	Pixel.Position	= Position;
	Pixel.Value		= Value;
	Pixel.Depth		= Depth;
	return Pixel;
}
FLWCScalar DFToWS(FDFScalar In) { return DFToTileOffset(In); }
FLWCScalar DFFastToWS(FDFScalar In) { return DFFastToTileOffset(In); }
FLWCVector2 DFToWS(FDFVector2 In) { return DFToTileOffset(In); }
FLWCVector2 DFFastToWS(FDFVector2 In) { return DFFastToTileOffset(In); }
FLWCVector3 DFToWS(FDFVector3 In) { return DFToTileOffset(In); }
FLWCVector3 DFFastToWS(FDFVector3 In) { return DFFastToTileOffset(In); }
FLWCVector4 DFToWS(FDFVector4 In) { return DFToTileOffset(In); }
FLWCVector4 DFFastToWS(FDFVector4 In) { return DFFastToTileOffset(In); }
FLWCMatrix DFToWS(FDFMatrix In) { return DFToTileOffset(In); }
FLWCMatrix DFFastToWS(FDFMatrix In) { return DFFastToTileOffset(In); }
FLWCInverseMatrix DFToWS(FDFInverseMatrix In) { return DFToTileOffset(In); }
FLWCInverseMatrix DFFastToWS(FDFInverseMatrix In) { return DFFastToTileOffset(In); }
float DFToWS( float In) { return In; }
float2 DFToWS( float2 In) { return In; }
float3 DFToWS( float3 In) { return In; }
float4 DFToWS( float4 In) { return In; }
float3x3 GetTangentBasis( float3 TangentZ )
{
	const float Sign = TangentZ.z >= 0 ? 1 : -1;
	const float a = -rcp( Sign + TangentZ.z );
	const float b = TangentZ.x * TangentZ.y * a;
	float3 TangentX = { 1 + Sign * a * Pow2( TangentZ.x ), Sign * b, -Sign * TangentZ.x };
	float3 TangentY = { b,  Sign + a * Pow2( TangentZ.y ), -TangentZ.y };
	return float3x3( TangentX, TangentY, TangentZ );
}
float3 TangentToWorld( float3 Vec, float3 TangentZ )
{
	return mul( Vec, GetTangentBasis( TangentZ ) );
}
float4 ProcessMaterialLinearColorTextureLookup(float4 TextureValue)
{
	return TextureValue;
}
struct FSubstrateData
{
	uint Dummy;
};
FSubstrateData GetInitialisedSubstrateData() { return (FSubstrateData)0; }
struct FMaterialParticleParameters
{
	float RelativeTime;
	float MotionBlurFade;
	float Random;
	float4 Velocity;
	float4 Color;
	float4 TranslatedWorldPositionAndSize;
	float4 PrevTranslatedWorldPositionAndSize;
	FLWCVector3 WorldPosition;
	FLWCVector3 PrevWorldPosition;
	float4 MacroUV;
	float4 DynamicParameter;
	FDFMatrix ParticleToWorld;
	FDFInverseMatrix WorldToParticle;
	float2 Size;
	float SpriteRotation;
};
struct FMaterialAttributes
{
	float3 BaseColor;
	float Metallic;
	float Specular;
	float Roughness;
	float Anisotropy;
	float3 EmissiveColor;
	float Opacity;
	float OpacityMask;
	float3 Normal;
	float3 Tangent;
	float3 WorldPositionOffset;
	float Displacement;
	float3 SubsurfaceColor;
	float ClearCoat;
	float ClearCoatRoughness;
	float AmbientOcclusion;
	float3 Refraction;
	float PixelDepthOffset;
	uint ShadingModel;
	float SurfaceThickness;
	FSubstrateData FrontMaterial;
	float2 CustomizedUV0;
	float2 CustomizedUV1;
	float2 CustomizedUV2;
	float2 CustomizedUV3;
	float2 CustomizedUV4;
	float2 CustomizedUV5;
	float2 CustomizedUV6;
	float2 CustomizedUV7;
	float3 BentNormal;
	float3 ClearCoatBottomNormal;
	float3 CustomEyeTangent;
	float3 TransmittanceColor;
};
struct FPixelMaterialInputs
{
	float3 EmissiveColor;
	float Opacity;
	float OpacityMask;
	float3 BaseColor;
	float Metallic;
	float Specular;
	float Roughness;
	float Anisotropy;
	float3 Normal;
	float3 Tangent;
	float4 Subsurface;
	float AmbientOcclusion;
	float3 Refraction;
	float PixelDepthOffset;
	uint ShadingModel;
	FSubstrateData FrontMaterial;
	float SurfaceThickness;
	float Displacement;
};
struct FMaterialLWCData
{
	FLWCVector3 AbsoluteWorldPosition;
	FLWCVector3 WorldPosition_NoOffsets;
	FLWCMatrix	LocalToWorld;
	FLWCInverseMatrix WorldToLocal;
	FLWCMatrix	PreviousLocalToWorld;
	FLWCInverseMatrix PreviousWorldToLocal;
	FLWCMatrix	InstanceToWorld;
	FLWCInverseMatrix WorldToInstance;
	FLWCMatrix	PreviousInstanceToWorld;
	FLWCVector3	ObjectWorldPosition;
	FLWCVector3	ActorWorldPosition;
	FLWCMatrix ParticleToWorld;
	FLWCInverseMatrix WorldToParticle;
	FLWCVector3 ParticleWorldPosition;
	FLWCVector3 PrevParticleWorldPosition;
	FLWCVector3 PreViewTranslation;
	FLWCVector3 PrevPreViewTranslation;
	FLWCVector3 WorldViewOrigin;
	FLWCVector3 PrevWorldViewOrigin;
	FLWCVector3 WorldCameraOrigin;
	FLWCVector3 PrevWorldCameraOrigin;
};
struct FMaterialPixelParameters
{
	float4 VertexColor;
	float3 WorldNormal;
	float3 WorldTangent;
	float3 ReflectionVector;
	float3 CameraVector;
	float3 LightVector;
	float4 SvPosition;
	float4 ScreenPosition;
	float2 ViewBufferUV;
	float4 PrevScreenPosition;
	float UnMirrored;
	float TwoSidedSign;
	float3x3 TangentToWorld;
	FDFVector3 AbsoluteWorldPosition;
	float3 WorldPosition_CamRelative;
	FDFVector3 WorldPosition_NoOffsets;
	float3 WorldPosition_NoOffsets_CamRelative;
	float3 LightingPositionOffset;
	float3 WorldPosition_DDX;
	float3 WorldPosition_DDY;
	float4 VertexColor_DDX;
	float4 VertexColor_DDY;
	float4 ScreenPosition_DDX;
	float4 ScreenPosition_DDY;
	float AOMaterialMask;
	float PerInstanceRandom;
	float4 PerInstanceParams;
	uint PrimitiveId;
	uint InstanceId;
	FMaterialParticleParameters Particle;
	uint Dummy;
	FMaterialAttributes MaterialAttributes;
	FMaterialLWCData LWCData;
};
FMaterialPixelParameters MakeInitializedMaterialPixelParameters()
{
	FMaterialPixelParameters MPP;
	MPP = (FMaterialPixelParameters)0;
	MPP.TangentToWorld = float3x3(1,0,0,0,1,0,0,0,1);
	return MPP;
}
struct FMaterialVertexParameters
{
	float3 WorldPosition;
	float3x3 TangentToWorld;
	float PerInstanceRandom;
	FDFMatrix InstanceLocalToWorld;
	FDFInverseMatrix InstanceWorldToLocal;
	float3 InstanceLocalPosition;
	float4 PerInstanceParams;
	uint InstanceId;
	uint InstanceOffset;
	FDFMatrix PrevFrameLocalToWorld;
	float3 PreSkinnedPosition;
	float3 PreSkinnedNormal;
	float4 VertexColor;
	FMaterialParticleParameters Particle;
	FMaterialAttributes MaterialAttributes;
	FSceneDataIntermediates SceneData;
	uint PrimitiveId;
	bool bEvaluateWorldPositionOffset;
	FMaterialLWCData LWCData;
};
FMaterialVertexParameters MakeInitializedMaterialVertexParameters()
{
	FMaterialVertexParameters Result = (FMaterialVertexParameters)0;
	Result.PrimitiveId = ((1u << (20u)) - 1u);
	Result.bEvaluateWorldPositionOffset = true;
	return Result;
}
FPrimitiveSceneData GetPrimitiveData(FMaterialVertexParameters Parameters)
{
	return Parameters.SceneData.Primitive;
}
FPrimitiveSceneData GetPrimitiveData(FMaterialPixelParameters Parameters)
{
	return GetPrimitiveData(Parameters.PrimitiveId);
}
FDFInverseMatrix GetWorldToInstanceDF(FMaterialVertexParameters Parameters)
{
		return Parameters.InstanceWorldToLocal;
}
FDFInverseMatrix GetWorldToInstanceDF(FMaterialPixelParameters Parameters)
{
		return GetPrimitiveData(Parameters).WorldToLocal;
}
FDFMatrix GetInstanceToWorldDF(FMaterialVertexParameters Parameters)
{
		return Parameters.InstanceLocalToWorld;
}
FDFMatrix GetPrevInstanceToWorldDF(FMaterialVertexParameters Parameters)
{
	return Parameters.PrevFrameLocalToWorld;
}
FDFMatrix GetInstanceToWorldDF(FMaterialPixelParameters Parameters)
{
		return GetPrimitiveData(Parameters).LocalToWorld;
}
FDFMatrix GetPrevInstanceToWorldDF(FMaterialPixelParameters Parameters)
{
	return GetPrimitiveData(Parameters).PreviousLocalToWorld;
}
FLWCVector3 GetWorldPosition_NoMaterialOffsets(FMaterialPixelParameters Parameters)
{
	return Parameters.LWCData.WorldPosition_NoOffsets;
}
FDFMatrix GetLocalToWorldDF(FMaterialVertexParameters Parameters)
{
	return GetPrimitiveData(Parameters).LocalToWorld;
}
FDFMatrix GetLocalToWorldDF(FMaterialPixelParameters Parameters)
{
	return GetPrimitiveData(Parameters).LocalToWorld;
}
FDFMatrix GetPrevLocalToWorldDF(FMaterialVertexParameters Parameters)
{
	return GetPrimitiveData(Parameters).PreviousLocalToWorld;
}
FDFMatrix GetPrevLocalToWorldDF(FMaterialPixelParameters Parameters)
{
	return GetPrimitiveData(Parameters).PreviousLocalToWorld;
}
FDFInverseMatrix GetWorldToLocalDF(FMaterialVertexParameters Parameters)
{
	return GetPrimitiveData(Parameters).WorldToLocal;
}
FDFInverseMatrix GetWorldToLocalDF(FMaterialPixelParameters Parameters)
{
	return GetPrimitiveData(Parameters).WorldToLocal;
}
FDFInverseMatrix GetPrevWorldToLocalDF(FMaterialVertexParameters Parameters)
{
	return GetPrimitiveData(Parameters).PreviousWorldToLocal;
}
FDFInverseMatrix GetPrevWorldToLocalDF(FMaterialPixelParameters Parameters)
{
	return GetPrimitiveData(Parameters).PreviousWorldToLocal;
}
FMaterialLWCData MakeMaterialLWCData(FMaterialVertexParameters Parameters)
{
	FMaterialLWCData Result = (FMaterialLWCData)0;
	Result.PreViewTranslation = ResolvedView.TileOffset.PreViewTranslation;
	Result.PrevPreViewTranslation = ResolvedView.TileOffset.PrevPreViewTranslation;
	Result.WorldViewOrigin = ResolvedView.TileOffset.WorldViewOrigin;
	Result.PrevWorldViewOrigin = ResolvedView.TileOffset.PrevWorldViewOrigin;
	Result.WorldCameraOrigin = ResolvedView.TileOffset.WorldCameraOrigin;
	Result.PrevWorldCameraOrigin = ResolvedView.TileOffset.PrevWorldCameraOrigin;
	Result.AbsoluteWorldPosition = LWCSubtract(Parameters.WorldPosition, Result.PreViewTranslation);
	Result.InstanceToWorld = DFToWS(GetInstanceToWorldDF(Parameters));
	Result.WorldToInstance = DFFastToWS(GetWorldToInstanceDF(Parameters));
	Result.PreviousInstanceToWorld = DFToWS(GetPrevInstanceToWorldDF(Parameters));
	Result.LocalToWorld = DFToWS(GetLocalToWorldDF(Parameters));
	Result.WorldToLocal = DFFastToWS(GetWorldToLocalDF(Parameters));
	Result.PreviousLocalToWorld = DFToWS(GetPrevLocalToWorldDF(Parameters));
	Result.PreviousWorldToLocal = DFFastToWS(GetPrevWorldToLocalDF(Parameters));
	Result.ObjectWorldPosition = GetPrimitiveData(Parameters).ObjectWorldPositionTO;
	Result.ActorWorldPosition = GetPrimitiveData(Parameters).ActorWorldPositionTO;
	Result.ParticleToWorld = DFFastToWS(Parameters.Particle.ParticleToWorld);
	Result.WorldToParticle = DFFastToWS(Parameters.Particle.WorldToParticle);
	Result.ParticleWorldPosition = LWCSubtract(Parameters.Particle.TranslatedWorldPositionAndSize.xyz, Result.PreViewTranslation);
	Result.PrevParticleWorldPosition = LWCSubtract(Parameters.Particle.PrevTranslatedWorldPositionAndSize.xyz, Result.PrevPreViewTranslation);
	return Result;
}
FMaterialLWCData MakeMaterialLWCData(FMaterialPixelParameters Parameters)
{
	FMaterialLWCData Result = (FMaterialLWCData)0;
	Result.PreViewTranslation = ResolvedView.TileOffset.PreViewTranslation;
	Result.PrevPreViewTranslation = ResolvedView.TileOffset.PrevPreViewTranslation;
	Result.WorldViewOrigin = ResolvedView.TileOffset.WorldViewOrigin;
	Result.PrevWorldViewOrigin = ResolvedView.TileOffset.PrevWorldViewOrigin;
	Result.WorldCameraOrigin = ResolvedView.TileOffset.WorldCameraOrigin;
	Result.PrevWorldCameraOrigin = ResolvedView.TileOffset.PrevWorldCameraOrigin;
	Result.AbsoluteWorldPosition = LWCSubtract(Parameters.WorldPosition_CamRelative, Result.PreViewTranslation);
	Result.WorldPosition_NoOffsets = LWCSubtract(Parameters.WorldPosition_NoOffsets_CamRelative, Result.PreViewTranslation);
	Result.InstanceToWorld = DFToWS(GetInstanceToWorldDF(Parameters));
	Result.WorldToInstance = DFFastToWS(GetWorldToInstanceDF(Parameters));
	Result.PreviousInstanceToWorld = DFToWS(GetPrevInstanceToWorldDF(Parameters));
	Result.LocalToWorld = DFToWS(GetLocalToWorldDF(Parameters));
	Result.WorldToLocal = DFFastToWS(GetWorldToLocalDF(Parameters));
	Result.PreviousLocalToWorld = DFToWS(GetPrevLocalToWorldDF(Parameters));
	Result.PreviousWorldToLocal = DFFastToWS(GetPrevWorldToLocalDF(Parameters));
	Result.ObjectWorldPosition = GetPrimitiveData(Parameters).ObjectWorldPositionTO;
	Result.ActorWorldPosition = GetPrimitiveData(Parameters).ActorWorldPositionTO;
	Result.ParticleToWorld = DFFastToWS(Parameters.Particle.ParticleToWorld);
	Result.WorldToParticle = DFFastToWS(Parameters.Particle.WorldToParticle);
	Result.ParticleWorldPosition = LWCSubtract(Parameters.Particle.TranslatedWorldPositionAndSize.xyz, Result.PreViewTranslation);
	Result.PrevParticleWorldPosition = LWCSubtract(Parameters.Particle.PrevTranslatedWorldPositionAndSize.xyz, Result.PrevPreViewTranslation);
	return Result;
}
SamplerState GetMaterialSharedSampler(SamplerState TextureSampler, SamplerState SharedSampler)
{
	return SharedSampler;
}
float3 ReflectionAboutCustomWorldNormal(FMaterialPixelParameters Parameters, float3 WorldNormal, bool bNormalizeInputNormal)
{
	if (bNormalizeInputNormal)
	{
		WorldNormal = normalize(WorldNormal);
	}
	return -Parameters.CameraVector + WorldNormal * dot(WorldNormal, Parameters.CameraVector) * 2.0;
}
float LWCApplyAddressModeWrap(FLWCScalar V)
{
	const float FracTile = frac( (( V ).Tile) * 2097152.00f);
	return FracTile + V.Offset;
}
float LWCApplyAddressModeMirror(FLWCScalar v)
{
	return LWCToFloat(v);
}
float LWCApplyAddressModeClamp(FLWCScalar v)
{
	return LWCToFloat(v);
}
float LWCApplyAddressMode(FLWCScalar v, uint AddressMode)
{
	if(AddressMode == 1u) return LWCApplyAddressModeWrap(v);
	else if(AddressMode == 2u) return LWCApplyAddressModeMirror(v);
	else return LWCApplyAddressModeClamp(v);
}
float2 LWCApplyAddressMode(FLWCVector2 UV, uint AddressX, uint AddressY)
{
	return float2(LWCApplyAddressMode( LWCGetComponent( UV , 0), AddressX), LWCApplyAddressMode( LWCGetComponent( UV , 1), AddressY));
}
float3 LWCApplyAddressMode(FLWCVector3 UV, uint AddressX, uint AddressY, uint AddressZ)
{
	return float3(LWCApplyAddressMode( LWCGetComponent( UV , 0), AddressX), LWCApplyAddressMode( LWCGetComponent( UV , 1), AddressY), LWCApplyAddressMode( LWCGetComponent( UV , 2), AddressZ));
}
FLWCVector2Deriv ConstructFWSVector2Deriv(FLWCVector2 InValue,float2 InDdx,float2 InDdy)
{
	FLWCVector2Deriv Ret;
	Ret.Value = InValue;
	Ret.Ddx = InDdx;
	Ret.Ddy = InDdy;
	return Ret;
}
FLWCVector3Deriv ConstructFWSVector3Deriv(FLWCVector3 InValue,float3 InDdx,float3 InDdy)
{
	FLWCVector3Deriv Ret;
	Ret.Value = InValue;
	Ret.Ddx = InDdx;
	Ret.Ddy = InDdy;
	return Ret;
}
FloatDeriv3 ConstructConstantFloatDeriv3(float3 Value)
{
	FloatDeriv3 Ret;
	Ret.Value = Value;
	Ret.Ddx = 0;
	Ret.Ddy = 0;
	return Ret;
}
FLWCVector3Deriv MulDerivLWC(FLWCVector3Deriv A, FloatDeriv3 B)
{
	FLWCVector3Deriv Ret;
	Ret.Value = LWCMultiply(A.Value, B.Value);
	Ret.Ddx = A.Ddx * LWCToFloat(B.Value) + LWCToFloat(A.Value) * B.Ddx;
	Ret.Ddy = A.Ddy * LWCToFloat(B.Value) + LWCToFloat(A.Value) * B.Ddy;
	return Ret;
}
float3 CustomExpression0(FMaterialPixelParameters Parameters)
{
return float3 N = normalize(VertexNormalWS);
float slope  = saturate(1 - N.z);   
float slopeMask = pow(slope, 1.5);  
}
float3 GetMaterialNormalRaw(FPixelMaterialInputs PixelMaterialInputs)
{
	return PixelMaterialInputs.Normal;
}
float3 GetMaterialNormal(FMaterialPixelParameters Parameters, FPixelMaterialInputs PixelMaterialInputs)
{
	float3 RetNormal;
	RetNormal = GetMaterialNormalRaw(PixelMaterialInputs);
	{
		float3 OverrideNormal = ResolvedView.NormalOverrideParameter.xyz;
		RetNormal = RetNormal * ResolvedView.NormalOverrideParameter.w + OverrideNormal;
	}
	return RetNormal;
}
float GetMaterialDisplacement(FPixelMaterialInputs PixelMaterialInputs)
{
	return saturate(PixelMaterialInputs.Displacement);
}
bool ShouldEnableWorldPositionOffset(FMaterialVertexParameters Parameters)
{
	return false;
}
float3 ClampWorldPositionOffset(FMaterialVertexParameters Parameters, float3 InOffset)
{
	const float MaxWPODim = GetPrimitiveData(Parameters).MaxWPOExtent;
	return MaxWPODim <= 0.0f ? InOffset : clamp(InOffset, -MaxWPODim.xxx, MaxWPODim.xxx);
}
float3 GetMaterialWorldPositionOffsetRaw(FMaterialVertexParameters Parameters)
{
	return float3(0.00000000,0.00000000,0.00000000);;
}
float3 GetMaterialWorldPositionOffset(FMaterialVertexParameters Parameters)
{
	[branch]
	if (ShouldEnableWorldPositionOffset(Parameters))
	{
		return ClampWorldPositionOffset(Parameters, GetMaterialWorldPositionOffsetRaw(Parameters));
	}
	return float3(0, 0, 0);
}
float3 TransformTangentNormalToWorld(float3x3 TangentToWorld, float3 TangentNormal)
{
	return normalize(float3(TransformTangentVectorToWorld(TangentToWorld, TangentNormal)));
}
void CalcPixelMaterialInputs(in out FMaterialPixelParameters Parameters, in out FPixelMaterialInputs PixelMaterialInputs)
{
	float3 Local0 = normalize(Parameters.TangentToWorld[2]);
	float3 Local1 = cross(Local0,normalize(float3(0.00000000,1.00000000,0.00000000).rgb));
	float Local2 = dot(Local1,Local1);
	float3 Local3 = normalize(Local1);
	float4 Local4 =  select_internal( (abs(Local2 - 0.00000100) > 0.00001000) ,  select_internal( (Local2 >= 0.00000100) , float4(Local3,0.00000000) , float4(float3(0.00000000,0.00000000,0.00000000),1.00000000) ) , float4(float3(0.00000000,0.00000000,0.00000000),1.00000000) );
	FLWCVector3 Local5 = GetWorldPosition_NoMaterialOffsets(Parameters);
	FLWCVector3 Local6 = MakeLWCVector( LWCGetComponent(   Local5  , 0),  LWCGetComponent(   Local5  , 1),  LWCGetComponent(   Local5  , 2));
	FLWCVector3 Local7 = LWCMultiply(  Local6 , Material.PreshaderBuffer[0].xyz);
	FLWCVector2 Local8 = MakeLWCVector( LWCGetComponent(   Local7  , 0),  LWCGetComponent(   Local7  , 1));
	float2 Local9 = LWCApplyAddressMode(  Local8 , 1u, 1u);
	float Local10 =  1.0f;
	float4 Local11 = UnpackNormalMap(Texture2DSample(Material_Texture2D_0,GetMaterialSharedSampler(Material_Texture2D_0Sampler,View_MaterialTextureBilinearWrapedSampler),Local9));
	float Local12 =  1.0f;
	float Local13 = dot(Parameters.TangentToWorld[2],float3(0.00000000,0.00000000,1.00000000).rgb);
	float Local14 =  select_internal( (Local13 >= 0.00000000) , 1.00000000 , -1.00000000 );
	float3 Local15 = (Local11.rgb * float3(float2(Local14,-1.00000000),1.00000000));
	float3 Local16 = (Local4.rgb * ((float3)Local15.r));
	float3 Local17 = cross(Local1,Local0);
	float Local18 = dot(Local17,Local17);
	float3 Local19 = normalize(Local17);
	float4 Local20 =  select_internal( (abs(Local18 - 0.00000100) > 0.00001000) ,  select_internal( (Local18 >= 0.00000100) , float4(Local19,0.00000000) , float4(float3(0.00000000,0.00000000,0.00000000),1.00000000) ) , float4(float3(0.00000000,0.00000000,0.00000000),1.00000000) );
	float3 Local21 = (Local20.rgb * ((float3)Local15.g));
	float3 Local22 = (Local16 + Local21);
	float3 Local23 = (Local0 * ((float3)Local15.b));
	float3 Local24 = (Local23 + float3(0.00000000,0.00000000,0.00000000));
	float3 Local25 = (Local22 + Local24);
	float3 Local26 = mul((float3x3)(Parameters.TangentToWorld), Local25);
	float3 Local27 = lerp(((float3)Local26.x),float3(0.00000000,0.00000000,1.00000000).rgb,Material.PreshaderBuffer[0].w);
	float3 Local28 = lerp(Local27,float3(float2(0.00000000,0.00000000),1.00000000),Material.PreshaderBuffer[1].x);
	FLWCVector3 Local29 = LWCMultiply(  Local6 , Material.PreshaderBuffer[1].yzw);
	FLWCVector2 Local30 = MakeLWCVector( LWCGetComponent(   Local29  , 0),  LWCGetComponent(   Local29  , 1));
	float2 Local31 = LWCApplyAddressMode(  Local30 , 1u, 1u);
	float Local32 =  1.0f;
	float4 Local33 = UnpackNormalMap(Texture2DSample(Material_Texture2D_1,GetMaterialSharedSampler(Material_Texture2D_1Sampler,View_MaterialTextureBilinearWrapedSampler),Local31));
	float Local34 =  1.0f;
	float3 Local35 = (Local33.rgb * float3(float2(Local14,-1.00000000),1.00000000));
	float3 Local36 = (Local4.rgb * ((float3)Local35.r));
	float3 Local37 = (Local20.rgb * ((float3)Local35.g));
	float3 Local38 = (Local36 + Local37);
	float3 Local39 = (Local0 * ((float3)Local35.b));
	float3 Local40 = (Local39 + float3(0.00000000,0.00000000,0.00000000));
	float3 Local41 = (Local38 + Local40);
	float3 Local42 = mul((float3x3)(Parameters.TangentToWorld), Local41);
	float3 Local43 = lerp(((float3)Local42.x),float3(0.00000000,0.00000000,1.00000000).rgb,Material.PreshaderBuffer[0].w);
	float3 Local44 = lerp(Local43,float3(float2(0.00000000,0.00000000),1.00000000),Material.PreshaderBuffer[1].x);
	FLWCVector3 Local45 = LWCMultiply(  Local6 , Material.PreshaderBuffer[2].xyz);
	FLWCVector2 Local46 = MakeLWCVector( LWCGetComponent(   Local45  , 0),  LWCGetComponent(   Local45  , 1));
	float2 Local47 = LWCApplyAddressMode(  Local46 , 1u, 1u);
	float Local48 =  1.0f;
	float4 Local49 = UnpackNormalMap(Texture2DSample(Material_Texture2D_2,GetMaterialSharedSampler(Material_Texture2D_2Sampler,View_MaterialTextureBilinearWrapedSampler),Local47));
	float Local50 =  1.0f;
	float3 Local51 = (Local49.rgb * float3(float2(Local14,-1.00000000),1.00000000));
	float3 Local52 = (Local4.rgb * ((float3)Local51.r));
	float3 Local53 = (Local20.rgb * ((float3)Local51.g));
	float3 Local54 = (Local52 + Local53);
	float3 Local55 = (Local0 * ((float3)Local51.b));
	float3 Local56 = (Local55 + float3(0.00000000,0.00000000,0.00000000));
	float3 Local57 = (Local54 + Local56);
	float3 Local58 = mul((float3x3)(Parameters.TangentToWorld), Local57);
	float3 Local59 = lerp(((float3)Local58.x),float3(0.00000000,0.00000000,1.00000000).rgb,Material.PreshaderBuffer[0].w);
	float3 Local60 = lerp(Local59,float3(float2(0.00000000,0.00000000),1.00000000),Material.PreshaderBuffer[1].x);
	float Local61 =  1.0f;
	float4 Local62 = ProcessMaterialLinearColorTextureLookup(Texture2DSample(Material_Texture2D_3,GetMaterialSharedSampler(Material_Texture2D_3Sampler,View_MaterialTextureBilinearWrapedSampler),Local31));
	float Local63 =  1.0f;
	float Local64 = PositiveClampedPow(Local62.rgb.x,Material.PreshaderBuffer[2].w);
	float Local65 = (Local64 + Material.PreshaderBuffer[3].x);
	FLWCVector3 Local66 = LWCMultiply(  Local6 , Material.PreshaderBuffer[3].yzw);
	FLWCVector2 Local67 = MakeLWCVector( LWCGetComponent(   Local66  , 0),  LWCGetComponent(   Local66  , 1));
	float2 Local68 = LWCApplyAddressMode(  Local67 , 1u, 1u);
	float Local69 =  1.0f;
	float4 Local70 = ProcessMaterialLinearColorTextureLookup(Texture2DSample(Material_Texture2D_4,GetMaterialSharedSampler(Material_Texture2D_4Sampler,View_MaterialTextureBilinearWrapedSampler),Local68));
	float Local71 =  1.0f;
	float Local72 = PositiveClampedPow(Local70.rgb.x,Material.PreshaderBuffer[2].w);
	float Local73 = (Local72 + Material.PreshaderBuffer[3].x);
	float3 Local74 = CustomExpression0(Parameters);
	float Local75 = (1.00000000 - Local74.g);
	float Local76 = (Local73 + Local75);
	float Local77 = (Local76 + 1.00000000);
	float Local78 = (2.00000000 * Local74.g);
	float Local79 = (Local78 + Local65);
	float Local80 = (Local77 - Local79);
	float Local81 = saturate(Local80);
	float Local82 = lerp(Material.PreshaderBuffer[4].y,Material.PreshaderBuffer[4].x,Local81);
	float Local83 = saturate(Local82);
	float Local84 = lerp(Local65,Local73,Local83.r.r);
	float Local85 = (Local84 + (1.00000000 - 0.00000000));
	float Local86 = (Local85 + 1.00000000);
	float Local87 =  1.0f;
	float4 Local88 = ProcessMaterialLinearColorTextureLookup(Texture2DSample(Material_Texture2D_5,GetMaterialSharedSampler(Material_Texture2D_5Sampler,View_MaterialTextureBilinearWrapedSampler),Local47));
	float Local89 =  1.0f;
	float Local90 = PositiveClampedPow(Local88.rgb.x,Material.PreshaderBuffer[2].w);
	float Local91 = (Local90 + Material.PreshaderBuffer[3].x);
	float Local92 = (0.00000000 + Local91);
	float Local93 = (Local86 - Local92);
	float Local94 = saturate(Local93);
	float Local95 = lerp(Material.PreshaderBuffer[4].w,Material.PreshaderBuffer[4].z,Local94);
	float Local96 = saturate(Local95);
	float3 Local97 = lerp(Local60,((float3)0.00000000),Local96.r.r);
	float Local98 = lerp(Local91,Local84,Local96.r.r);
	float Local99 = (Local98 + (1.00000000 - 0.00000000));
	float Local100 = (Local99 + 1.00000000);
	float Local101 = (0.00000000 + Local65);
	float Local102 = (Local100 - Local101);
	float Local103 = saturate(Local102);
	float Local104 = lerp(Material.PreshaderBuffer[5].y,Material.PreshaderBuffer[5].x,Local103);
	float Local105 = saturate(Local104);
	float3 Local106 = lerp(Local44,Local97,Local105.r.r);
	float Local107 = lerp(Local65,Local98,Local105.r.r);
	float Local108 = (Local107 + (1.00000000 - 0.00000000));
	float Local109 = (Local108 + 1.00000000);
	float Local110 =  1.0f;
	float4 Local111 = ProcessMaterialLinearColorTextureLookup(Texture2DSample(Material_Texture2D_6,GetMaterialSharedSampler(Material_Texture2D_6Sampler,View_MaterialTextureBilinearWrapedSampler),Local9));
	float Local112 =  1.0f;
	float Local113 = PositiveClampedPow(Local111.rgb.x,Material.PreshaderBuffer[2].w);
	float Local114 = (Local113 + Material.PreshaderBuffer[3].x);
	float Local115 = (0.00000000 + Local114);
	float Local116 = (Local109 - Local115);
	float Local117 = saturate(Local116);
	float Local118 = lerp(Material.PreshaderBuffer[5].w,Material.PreshaderBuffer[5].z,Local117);
	float Local119 = saturate(Local118);
	float3 Local120 = lerp(Local28,Local106,Local119.r.r);
	PixelMaterialInputs.Normal = Local120;
	float3 MaterialNormal = GetMaterialNormal(Parameters, PixelMaterialInputs);
	MaterialNormal = normalize(MaterialNormal);
	Parameters.WorldNormal = TransformTangentNormalToWorld(Parameters.TangentToWorld, MaterialNormal);
	Parameters.WorldNormal *= Parameters.TwoSidedSign;
	Parameters.ReflectionVector = ReflectionAboutCustomWorldNormal(Parameters, Parameters.WorldNormal, false);
	Parameters.Particle.MotionBlurFade = 1.0f;
	float3 Local121 = lerp(float3(0.00000000,0.00000000,0.00000000),Material.PreshaderBuffer[6].yzw,Material.PreshaderBuffer[6].x);
	float4 Local122 = ProcessMaterialLinearColorTextureLookup(Texture2DSample(Material_Texture2D_7,GetMaterialSharedSampler(Material_Texture2D_7Sampler,View_MaterialTextureBilinearWrapedSampler),Local9));
	float Local123 =  1.0f;
	float Local124 = (Local122.rgb.x * Material.PreshaderBuffer[7].x);
	float3 Local125 = lerp(((float3)Local124),Material.PreshaderBuffer[8].xyz,Material.PreshaderBuffer[7].y);
	float Local126 = lerp(Material.PreshaderBuffer[9].x,Material.PreshaderBuffer[8].w,Local125.x);
	float Local127 = saturate(Local126);
	float Local128 = dot(((float3)Local127.r),float3(0.30000001,0.58999997,0.11000000));
	float3 Local129 = lerp(((float3)Local127.r),((float3)Local128),Material.PreshaderBuffer[9].y);
	float4 Local130 = ProcessMaterialLinearColorTextureLookup(Texture2DSample(Material_Texture2D_8,GetMaterialSharedSampler(Material_Texture2D_8Sampler,View_MaterialTextureBilinearWrapedSampler),Local31));
	float Local131 =  1.0f;
	float Local132 = (Local130.rgb.x * Material.PreshaderBuffer[7].x);
	float3 Local133 = lerp(((float3)Local132),Material.PreshaderBuffer[8].xyz,Material.PreshaderBuffer[7].y);
	float Local134 = lerp(Material.PreshaderBuffer[9].x,Material.PreshaderBuffer[8].w,Local133.x);
	float Local135 = saturate(Local134);
	float Local136 = dot(((float3)Local135.r),float3(0.30000001,0.58999997,0.11000000));
	float3 Local137 = lerp(((float3)Local135.r),((float3)Local136),Material.PreshaderBuffer[9].y);
	float4 Local138 = ProcessMaterialLinearColorTextureLookup(Texture2DSample(Material_Texture2D_9,GetMaterialSharedSampler(Material_Texture2D_9Sampler,View_MaterialTextureBilinearWrapedSampler),Local47));
	float Local139 =  1.0f;
	float Local140 = (Local138.rgb.x * Material.PreshaderBuffer[7].x);
	float3 Local141 = lerp(((float3)Local140),Material.PreshaderBuffer[8].xyz,Material.PreshaderBuffer[7].y);
	float Local142 = lerp(Material.PreshaderBuffer[9].x,Material.PreshaderBuffer[8].w,Local141.x);
	float Local143 = saturate(Local142);
	float Local144 = dot(((float3)Local143.r),float3(0.30000001,0.58999997,0.11000000));
	float3 Local145 = lerp(((float3)Local143.r),((float3)Local144),Material.PreshaderBuffer[9].y);
	float3 Local146 = lerp(Local145,((float3)0.00000000),Local96.r.r);
	float3 Local147 = lerp(Local137,Local146,Local105.r.r);
	float3 Local148 = lerp(Local129,Local147,Local119.r.r);
	float4 Local149 = ProcessMaterialLinearColorTextureLookup(Texture2DSample(Material_Texture2D_10,GetMaterialSharedSampler(Material_Texture2D_10Sampler,View_MaterialTextureBilinearWrapedSampler),Local9));
	float Local150 =  1.0f;
	float Local151 = (Local149.rgb.r + Material.PreshaderBuffer[9].z);
	float Local152 = (Local149.rgb.g + Material.PreshaderBuffer[9].w);
	float Local153 = (Local149.rgb.b + Material.PreshaderBuffer[10].x);
	float4 Local154 = ProcessMaterialLinearColorTextureLookup(Texture2DSample(Material_Texture2D_11,GetMaterialSharedSampler(Material_Texture2D_11Sampler,View_MaterialTextureBilinearWrapedSampler),Local31));
	float Local155 =  1.0f;
	float Local156 = (Local154.rgb.r + Material.PreshaderBuffer[9].z);
	float Local157 = (Local154.rgb.g + Material.PreshaderBuffer[9].w);
	float Local158 = (Local154.rgb.b + Material.PreshaderBuffer[10].x);
	float4 Local159 = ProcessMaterialLinearColorTextureLookup(Texture2DSample(Material_Texture2D_12,GetMaterialSharedSampler(Material_Texture2D_12Sampler,View_MaterialTextureBilinearWrapedSampler),Local47));
	float Local160 =  1.0f;
	float Local161 = (Local159.rgb.r + Material.PreshaderBuffer[9].z);
	float Local162 = (Local159.rgb.g + Material.PreshaderBuffer[9].w);
	float Local163 = (Local159.rgb.b + Material.PreshaderBuffer[10].x);
	float Local164 = lerp((0.00000000 - 0.00000000),(0.00000000 + 1.00000000),Local94);
	float Local165 = saturate(Local164);
	float3 Local166 = lerp(float3(float2(Local161,Local162),Local163),((float3)0.00000000),Local165.r.r);
	float Local167 = lerp(Local91,Local84,Local165.r.r);
	float Local168 = (Local167 + (1.00000000 - 0.00000000));
	float Local169 = (Local168 + 1.00000000);
	float Local170 = (Local169 - Local101);
	float Local171 = saturate(Local170);
	float Local172 = lerp(Material.PreshaderBuffer[5].y,Material.PreshaderBuffer[5].x,Local171);
	float Local173 = saturate(Local172);
	float3 Local174 = lerp(float3(float2(Local156,Local157),Local158),Local166,Local173.r.r);
	float Local175 = lerp(Local65,Local167,Local173.r.r);
	float Local176 = (Local175 + (1.00000000 - 0.00000000));
	float Local177 = (Local176 + 1.00000000);
	float Local178 = (Local177 - Local115);
	float Local179 = saturate(Local178);
	float Local180 = lerp(Material.PreshaderBuffer[5].w,Material.PreshaderBuffer[5].z,Local179);
	float Local181 = saturate(Local180);
	float3 Local182 = lerp(float3(float2(Local151,Local152),Local153),Local174,Local181.r.r);
	float Local183 = lerp(Local91,0.00000000,Local96.r.r);
	float Local184 = lerp(Local65,Local183,Local105.r.r);
	float Local185 = lerp(Local114,Local184,Local119.r.r);
	PixelMaterialInputs.EmissiveColor = Local121;
	PixelMaterialInputs.Opacity = 1.00000000;
	PixelMaterialInputs.OpacityMask = 1.00000000;
	PixelMaterialInputs.BaseColor = Local148;
	PixelMaterialInputs.Metallic = Local182.b;
	PixelMaterialInputs.Specular = 0.50000000;
	PixelMaterialInputs.Roughness = Local182.g;
	PixelMaterialInputs.Anisotropy = 0.00000000;
	PixelMaterialInputs.Normal = Local120;
	PixelMaterialInputs.Tangent = float3(1.00000000,0.00000000,0.00000000);
	PixelMaterialInputs.Subsurface = 0;
	PixelMaterialInputs.AmbientOcclusion = Local182.r;
	PixelMaterialInputs.Refraction = 0;
	PixelMaterialInputs.PixelDepthOffset = 0.00000000;
	PixelMaterialInputs.ShadingModel = 1;
	PixelMaterialInputs.FrontMaterial = GetInitialisedSubstrateData();
	PixelMaterialInputs.SurfaceThickness = 0.01000000;
	PixelMaterialInputs.Displacement = Local185;
	Parameters.WorldTangent = 0;
}
void CalcPixelMaterialInputsAnalyticDerivatives(in out FMaterialPixelParameters Parameters, in out FPixelMaterialInputs PixelMaterialInputs)
{
	float3 Local0 = normalize(Parameters.TangentToWorld[2]);
	float3 Local1 = cross(Local0,normalize(float3(0.00000000,1.00000000,0.00000000).rgb));
	float Local2 = dot(Local1,Local1);
	float3 Local3 = normalize(Local1);
	float4 Local4 =  select_internal( (abs(Local2 - 0.00000100) > 0.00001000) ,  select_internal( (Local2 >= 0.00000100) , float4(Local3,0.00000000) , float4(float3(0.00000000,0.00000000,0.00000000),1.00000000) ) , float4(float3(0.00000000,0.00000000,0.00000000),1.00000000) );
	FLWCVector3Deriv Local5 = ConstructFWSVector3Deriv(GetWorldPosition_NoMaterialOffsets(Parameters),Parameters.WorldPosition_DDX,Parameters.WorldPosition_DDY);
	FLWCVector3Deriv Local6 = ConstructFWSVector3Deriv(MakeLWCVector( LWCGetComponent( Local5.Value , 0),  LWCGetComponent( Local5.Value , 1),  LWCGetComponent( Local5.Value , 2)),Local5.Ddx.rgb,Local5.Ddy.rgb);
	FLWCVector3Deriv Local7 = MulDerivLWC(Local6,ConstructConstantFloatDeriv3(Material.PreshaderBuffer[0].xyz));
	FLWCVector2Deriv Local8 = ConstructFWSVector2Deriv(MakeLWCVector( LWCGetComponent( Local7.Value , 0),  LWCGetComponent( Local7.Value , 1)),Local7.Ddx.rg,Local7.Ddy.rg);
	float2 Local9 = LWCApplyAddressMode(  Local8 .Value, 1u, 1u);
	float Local10 =  1.0f;
	float4 Local11 = UnpackNormalMap(Texture2DSampleGrad(Material_Texture2D_0,GetMaterialSharedSampler(Material_Texture2D_0Sampler,View_MaterialTextureBilinearWrapedSampler),Local9,Local8.Ddx,Local8.Ddy));
	float Local12 =  1.0f;
	float Local13 = dot(Parameters.TangentToWorld[2],float3(0.00000000,0.00000000,1.00000000).rgb);
	float Local14 =  select_internal( (Local13 >= 0.00000000) , 1.00000000 , -1.00000000 );
	float3 Local15 = (Local11.rgb * float3(float2(Local14,-1.00000000),1.00000000));
	float3 Local16 = (Local4.rgb * ((float3)Local15.r));
	float3 Local17 = cross(Local1,Local0);
	float Local18 = dot(Local17,Local17);
	float3 Local19 = normalize(Local17);
	float4 Local20 =  select_internal( (abs(Local18 - 0.00000100) > 0.00001000) ,  select_internal( (Local18 >= 0.00000100) , float4(Local19,0.00000000) , float4(float3(0.00000000,0.00000000,0.00000000),1.00000000) ) , float4(float3(0.00000000,0.00000000,0.00000000),1.00000000) );
	float3 Local21 = (Local20.rgb * ((float3)Local15.g));
	float3 Local22 = (Local16 + Local21);
	float3 Local23 = (Local0 * ((float3)Local15.b));
	float3 Local24 = (Local23 + float3(0.00000000,0.00000000,0.00000000));
	float3 Local25 = (Local22 + Local24);
	float3 Local26 = mul((float3x3)(Parameters.TangentToWorld), Local25);
	float3 Local27 = lerp(((float3)Local26.x),float3(0.00000000,0.00000000,1.00000000).rgb,Material.PreshaderBuffer[0].w);
	float3 Local28 = lerp(Local27,float3(float2(0.00000000,0.00000000),1.00000000),Material.PreshaderBuffer[1].x);
	FLWCVector3Deriv Local29 = MulDerivLWC(Local6,ConstructConstantFloatDeriv3(Material.PreshaderBuffer[1].yzw));
	FLWCVector2Deriv Local30 = ConstructFWSVector2Deriv(MakeLWCVector( LWCGetComponent( Local29.Value , 0),  LWCGetComponent( Local29.Value , 1)),Local29.Ddx.rg,Local29.Ddy.rg);
	float2 Local31 = LWCApplyAddressMode(  Local30 .Value, 1u, 1u);
	float Local32 =  1.0f;
	float4 Local33 = UnpackNormalMap(Texture2DSampleGrad(Material_Texture2D_1,GetMaterialSharedSampler(Material_Texture2D_1Sampler,View_MaterialTextureBilinearWrapedSampler),Local31,Local30.Ddx,Local30.Ddy));
	float Local34 =  1.0f;
	float3 Local35 = (Local33.rgb * float3(float2(Local14,-1.00000000),1.00000000));
	float3 Local36 = (Local4.rgb * ((float3)Local35.r));
	float3 Local37 = (Local20.rgb * ((float3)Local35.g));
	float3 Local38 = (Local36 + Local37);
	float3 Local39 = (Local0 * ((float3)Local35.b));
	float3 Local40 = (Local39 + float3(0.00000000,0.00000000,0.00000000));
	float3 Local41 = (Local38 + Local40);
	float3 Local42 = mul((float3x3)(Parameters.TangentToWorld), Local41);
	float3 Local43 = lerp(((float3)Local42.x),float3(0.00000000,0.00000000,1.00000000).rgb,Material.PreshaderBuffer[0].w);
	float3 Local44 = lerp(Local43,float3(float2(0.00000000,0.00000000),1.00000000),Material.PreshaderBuffer[1].x);
	FLWCVector3Deriv Local45 = MulDerivLWC(Local6,ConstructConstantFloatDeriv3(Material.PreshaderBuffer[2].xyz));
	FLWCVector2Deriv Local46 = ConstructFWSVector2Deriv(MakeLWCVector( LWCGetComponent( Local45.Value , 0),  LWCGetComponent( Local45.Value , 1)),Local45.Ddx.rg,Local45.Ddy.rg);
	float2 Local47 = LWCApplyAddressMode(  Local46 .Value, 1u, 1u);
	float Local48 =  1.0f;
	float4 Local49 = UnpackNormalMap(Texture2DSampleGrad(Material_Texture2D_2,GetMaterialSharedSampler(Material_Texture2D_2Sampler,View_MaterialTextureBilinearWrapedSampler),Local47,Local46.Ddx,Local46.Ddy));
	float Local50 =  1.0f;
	float3 Local51 = (Local49.rgb * float3(float2(Local14,-1.00000000),1.00000000));
	float3 Local52 = (Local4.rgb * ((float3)Local51.r));
	float3 Local53 = (Local20.rgb * ((float3)Local51.g));
	float3 Local54 = (Local52 + Local53);
	float3 Local55 = (Local0 * ((float3)Local51.b));
	float3 Local56 = (Local55 + float3(0.00000000,0.00000000,0.00000000));
	float3 Local57 = (Local54 + Local56);
	float3 Local58 = mul((float3x3)(Parameters.TangentToWorld), Local57);
	float3 Local59 = lerp(((float3)Local58.x),float3(0.00000000,0.00000000,1.00000000).rgb,Material.PreshaderBuffer[0].w);
	float3 Local60 = lerp(Local59,float3(float2(0.00000000,0.00000000),1.00000000),Material.PreshaderBuffer[1].x);
	float Local61 =  1.0f;
	float4 Local62 = ProcessMaterialLinearColorTextureLookup(Texture2DSampleGrad(Material_Texture2D_3,GetMaterialSharedSampler(Material_Texture2D_3Sampler,View_MaterialTextureBilinearWrapedSampler),Local31,Local30.Ddx,Local30.Ddy));
	float Local63 =  1.0f;
	float Local64 = PositiveClampedPow(Local62.rgb.x,Material.PreshaderBuffer[2].w);
	float Local65 = (Local64 + Material.PreshaderBuffer[3].x);
	FLWCVector3Deriv Local66 = MulDerivLWC(Local6,ConstructConstantFloatDeriv3(Material.PreshaderBuffer[3].yzw));
	FLWCVector2Deriv Local67 = ConstructFWSVector2Deriv(MakeLWCVector( LWCGetComponent( Local66.Value , 0),  LWCGetComponent( Local66.Value , 1)),Local66.Ddx.rg,Local66.Ddy.rg);
	float2 Local68 = LWCApplyAddressMode(  Local67 .Value, 1u, 1u);
	float Local69 =  1.0f;
	float4 Local70 = ProcessMaterialLinearColorTextureLookup(Texture2DSampleGrad(Material_Texture2D_4,GetMaterialSharedSampler(Material_Texture2D_4Sampler,View_MaterialTextureBilinearWrapedSampler),Local68,Local67.Ddx,Local67.Ddy));
	float Local71 =  1.0f;
	float Local72 = PositiveClampedPow(Local70.rgb.x,Material.PreshaderBuffer[2].w);
	float Local73 = (Local72 + Material.PreshaderBuffer[3].x);
	float3 Local74 = CustomExpression0(Parameters);
	float Local75 = (1.00000000 - Local74.g);
	float Local76 = (Local73 + Local75);
	float Local77 = (Local76 + 1.00000000);
	float Local78 = (2.00000000 * Local74.g);
	float Local79 = (Local78 + Local65);
	float Local80 = (Local77 - Local79);
	float Local81 = saturate(Local80);
	float Local82 = lerp(Material.PreshaderBuffer[4].y,Material.PreshaderBuffer[4].x,Local81);
	float Local83 = saturate(Local82);
	float Local84 = lerp(Local65,Local73,Local83.r.r);
	float Local85 = (Local84 + (1.00000000 - 0.00000000));
	float Local86 = (Local85 + 1.00000000);
	float Local87 =  1.0f;
	float4 Local88 = ProcessMaterialLinearColorTextureLookup(Texture2DSampleGrad(Material_Texture2D_5,GetMaterialSharedSampler(Material_Texture2D_5Sampler,View_MaterialTextureBilinearWrapedSampler),Local47,Local46.Ddx,Local46.Ddy));
	float Local89 =  1.0f;
	float Local90 = PositiveClampedPow(Local88.rgb.x,Material.PreshaderBuffer[2].w);
	float Local91 = (Local90 + Material.PreshaderBuffer[3].x);
	float Local92 = (0.00000000 + Local91);
	float Local93 = (Local86 - Local92);
	float Local94 = saturate(Local93);
	float Local95 = lerp(Material.PreshaderBuffer[4].w,Material.PreshaderBuffer[4].z,Local94);
	float Local96 = saturate(Local95);
	float3 Local97 = lerp(Local60,((float3)0.00000000),Local96.r.r);
	float Local98 = lerp(Local91,Local84,Local96.r.r);
	float Local99 = (Local98 + (1.00000000 - 0.00000000));
	float Local100 = (Local99 + 1.00000000);
	float Local101 = (0.00000000 + Local65);
	float Local102 = (Local100 - Local101);
	float Local103 = saturate(Local102);
	float Local104 = lerp(Material.PreshaderBuffer[5].y,Material.PreshaderBuffer[5].x,Local103);
	float Local105 = saturate(Local104);
	float3 Local106 = lerp(Local44,Local97,Local105.r.r);
	float Local107 = lerp(Local65,Local98,Local105.r.r);
	float Local108 = (Local107 + (1.00000000 - 0.00000000));
	float Local109 = (Local108 + 1.00000000);
	float Local110 =  1.0f;
	float4 Local111 = ProcessMaterialLinearColorTextureLookup(Texture2DSampleGrad(Material_Texture2D_6,GetMaterialSharedSampler(Material_Texture2D_6Sampler,View_MaterialTextureBilinearWrapedSampler),Local9,Local8.Ddx,Local8.Ddy));
	float Local112 =  1.0f;
	float Local113 = PositiveClampedPow(Local111.rgb.x,Material.PreshaderBuffer[2].w);
	float Local114 = (Local113 + Material.PreshaderBuffer[3].x);
	float Local115 = (0.00000000 + Local114);
	float Local116 = (Local109 - Local115);
	float Local117 = saturate(Local116);
	float Local118 = lerp(Material.PreshaderBuffer[5].w,Material.PreshaderBuffer[5].z,Local117);
	float Local119 = saturate(Local118);
	float3 Local120 = lerp(Local28,Local106,Local119.r.r);
	PixelMaterialInputs.Normal = Local120;
	float3 MaterialNormal = GetMaterialNormal(Parameters, PixelMaterialInputs);
	MaterialNormal = normalize(MaterialNormal);
	Parameters.WorldNormal = TransformTangentNormalToWorld(Parameters.TangentToWorld, MaterialNormal);
	Parameters.WorldNormal *= Parameters.TwoSidedSign;
	Parameters.ReflectionVector = ReflectionAboutCustomWorldNormal(Parameters, Parameters.WorldNormal, false);
	Parameters.Particle.MotionBlurFade = 1.0f;
	float3 Local121 = lerp(float3(0.00000000,0.00000000,0.00000000),Material.PreshaderBuffer[6].yzw,Material.PreshaderBuffer[6].x);
	float4 Local122 = ProcessMaterialLinearColorTextureLookup(Texture2DSampleGrad(Material_Texture2D_7,GetMaterialSharedSampler(Material_Texture2D_7Sampler,View_MaterialTextureBilinearWrapedSampler),Local9,Local8.Ddx,Local8.Ddy));
	float Local123 =  1.0f;
	float Local124 = (Local122.rgb.x * Material.PreshaderBuffer[7].x);
	float3 Local125 = lerp(((float3)Local124),Material.PreshaderBuffer[8].xyz,Material.PreshaderBuffer[7].y);
	float Local126 = lerp(Material.PreshaderBuffer[9].x,Material.PreshaderBuffer[8].w,Local125.x);
	float Local127 = saturate(Local126);
	float Local128 = dot(((float3)Local127.r),float3(0.30000001,0.58999997,0.11000000));
	float3 Local129 = lerp(((float3)Local127.r),((float3)Local128),Material.PreshaderBuffer[9].y);
	float4 Local130 = ProcessMaterialLinearColorTextureLookup(Texture2DSampleGrad(Material_Texture2D_8,GetMaterialSharedSampler(Material_Texture2D_8Sampler,View_MaterialTextureBilinearWrapedSampler),Local31,Local30.Ddx,Local30.Ddy));
	float Local131 =  1.0f;
	float Local132 = (Local130.rgb.x * Material.PreshaderBuffer[7].x);
	float3 Local133 = lerp(((float3)Local132),Material.PreshaderBuffer[8].xyz,Material.PreshaderBuffer[7].y);
	float Local134 = lerp(Material.PreshaderBuffer[9].x,Material.PreshaderBuffer[8].w,Local133.x);
	float Local135 = saturate(Local134);
	float Local136 = dot(((float3)Local135.r),float3(0.30000001,0.58999997,0.11000000));
	float3 Local137 = lerp(((float3)Local135.r),((float3)Local136),Material.PreshaderBuffer[9].y);
	float4 Local138 = ProcessMaterialLinearColorTextureLookup(Texture2DSampleGrad(Material_Texture2D_9,GetMaterialSharedSampler(Material_Texture2D_9Sampler,View_MaterialTextureBilinearWrapedSampler),Local47,Local46.Ddx,Local46.Ddy));
	float Local139 =  1.0f;
	float Local140 = (Local138.rgb.x * Material.PreshaderBuffer[7].x);
	float3 Local141 = lerp(((float3)Local140),Material.PreshaderBuffer[8].xyz,Material.PreshaderBuffer[7].y);
	float Local142 = lerp(Material.PreshaderBuffer[9].x,Material.PreshaderBuffer[8].w,Local141.x);
	float Local143 = saturate(Local142);
	float Local144 = dot(((float3)Local143.r),float3(0.30000001,0.58999997,0.11000000));
	float3 Local145 = lerp(((float3)Local143.r),((float3)Local144),Material.PreshaderBuffer[9].y);
	float3 Local146 = lerp(Local145,((float3)0.00000000),Local96.r.r);
	float3 Local147 = lerp(Local137,Local146,Local105.r.r);
	float3 Local148 = lerp(Local129,Local147,Local119.r.r);
	float4 Local149 = ProcessMaterialLinearColorTextureLookup(Texture2DSampleGrad(Material_Texture2D_10,GetMaterialSharedSampler(Material_Texture2D_10Sampler,View_MaterialTextureBilinearWrapedSampler),Local9,Local8.Ddx,Local8.Ddy));
	float Local150 =  1.0f;
	float Local151 = (Local149.rgb.r + Material.PreshaderBuffer[9].z);
	float Local152 = (Local149.rgb.g + Material.PreshaderBuffer[9].w);
	float Local153 = (Local149.rgb.b + Material.PreshaderBuffer[10].x);
	float4 Local154 = ProcessMaterialLinearColorTextureLookup(Texture2DSampleGrad(Material_Texture2D_11,GetMaterialSharedSampler(Material_Texture2D_11Sampler,View_MaterialTextureBilinearWrapedSampler),Local31,Local30.Ddx,Local30.Ddy));
	float Local155 =  1.0f;
	float Local156 = (Local154.rgb.r + Material.PreshaderBuffer[9].z);
	float Local157 = (Local154.rgb.g + Material.PreshaderBuffer[9].w);
	float Local158 = (Local154.rgb.b + Material.PreshaderBuffer[10].x);
	float4 Local159 = ProcessMaterialLinearColorTextureLookup(Texture2DSampleGrad(Material_Texture2D_12,GetMaterialSharedSampler(Material_Texture2D_12Sampler,View_MaterialTextureBilinearWrapedSampler),Local47,Local46.Ddx,Local46.Ddy));
	float Local160 =  1.0f;
	float Local161 = (Local159.rgb.r + Material.PreshaderBuffer[9].z);
	float Local162 = (Local159.rgb.g + Material.PreshaderBuffer[9].w);
	float Local163 = (Local159.rgb.b + Material.PreshaderBuffer[10].x);
	float Local164 = lerp((0.00000000 - 0.00000000),(0.00000000 + 1.00000000),Local94);
	float Local165 = saturate(Local164);
	float3 Local166 = lerp(float3(float2(Local161,Local162),Local163),((float3)0.00000000),Local165.r.r);
	float Local167 = lerp(Local91,Local84,Local165.r.r);
	float Local168 = (Local167 + (1.00000000 - 0.00000000));
	float Local169 = (Local168 + 1.00000000);
	float Local170 = (Local169 - Local101);
	float Local171 = saturate(Local170);
	float Local172 = lerp(Material.PreshaderBuffer[5].y,Material.PreshaderBuffer[5].x,Local171);
	float Local173 = saturate(Local172);
	float3 Local174 = lerp(float3(float2(Local156,Local157),Local158),Local166,Local173.r.r);
	float Local175 = lerp(Local65,Local167,Local173.r.r);
	float Local176 = (Local175 + (1.00000000 - 0.00000000));
	float Local177 = (Local176 + 1.00000000);
	float Local178 = (Local177 - Local115);
	float Local179 = saturate(Local178);
	float Local180 = lerp(Material.PreshaderBuffer[5].w,Material.PreshaderBuffer[5].z,Local179);
	float Local181 = saturate(Local180);
	float3 Local182 = lerp(float3(float2(Local151,Local152),Local153),Local174,Local181.r.r);
	float Local183 = lerp(Local91,0.00000000,Local96.r.r);
	float Local184 = lerp(Local65,Local183,Local105.r.r);
	float Local185 = lerp(Local114,Local184,Local119.r.r);
	PixelMaterialInputs.EmissiveColor = Local121;
	PixelMaterialInputs.Opacity = 1.00000000;
	PixelMaterialInputs.OpacityMask = 1.00000000;
	PixelMaterialInputs.BaseColor = Local148;
	PixelMaterialInputs.Metallic = Local182.b;
	PixelMaterialInputs.Specular = 0.50000000;
	PixelMaterialInputs.Roughness = Local182.g;
	PixelMaterialInputs.Anisotropy = 0.00000000;
	PixelMaterialInputs.Normal = Local120;
	PixelMaterialInputs.Tangent = float3(1.00000000,0.00000000,0.00000000);
	PixelMaterialInputs.Subsurface = 0;
	PixelMaterialInputs.AmbientOcclusion = Local182.r;
	PixelMaterialInputs.Refraction = 0;
	PixelMaterialInputs.PixelDepthOffset = 0.00000000;
	PixelMaterialInputs.ShadingModel = 1;
	PixelMaterialInputs.FrontMaterial = GetInitialisedSubstrateData();
	PixelMaterialInputs.SurfaceThickness = 0.01000000;
	PixelMaterialInputs.Displacement = Local185;
	Parameters.WorldTangent = 0;
}
void CalcMaterialParametersEx(
	in out FMaterialPixelParameters Parameters,
	in out FPixelMaterialInputs PixelMaterialInputs,
	float4 SvPosition,
	float4 ScreenPosition,
	bool bIsFrontFace,
	float3 TranslatedWorldPosition,
	float3 TranslatedWorldPositionExcludingShaderOffsets)
{
	Parameters.WorldPosition_CamRelative = TranslatedWorldPosition;
	Parameters.WorldPosition_NoOffsets_CamRelative = TranslatedWorldPositionExcludingShaderOffsets;
	Parameters.LWCData = MakeMaterialLWCData(Parameters);
	Parameters.AbsoluteWorldPosition = DFMultiplyLHSAndFastTwoSum(Parameters.LWCData.AbsoluteWorldPosition.Tile, 2097152.00f, Parameters.LWCData.AbsoluteWorldPosition.Offset);
	Parameters.WorldPosition_NoOffsets = DFMultiplyLHSAndFastTwoSum(Parameters.LWCData.WorldPosition_NoOffsets.Tile, 2097152.00f, Parameters.LWCData.WorldPosition_NoOffsets.Offset);
	Parameters.SvPosition = SvPosition;
	Parameters.ScreenPosition = ScreenPosition;
	Parameters.ViewBufferUV = ScreenPositionToBufferUV(ScreenPosition);
		Parameters.CameraVector =  select_internal( IsOrthoProjection(ResolvedView) , -ResolvedView.ViewForward , normalize(-Parameters.WorldPosition_CamRelative.xyz) );
	Parameters.LightVector = 0;
	const bool bNaniteIsFrontFace = Parameters.TwoSidedSign < 0.0f;
	Parameters.TwoSidedSign = 1.0f;
	if(!0 || View.GeneralPurposeTweak >= 1.0f)
		CalcPixelMaterialInputsAnalyticDerivatives(Parameters, PixelMaterialInputs);
	else
	{
		CalcPixelMaterialInputs(Parameters, PixelMaterialInputs);
	}
}
struct FNaniteLocalVertex
{
	uint VertIndex;
	float3 Position;
	FNaniteRawAttributeData RawAttributeData;
};
FNaniteLocalVertex FetchLocalNaniteVertex(FCluster Cluster, uint VertIndex, uint CompileTimeMaxTexCoords)
{
	FNaniteLocalVertex Output = (FNaniteLocalVertex)0;
	Output.VertIndex = VertIndex;
	Output.Position = DecodePosition(VertIndex, Cluster);
	Output.RawAttributeData = GetRawAttributeData(Cluster, VertIndex, CompileTimeMaxTexCoords);
	return Output;
}
void FetchLocalNaniteTriangle(FCluster Cluster, uint3 VertIndexes, uint CompileTimeMaxTexCoords, inout FNaniteLocalVertex OutVerts[3])
{
	const float3 Positions[3] = 
	{
		DecodePosition(VertIndexes.x, Cluster),
		DecodePosition(VertIndexes.y, Cluster),
		DecodePosition(VertIndexes.z, Cluster)
	};
	FNaniteRawAttributeData RawAttributeData[3];
	GetRawAttributeData3(RawAttributeData, Cluster, VertIndexes, CompileTimeMaxTexCoords);
	 [unroll( 3 )]
	for (uint i = 0; i < 3; ++i)
	{
		OutVerts[i].VertIndex			= VertIndexes[i];
		OutVerts[i].Position			= Positions[i];
		OutVerts[i].RawAttributeData	= RawAttributeData[i];
	}
}
struct FNanitePostDeformVertex
{
	uint VertIndex;
	float3 Position;
	float3 PointLocal;
	float3 Normal;
	float SplineDist;
	FNaniteRawAttributeData RawAttributeData;
};
FNanitePostDeformVertex DeformLocalNaniteVertex(FPrimitiveSceneData PrimitiveData, FInstanceSceneData InstanceData, FNaniteLocalVertex Input)
{
	FNanitePostDeformVertex Output;
	Output.VertIndex			= Input.VertIndex;
	Output.PointLocal			= Input.Position;
	Output.Position				= Input.Position;
	Output.Normal				= float3(Input.RawAttributeData.TangentZ);
	Output.SplineDist			= 0.0f;
	Output.RawAttributeData		= Input.RawAttributeData;
	return Output;
}
FNanitePostDeformVertex FetchAndDeformLocalNaniteVertex(FPrimitiveSceneData PrimitiveData, FInstanceSceneData InstanceData, FCluster Cluster, uint VertIndex, uint CompileTimeMaxTexCoords)
{
	return DeformLocalNaniteVertex(PrimitiveData, InstanceData, FetchLocalNaniteVertex(Cluster, VertIndex, CompileTimeMaxTexCoords));
}
void FetchAndDeformLocalNaniteTriangle(FPrimitiveSceneData PrimitiveData, FInstanceSceneData InstanceData, FCluster Cluster, uint3 VertIndexes, uint CompileTimeMaxTexCoords, inout FNanitePostDeformVertex OutVerts[3])
{
	FNaniteLocalVertex InVerts[3];
	FetchLocalNaniteTriangle(Cluster, VertIndexes, CompileTimeMaxTexCoords, InVerts);
	 [unroll( 3 )]
	for(uint i = 0; i < 3; ++i)
	{
		OutVerts[i] = DeformLocalNaniteVertex(PrimitiveData, InstanceData, InVerts[i]);
	}
}
struct FVertexFactoryInterpolantsVSToPS
{
	nointerpolation uint ViewIndex				: PACKED_VIEW_INDEX;
};
void GetNaniteMaterialSceneData(FVisibleCluster VisibleCluster, inout FPrimitiveSceneData PrimitiveData, inout FInstanceSceneData InstanceData)
{
	InstanceData	= GetInstanceSceneData(VisibleCluster, false);
	PrimitiveData	= GetPrimitiveData(InstanceData.PrimitiveId);
}
float3x3 CalcVertexTangentToLocal(FPrimitiveSceneData PrimitiveData, FInstanceSceneData InstanceData, FNanitePostDeformVertex Vert)
{
	float3x3 TangentToLocal;
	[branch]
	if(Vert.RawAttributeData.TangentX_AndSign.w != 0.0f)
	{
		TangentToLocal = NaniteTangentToLocal(Vert.RawAttributeData.TangentX_AndSign, Vert.RawAttributeData.TangentZ);
	}
	else
	{
		TangentToLocal = GetTangentBasis(Vert.RawAttributeData.TangentZ);
	}
	return TangentToLocal;
}
void SetVertexParameterInstanceData(inout FMaterialVertexParameters VertexParameters, FInstanceSceneData InstanceData, FPrimitiveSceneData PrimitiveData, bool bEvaluateWorldPositionOffset)
{
	VertexParameters.PrimitiveId			= InstanceData.PrimitiveId;
	VertexParameters.InstanceLocalToWorld	= InstanceData.LocalToWorld;
	VertexParameters.InstanceWorldToLocal	= InstanceData.WorldToLocal;
	VertexParameters.PrevFrameLocalToWorld	= InstanceData.PrevLocalToWorld;
	VertexParameters.PerInstanceRandom      = InstanceData.RandomID;
	VertexParameters.SceneData.PrimitiveId 	= InstanceData.PrimitiveId;
	VertexParameters.SceneData.InstanceId 	= InstanceData.RelativeId;
	VertexParameters.SceneData.InstanceData	= InstanceData;
	VertexParameters.SceneData.Primitive	= PrimitiveData;
	VertexParameters.bEvaluateWorldPositionOffset = bEvaluateWorldPositionOffset;
}
void SetVertexParameterAttributeData(inout FMaterialVertexParameters VertexParameters, FNanitePostDeformVertex Vert, float4x4 LocalToTranslatedWorld, float3x3 LocalToWorldNoScale)
{
	float3x3 TangentToLocal = CalcVertexTangentToLocal(VertexParameters.SceneData.Primitive, VertexParameters.SceneData.InstanceData, Vert);
	VertexParameters.WorldPosition		= mul(float4(Vert.Position, 1), LocalToTranslatedWorld).xyz;
	VertexParameters.TangentToWorld		= mul(TangentToLocal, LocalToWorldNoScale);
	VertexParameters.VertexColor		= Vert.RawAttributeData.Color;
	VertexParameters.PreSkinnedPosition = Vert.Position;
	VertexParameters.PreSkinnedNormal	= TangentToLocal[2];
	VertexParameters.LWCData = MakeMaterialLWCData(VertexParameters);
}
struct FNaniteVertTransforms
{
	float4x4 LocalToTranslatedWorld;
	float4x4 PrevLocalToTranslatedWorld;
	float4x4 TranslatedWorldToClip;
	float3x3 LocalToWorldNoScale;
	float3x3 PrevLocalToWorldNoScale;
	float3x3 WorldToLocalVector;
	float3x3 PrevWorldToLocalVector;
};
struct FNaniteTransformedVert
{
	uint VertIndex;
	float3 PointLocal;
	float3 PointPostDeform;
	float3 PrevPointPostDeform;
	float3 PointWorld;
	float3 PointWorld_NoOffset;
	float4 PointClip;
	float3 NormalPostDeform;
	float4 NormalClip;
	FNaniteRawAttributeData RawAttributeData;
	float SplineDist;
};
struct FNaniteTransformedTri
{
	FNaniteTransformedVert Verts[3];
};
FNaniteVertTransforms CalculateNaniteVertexTransforms(FInstanceSceneData InstanceData, FInstanceDynamicData InstanceDynamicData, FNaniteView NaniteView)
{
	const float4x4 LocalToTranslatedWorld = InstanceDynamicData.LocalToTranslatedWorld;
	const float4x4 PrevLocalToTranslatedWorld = InstanceDynamicData.PrevLocalToTranslatedWorld;
	const float3 InvNonUniformScale = InstanceData.InvNonUniformScale;
	float3x3 LocalToWorldNoScale = (float3x3)LocalToTranslatedWorld;
	LocalToWorldNoScale[0] *= InvNonUniformScale.x;
	LocalToWorldNoScale[1] *= InvNonUniformScale.y;
	LocalToWorldNoScale[2] *= InvNonUniformScale.z;
	float3x3 PrevLocalToWorldNoScale = (float3x3)PrevLocalToTranslatedWorld;
	PrevLocalToWorldNoScale[0] *= InvNonUniformScale.x;
	PrevLocalToWorldNoScale[1] *= InvNonUniformScale.y;
	PrevLocalToWorldNoScale[2] *= InvNonUniformScale.z;
	float3x3 WorldToLocalVector = DFToFloat3x3(InstanceData.WorldToLocal);
	const float3 SqInvNonUniformScale = Pow2(InvNonUniformScale);
	float3x3 PrevWorldToLocalVector = DFToFloat3x3(InstanceData.PrevLocalToWorld);
	PrevWorldToLocalVector[0] *= SqInvNonUniformScale.x;
	PrevWorldToLocalVector[1] *= SqInvNonUniformScale.y;
	PrevWorldToLocalVector[2] *= SqInvNonUniformScale.z;
	PrevWorldToLocalVector = transpose(PrevWorldToLocalVector);
	FNaniteVertTransforms Transforms;
	Transforms.LocalToTranslatedWorld		= LocalToTranslatedWorld;
	Transforms.PrevLocalToTranslatedWorld	= PrevLocalToTranslatedWorld;
	Transforms.TranslatedWorldToClip		= NaniteView.TranslatedWorldToClip;
	Transforms.LocalToWorldNoScale			= LocalToWorldNoScale;
	Transforms.PrevLocalToWorldNoScale		= PrevLocalToWorldNoScale;
	Transforms.WorldToLocalVector			= WorldToLocalVector;
	Transforms.PrevWorldToLocalVector		= PrevWorldToLocalVector;
	return Transforms;
}
FNaniteVertTransforms WaveReadLaneAt(FNaniteVertTransforms In, uint SrcIndex)
{
	FNaniteVertTransforms Result;
	Result.LocalToTranslatedWorld		= WaveReadLaneAtMatrix(In.LocalToTranslatedWorld,		SrcIndex);
	Result.PrevLocalToTranslatedWorld	= WaveReadLaneAtMatrix(In.PrevLocalToTranslatedWorld, SrcIndex);
	Result.TranslatedWorldToClip		= WaveReadLaneAtMatrix(In.TranslatedWorldToClip,		SrcIndex);
	Result.LocalToWorldNoScale			= WaveReadLaneAtMatrix(In.LocalToWorldNoScale,		SrcIndex);
	Result.PrevLocalToWorldNoScale		= WaveReadLaneAtMatrix(In.PrevLocalToWorldNoScale,	SrcIndex);
	Result.WorldToLocalVector			= WaveReadLaneAtMatrix(In.WorldToLocalVector,			SrcIndex);
	Result.PrevWorldToLocalVector		= WaveReadLaneAtMatrix(In.PrevWorldToLocalVector,		SrcIndex);
	return Result;
}
FNaniteTransformedTri TransformNaniteTriangle(FPrimitiveSceneData PrimitiveData, FInstanceSceneData InstanceData, FNaniteVertTransforms Transforms, FNanitePostDeformVertex InVerts[3], bool bEvaluateWPO)
{
	FNaniteTransformedTri Tri = (FNaniteTransformedTri)0;
	{
		 [unroll( 3 )]
		for (int i = 0; i < 3; ++i)
		{
			const float3 NormalWorld			= mul(float4(InVerts[i].Normal, 0), Transforms.LocalToTranslatedWorld).xyz;
			Tri.Verts[i].VertIndex				= InVerts[i].VertIndex;
			Tri.Verts[i].RawAttributeData		= InVerts[i].RawAttributeData;
			Tri.Verts[i].SplineDist				= InVerts[i].SplineDist;
			Tri.Verts[i].NormalPostDeform		= InVerts[i].Normal;
			Tri.Verts[i].NormalClip				= mul(float4(NormalWorld, 0), Transforms.TranslatedWorldToClip);
			Tri.Verts[i].PointLocal				= InVerts[i].PointLocal;
			Tri.Verts[i].PointPostDeform		= InVerts[i].Position;
			Tri.Verts[i].PrevPointPostDeform	= InVerts[i].Position;
			Tri.Verts[i].PointWorld				= mul(float4(Tri.Verts[i].PointPostDeform, 1), Transforms.LocalToTranslatedWorld).xyz;
			Tri.Verts[i].PointWorld_NoOffset	= Tri.Verts[i].PointWorld;
			Tri.Verts[i].PointClip				= mul(float4(Tri.Verts[i].PointWorld, 1), Transforms.TranslatedWorldToClip);
		}
	}
	return Tri;
}
FNaniteTransformedTri FetchTransformedNaniteTriangle(FPrimitiveSceneData PrimitiveData, FInstanceSceneData InstanceData, FNaniteVertTransforms Transforms, FCluster Cluster, uint3 VertIndexes, bool bEvaluateWPO)
{
	FNanitePostDeformVertex Verts[3];
	FetchAndDeformLocalNaniteTriangle(PrimitiveData, InstanceData, Cluster, VertIndexes, 0, Verts);
	return TransformNaniteTriangle(PrimitiveData, InstanceData, Transforms, Verts, bEvaluateWPO);
}
FNaniteTransformedVert TransformNaniteVertex(FPrimitiveSceneData PrimitiveData, FInstanceSceneData InstanceData, FNaniteVertTransforms Transforms, FNanitePostDeformVertex InVert, bool bEvaluateWPO)
{
	FNaniteTransformedVert Vert = (FNaniteTransformedVert)0;
	Vert.VertIndex = InVert.VertIndex;
	Vert.RawAttributeData = InVert.RawAttributeData;
	Vert.NormalPostDeform = InVert.Normal;
	Vert.PointLocal = InVert.PointLocal;
	Vert.SplineDist = InVert.SplineDist;
	const float3 NormalWorld = mul(float4(InVert.Normal, 0), Transforms.LocalToTranslatedWorld).xyz;
	Vert.NormalClip = mul(float4(NormalWorld, 0), Transforms.TranslatedWorldToClip);
	{
		Vert.PointPostDeform = InVert.Position;
		Vert.PrevPointPostDeform = InVert.Position;
		Vert.PointWorld = mul(float4(Vert.PointPostDeform, 1), Transforms.LocalToTranslatedWorld).xyz;
		Vert.PointWorld_NoOffset = Vert.PointWorld;
		Vert.PointClip = mul(float4(Vert.PointWorld, 1), Transforms.TranslatedWorldToClip);
	}
	return Vert;
}
FNaniteTransformedVert FetchTransformedNaniteVertex(FPrimitiveSceneData PrimitiveData, FInstanceSceneData InstanceData, FNaniteVertTransforms Transforms, FCluster Cluster, uint VertIndex, bool bEvaluateWPO)
{
	FNanitePostDeformVertex Vert = FetchAndDeformLocalNaniteVertex(PrimitiveData, InstanceData, Cluster, VertIndex, 0);
	return TransformNaniteVertex(PrimitiveData, InstanceData, Transforms, Vert, bEvaluateWPO);
}
FNaniteTransformedVert WaveReadLaneAt(FNaniteTransformedVert Vert, uint SrcIndex)
{
	FNaniteTransformedVert Result;
	Result.VertIndex			= WaveReadLaneAt( Vert.VertIndex,			SrcIndex );
	Result.RawAttributeData		= WaveReadLaneAt( Vert.RawAttributeData,	SrcIndex );
	Result.PointLocal			= WaveReadLaneAt( Vert.PointLocal,			SrcIndex );
	Result.PointPostDeform		= WaveReadLaneAt( Vert.PointPostDeform,		SrcIndex );
	Result.PrevPointPostDeform	= WaveReadLaneAt( Vert.PrevPointPostDeform,	SrcIndex );
	Result.PointWorld			= WaveReadLaneAt( Vert.PointWorld,			SrcIndex );
	Result.PointWorld_NoOffset	= WaveReadLaneAt( Vert.PointWorld_NoOffset,	SrcIndex );
	Result.PointClip			= WaveReadLaneAt( Vert.PointClip,			SrcIndex );
	Result.SplineDist			= WaveReadLaneAt( Vert.SplineDist,			SrcIndex );
	Result.NormalPostDeform		= WaveReadLaneAt( Vert.NormalPostDeform,	SrcIndex );
	Result.NormalClip			= WaveReadLaneAt( Vert.NormalClip,			SrcIndex );
	return Result;
}
FNaniteTransformedTri MakeTransformedNaniteTriangle(FNaniteTransformedVert Vert, uint3 SrcLaneIndices)
{
	FNaniteTransformedTri Tri;
	for (uint Corner = 0; Corner < 3; ++Corner)
	{
		Tri.Verts[Corner] = WaveReadLaneAt(Vert, SrcLaneIndices[Corner]);
	}
	return Tri;
}
FMaterialPixelParameters FetchNaniteMaterialPixelParameters(FPrimitiveSceneData PrimitiveData, FInstanceSceneData InstanceData, FInstanceDynamicData InstanceDynamicData, FNaniteView NaniteView, FNaniteTransformedTri Tri, FCluster Cluster, FBarycentrics Barycentrics, inout FVertexFactoryInterpolantsVSToPS Interpolants, inout float4 SvPosition)
{
	FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();
	const float SignTest = dot(cross(Tri.Verts[1].PointClip.xyw - Tri.Verts[0].PointClip.xyw, Tri.Verts[2].PointClip.xyw - Tri.Verts[0].PointClip.xyw), Tri.Verts[0].PointClip.xyw);
	Result.TwoSidedSign = CondMask(SignTest > 0.0f, -1.0f, 1.0f);
	float3x3 TangentRot =
	{
		1, 0, 0,
		0, 1, 0,
		0, 0, 1
	};
	const uint NumAttributeDataCoords = 1;
	const FNaniteAttributeData AttributeData = GetAttributeData(
		Cluster,
		Tri.Verts[0].PointLocal,
		Tri.Verts[1].PointLocal,
		Tri.Verts[2].PointLocal,
		Tri.Verts[0].RawAttributeData,
		Tri.Verts[1].RawAttributeData,
		Tri.Verts[2].RawAttributeData,
		Barycentrics,
		InstanceData,
		NumAttributeDataCoords,
		TangentRot
	);
	Result.VertexColor = float4(1, 1, 1, 1);
	Result.VertexColor_DDX = 0.0f;
	Result.VertexColor_DDY = 0.0f;
	Result.TangentToWorld = AttributeData.TangentToWorld;
	Result.UnMirrored = AttributeData.UnMirrored;
	const TDual< float3 > PointWorld = Lerp( Tri.Verts[0].PointWorld, Tri.Verts[1].PointWorld, Tri.Verts[2].PointWorld, Barycentrics );
	Result.WorldPosition_CamRelative	= PointWorld.Value;
	Result.WorldPosition_DDX			= PointWorld.Value_dx;
	Result.WorldPosition_DDY			= PointWorld.Value_dy;
	Result.WorldPosition_NoOffsets_CamRelative = Lerp( Tri.Verts[0].PointWorld_NoOffset, Tri.Verts[1].PointWorld_NoOffset, Tri.Verts[2].PointWorld_NoOffset, Barycentrics ).Value;
	const float3 PrevPointPostDeform = Lerp( Tri.Verts[0].PrevPointPostDeform, Tri.Verts[1].PrevPointPostDeform, Tri.Verts[2].PrevPointPostDeform, Barycentrics ).Value;
	float3 PrevPointWorld = mul(float4(PrevPointPostDeform.xyz, 1), InstanceDynamicData.PrevLocalToTranslatedWorld).xyz;
	const float4 PixelTranslatedWorld = mul( SvPosition, NaniteView.SVPositionToTranslatedWorld );
	const float3 Displacement = PixelTranslatedWorld.xyz / PixelTranslatedWorld.w - PointWorld.Value;
	PrevPointWorld += Displacement;
	Result.PrevScreenPosition = mul(float4(PrevPointWorld, 1), NaniteView.PrevTranslatedWorldToClip);
	{
		const TDual< float4 > PointClip = Lerp( Tri.Verts[0].PointClip, Tri.Verts[1].PointClip, Tri.Verts[2].PointClip, Barycentrics );
		SvPosition.w = PointClip.Value.w;
		float2 Z_DDX_DDY = float2( PointClip.Value_dx.z, PointClip.Value_dy.z );
		float2 W_DDX_DDY = float2( PointClip.Value_dx.w, PointClip.Value_dy.w );
		float2 PPZ_DDX_DDY = (Z_DDX_DDY * PointClip.Value.w - PointClip.Value.z * W_DDX_DDY) / (PointClip.Value.w * PointClip.Value.w);
		SvPositionToResolvedScreenPositionDeriv(SvPosition, PPZ_DDX_DDY, W_DDX_DDY, Result.ScreenPosition, Result.ScreenPosition_DDX, Result.ScreenPosition_DDY);
	}
	Result.Particle.Color = float4(1, 1, 1, 1);
	Result.PerInstanceRandom = InstanceData.RandomID;
	Result.PrimitiveId  = InstanceData.PrimitiveId;
	Result.InstanceId   = InstanceData.RelativeId;
	return Result;
}
FMaterialPixelParameters FetchNaniteMaterialPixelParameters(FNaniteView NaniteView, uint64_t PackedPixel, bool bHasPageData, FBarycentrics Barycentrics, bool bCalcBarycentrics, uint3 TriIndices, bool bCalcTriIndices, inout FVertexFactoryInterpolantsVSToPS Interpolants, inout float4 SvPosition)
{
	FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();
	uint DepthInt = 0;
	uint VisibleClusterIndex = 0;
	uint TriIndex = 0;
	bool bIsImposter = false;
	UnpackVisPixel(PackedPixel, DepthInt, VisibleClusterIndex, TriIndex, bIsImposter);
	SvPosition.z = asfloat(DepthInt);
	if (VisibleClusterIndex != 0xFFFFFFFF)
	{
		FVisibleCluster VisibleCluster           = GetVisibleCluster( VisibleClusterIndex, 1 );
		FPrimitiveSceneData PrimitiveData;
		FInstanceSceneData InstanceData;
		GetNaniteMaterialSceneData(VisibleCluster, PrimitiveData, InstanceData);
		FInstanceDynamicData InstanceDynamicData = CalculateInstanceDynamicData(NaniteView, InstanceData);
		FCluster Cluster                         = GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);
		if (bCalcTriIndices)
		{
			TriIndices = DecodeTriangleIndices(Cluster, TriIndex);
		}
		bool bEvaluateWPO = !bIsImposter;
		bEvaluateWPO &= (VisibleCluster.Flags & 0x8) != 0;
		const FNaniteVertTransforms Transforms = CalculateNaniteVertexTransforms(InstanceData, InstanceDynamicData, NaniteView);
		const FNaniteTransformedTri Tri = FetchTransformedNaniteTriangle(PrimitiveData, InstanceData, Transforms, Cluster, TriIndices, bEvaluateWPO);
		if (bCalcBarycentrics)
		{
			const float2 PixelClip = (SvPosition.xy - NaniteView.ViewRect.xy) * NaniteView.ViewSizeAndInvSize.zw * float2(2, -2) + float2(-1, 1);
			float4x4 TranslatedWorldToLocal = DFFastToTranslatedWorld( InstanceData.WorldToLocal, NaniteView.PreViewTranslation );
			float4 PixelTranslatedWorld		= mul( SvPosition,		NaniteView.SVPositionToTranslatedWorld );
			float4 PixelTranslatedWorld_dx	= mul( float4(1,0,0,0),	NaniteView.SVPositionToTranslatedWorld );
			float4 PixelTranslatedWorld_dy	= mul( float4(0,1,0,0),	NaniteView.SVPositionToTranslatedWorld );
			float4 PixelLocal		= mul( PixelTranslatedWorld,	TranslatedWorldToLocal );
			float4 PixelLocal_dx	= mul( PixelTranslatedWorld_dx,	TranslatedWorldToLocal );
			float4 PixelLocal_dy	= mul( PixelTranslatedWorld_dy,	TranslatedWorldToLocal );
			Barycentrics = CalculateTriangleBarycentrics(
				PixelLocal.xyz / PixelLocal.w,
				( PixelLocal.xyz + PixelLocal_dx.xyz ) / PixelLocal.w,
				( PixelLocal.xyz + PixelLocal_dy.xyz ) / PixelLocal.w,
				Tri.Verts[0].PointPostDeform,
				Tri.Verts[1].PointPostDeform,
				Tri.Verts[2].PointPostDeform,
				Tri.Verts[0].NormalPostDeform,
				Tri.Verts[1].NormalPostDeform,
				Tri.Verts[2].NormalPostDeform );
		}
		Result = FetchNaniteMaterialPixelParameters(PrimitiveData, InstanceData, InstanceDynamicData, NaniteView, Tri, Cluster, Barycentrics, Interpolants, SvPosition);
	}
	return Result;
}
static const uint BarycentricMax = (1 << 15);
uint EncodeBarycentrics( float3 Barycentrics )
{
	Barycentrics = round( Barycentrics * BarycentricMax );
	[flatten]
	if( Barycentrics.x > max( Barycentrics.y, Barycentrics.z ) )
		Barycentrics.x = BarycentricMax - Barycentrics.y - Barycentrics.z;
	else if( Barycentrics.y > Barycentrics.z )
		Barycentrics.y = BarycentricMax - Barycentrics.x - Barycentrics.z;
	else
		Barycentrics.z = BarycentricMax - Barycentrics.x - Barycentrics.y;
	uint Encoded;
	Encoded  = uint( Barycentrics.x );
	Encoded |= uint( Barycentrics.y ) << 16;
	return Encoded;
}
float3 DecodeBarycentrics( uint Encoded )
{
	float3 Barycentrics;
	Barycentrics.x = float(Encoded & 0xffff) / BarycentricMax;
	Barycentrics.y = float(Encoded >> 16) / BarycentricMax;
	Barycentrics.z = 1.0f - Barycentrics.x - Barycentrics.y;
	return Barycentrics;
}
ByteAddressBuffer TessellationTable_Offsets;
ByteAddressBuffer TessellationTable_VertsAndIndexes;
float InvDiceRate;
uint MaxPatchesPerGroup;
float3 GetTessFactors( FNaniteView NaniteView, float3 PointView[3] )
{
	bool bOrtho = NaniteView.ViewToClip[3][3] >= 1;
	float3 TessFactors;
	for( uint i = 0; i < 3; i++ )
	{
		uint i0 = i;
		uint i1 = (i + 1) % 3;
		float EdgeScale = min( PointView[ i0 ].z, PointView[ i1 ].z );
		float EdgeLength = length( PointView[ i0 ] - PointView[ i1 ] );
		EdgeScale = bOrtho ? 1.0f : max( EdgeScale, NaniteView.NearPlane );
		TessFactors[i] = EdgeLength / EdgeScale;
	}
	TessFactors *= NaniteView.LODScale * InvDiceRate;
	return TessFactors;
}
struct FTessellatedPatch
{
	uint	TableOffset;
	uint	Pattern_NumVerts_NumTris;
	void Init( float3 TessFactors, inout uint3 VertData, bool bImmediateTable )
	{
		TessFactors = ceil( TessFactors );
		TessFactors = clamp( TessFactors, 1, 14 );
		float MaxTessFactor = max3( TessFactors.x, TessFactors.y, TessFactors.z );
		if( TessFactors.y == MaxTessFactor )
		{
			VertData = VertData.yzx;
			TessFactors = TessFactors.yzx;
		}
		else if( TessFactors.z == MaxTessFactor )
		{
			VertData = VertData.zxy;
			TessFactors = TessFactors.zxy;
		}
		bool bFlipWinding = false;
		if( TessFactors.y < TessFactors.z )
		{
			VertData.xy = VertData.yx;
			TessFactors.yz = TessFactors.zy;
			bFlipWinding = true;
		}
		uint Pattern = uint(
			TessFactors.x +
			TessFactors.y * 16 +
			TessFactors.z * 16 * 16 -
			(1 + 16 + 16 * 16) );
		Pattern |= bFlipWinding ? 0x1000 : 0;
		Init( Pattern, bImmediateTable );
	}
	void Init( uint InPattern, bool bImmediateTable)
	{
		const uint Offset = bImmediateTable ? (16 * 16 * 16) : 0u;
		const uint2 Tmp = TessellationTable_Offsets.Load2( 4 * 2 * ( Offset + ( InPattern & 0xfff ) ) );
		TableOffset = Tmp.x;
		Pattern_NumVerts_NumTris = InPattern | Tmp.y;
	}
	uint GetPattern()	{ return Pattern_NumVerts_NumTris & 0x1FFFu; }
	uint GetNumVerts()	{ return ( Pattern_NumVerts_NumTris >> 13 ) & 0x1FFu; }
	uint GetNumTris()	{ return Pattern_NumVerts_NumTris >> 22; }
	float3 GetVert( uint VertIndex )
	{
		uint BarycentricsEncoded = TessellationTable_VertsAndIndexes.Load( 4 * ( TableOffset + VertIndex ) );
		return DecodeBarycentrics( BarycentricsEncoded );
	}
	uint3 GetIndexes( uint TriIndex )
	{
		uint  PackedIndexes	= TessellationTable_VertsAndIndexes.Load( 4 * ( TableOffset + GetNumVerts() + TriIndex ) );
		uint3 VertIndexes;
		VertIndexes[0] = ( PackedIndexes >>  0 ) & 1023;
		VertIndexes[1] = ( PackedIndexes >> 10 ) & 1023;
		VertIndexes[2] = ( PackedIndexes >> 20 ) & 1023;
		bool bFlipWinding = Pattern_NumVerts_NumTris & 0x1000;
		if( bFlipWinding )
			VertIndexes.yz = VertIndexes.zy;
		return VertIndexes;
	}
	uint3 GetTriangleEncoded( uint TriIndex )
	{
		uint3 VertIndexes = GetIndexes( TriIndex );
		uint Pattern = GetPattern();
		uint3 Shift, Mask;
		for( int i = 0; i < 3; i++ )
		{
			Shift[i] = BitFieldExtractU32( Pattern, 1, i + 25 ) << 4;
			Mask[i]  = BitFieldExtractU32( Pattern, 1, i + 28 ) << 4;
			Mask[i]  = BitFieldMaskU32( Mask[i], 0 );
		}
		uint3 Encoded;
		for( int i = 0; i < 3; i++ )
		{
			uint BarycentricsEncoded = TessellationTable_VertsAndIndexes.Load( 4 * ( TableOffset + VertIndexes[i] ) );
			uint3 Barycentrics;
			Barycentrics.x = BarycentricsEncoded & 0xffff;
			Barycentrics.y = BarycentricsEncoded >> 16;
			Barycentrics.z = BarycentricMax - Barycentrics.x - Barycentrics.y;
			Barycentrics = ( Barycentrics & Mask ) << Shift;
			Encoded[i] = Barycentrics.x | Barycentrics.y | Barycentrics.z;
		}
		return Encoded;
	}
	uint3 GetTessFactors()
	{
		uint Packed = GetPattern() & 0xfff;
		Packed -= (1 + 16 + 16 * 16);
		uint3 TessFactors;
		for( int i = 0; i < 3; i++ )
		{
			TessFactors[i] = Packed % 16;
			Packed /= 16;
		}
		return TessFactors;
	}
};
FTessellatedPatch WaveReadLaneAt( FTessellatedPatch In, uint SrcIndex )
{
	FTessellatedPatch Out;
	Out.TableOffset					= WaveReadLaneAt( In.TableOffset,				SrcIndex );
	Out.Pattern_NumVerts_NumTris	= WaveReadLaneAt( In.Pattern_NumVerts_NumTris,	SrcIndex );
	return Out;
}
struct FSplitPatch
{
	uint	VisibleClusterIndex;
	uint	TriIndex;
	float3	Barycentrics[3];
	void Decode( uint4 Encoded )
	{
		VisibleClusterIndex	= Encoded.x >> 7;
		TriIndex			= Encoded.x & 0x7F;
		for( int i = 0; i < 3; i++ )
			Barycentrics[i] = DecodeBarycentrics( Encoded[ i + 1 ] );
	}
	float3 TransformBarycentrics( float3 Local )
	{
		return  MakePrecise( Barycentrics[0] * Local.x + 			Barycentrics[1] * Local.y + 			Barycentrics[2] * Local.z );
	}
	FBarycentrics TransformBarycentrics( FBarycentrics Local )
	{
		FBarycentrics Global;
		Global.Value	= TransformBarycentrics( Local.Value );
		Global.Value_dx	= TransformBarycentrics( Local.Value_dx );
		Global.Value_dy	= TransformBarycentrics( Local.Value_dy );
		return Global;
	}
};
FSplitPatch WaveReadLaneAt(FSplitPatch In, uint SrcIndex)
{
	FSplitPatch Result;
	Result.VisibleClusterIndex	= WaveReadLaneAt(In.VisibleClusterIndex, SrcIndex);
	Result.TriIndex				= WaveReadLaneAt(In.TriIndex, SrcIndex);
	Result.Barycentrics[0]		= WaveReadLaneAt(In.Barycentrics[0], SrcIndex);
	Result.Barycentrics[1]		= WaveReadLaneAt(In.Barycentrics[1], SrcIndex);
	Result.Barycentrics[2]		= WaveReadLaneAt(In.Barycentrics[2], SrcIndex);
	return Result;
}
struct FWorkQueueState
{
	uint	ReadOffset;
	uint	WriteOffset;
	int		TaskCount;		
};
struct FOutputQueue
{
	RWByteAddressBuffer						DataBuffer;
	RWStructuredBuffer< FWorkQueueState >	StateBuffer;	
	uint	StateIndex;
	uint	Size;
	uint Add()
	{
		uint WriteOffset;
		 { 	uint NumToAdd = WaveActiveCountBits( true ) * 1 ; WriteOffset = 0; 	if( WaveIsFirstLane() ) 		InterlockedAdd( StateBuffer[ StateIndex ].WriteOffset , NumToAdd, WriteOffset ); WriteOffset = WaveReadLaneFirst( WriteOffset ) + WavePrefixCountBits( true ) * 1 ; };
		 { 	uint NumToAdd = WaveActiveCountBits( true ) * 1 ; 	if( WaveIsFirstLane() ) 		InterlockedAdd( StateBuffer[ StateIndex ].TaskCount , NumToAdd ); };
		return WriteOffset;
	}
};
RWByteAddressBuffer						SplitWorkQueue_DataBuffer;
RWStructuredBuffer< FWorkQueueState >	SplitWorkQueue_StateBuffer;
uint									SplitWorkQueue_Size;
static const FOutputQueue SplitWorkQueue = { SplitWorkQueue_DataBuffer, SplitWorkQueue_StateBuffer, 0, SplitWorkQueue_Size };
ByteAddressBuffer	VisiblePatches;
struct FRaster
{
	float2	ViewportScale;
	float2	ViewportBias;
	int4	ScissorRect;
	uint2	pPage;
	uint2	vPage;
	float2	vTranslation;
	bool	bSinglePage;
	uint	ArrayIndex;
};
float4 CalculateSubpixelCoordinates( FRaster Raster, float4 PointClip )
{
	float4 Subpixel = float4( PointClip.xyz, 1 ) / PointClip.w;
	Subpixel.xy = Subpixel.xy * Raster.ViewportScale + Raster.ViewportBias;
	Subpixel.xy = floor(Subpixel.xy);
	return Subpixel;
}
struct FNullTranslation
{
	bool operator()( inout FVisBufferPixel Pixel )
	{
		return true;
	}
};
template< typename FSoftwareShader, typename FPageTranslation = FNullTranslation >
struct TNaniteWritePixel
{
	FRaster				Raster;
	FSoftwareShader		Shader;
	uint				PixelValue;
	uint2				VisualizeValues;
	FPageTranslation	PageTranslation;
	void operator()( uint2 PixelPos, float3 C, FRasterTri Tri )
	{
		float DeviceZ = Tri.DepthPlane.x + Tri.DepthPlane.y * C.y + Tri.DepthPlane.z * C.z;
		FVisBufferPixel Pixel = CreateVisBufferPixel( PixelPos, PixelValue, DeviceZ );
		Pixel.VisualizeValues = VisualizeValues;
		Pixel.PhysicalPosition.xy = Pixel.Position;
		Pixel.PhysicalPosition.z = Raster.ArrayIndex;
		if( !PageTranslation( Pixel ) )
		{
			return;
		}
		Pixel.WriteOverdraw();
		Pixel.Write();
	}
};
struct FMaterialShader
{
	FNaniteView					NaniteView;
	FInstanceSceneData			InstanceData;
	FInstanceDynamicData		InstanceDynamicData;
	FCluster					Cluster;
	FNaniteVertTransforms		VertTransforms;
	FNaniteTransformedTri		TransformedTri;
	float DisplacementCenter;
	float DisplacementMagnitude;
	float3 EvaluateWorldPositionOffset( FNanitePostDeformVertex InputVert )
	{
		float3 WorldPositionOffset = 0.0f;
		FPrimitiveSceneData PrimitiveData = GetPrimitiveData(InstanceData.PrimitiveId);
		[branch]
		if ((PrimitiveData.Flags & 0x8000) != 0u)
		{
			float3x3 LocalToWorld = DFToFloat3x3(InstanceData.LocalToWorld);
			float3 InvScale = InstanceData.InvNonUniformScale;
			LocalToWorld[0] *= InvScale.x;
			LocalToWorld[1] *= InvScale.y;
			LocalToWorld[2] *= InvScale.z;
			FMaterialVertexParameters VertexParameters = MakeInitializedMaterialVertexParameters();
			SetVertexParameterInstanceData(VertexParameters, InstanceData, PrimitiveData, true );
			SetVertexParameterAttributeData(VertexParameters, InputVert, InstanceDynamicData.LocalToTranslatedWorld, LocalToWorld);
			WorldPositionOffset = GetMaterialWorldPositionOffset(VertexParameters);
		}
		return WorldPositionOffset;
	}
	float4 EvaluateDomain( float4 UVDensities, FBarycentrics Barycentrics )
	{
		float3 PointPostDeform = Lerp( 
			TransformedTri.Verts[0].PointPostDeform,
			TransformedTri.Verts[1].PointPostDeform,
			TransformedTri.Verts[2].PointPostDeform,
			Barycentrics ).Value;
		float4 BaseClip = Lerp( 
			TransformedTri.Verts[0].PointClip,
			TransformedTri.Verts[1].PointClip,
			TransformedTri.Verts[2].PointClip,
			Barycentrics ).Value;
		float4 SvPosition;
		SvPosition.xyz = BaseClip.xyz / BaseClip.w;
		SvPosition.xy = ( float2(0.5, -0.5) * SvPosition.xy + 0.5 ) * NaniteView.ViewSizeAndInvSize.xy + NaniteView.ViewRect.xy;
		SvPosition.w = 1;
		FPrimitiveSceneData PrimitiveData = GetPrimitiveData(InstanceData.PrimitiveId);
		FVertexFactoryInterpolantsVSToPS Interpolants = (FVertexFactoryInterpolantsVSToPS)0;
		FMaterialPixelParameters MaterialParameters = FetchNaniteMaterialPixelParameters( PrimitiveData, InstanceData, InstanceDynamicData, NaniteView, TransformedTri, Cluster, Barycentrics, Interpolants, SvPosition );
		FPixelMaterialInputs PixelMaterialInputs;
		CalcMaterialParametersEx(
			MaterialParameters,
			PixelMaterialInputs,
			SvPosition,
			MaterialParameters.ScreenPosition,
			true, 
			MaterialParameters.WorldPosition_CamRelative,
			MaterialParameters.WorldPosition_NoOffsets_CamRelative );
		const float NormalizedDisplacement = GetMaterialDisplacement(PixelMaterialInputs);
		const float CenterScaled = DisplacementCenter * DisplacementMagnitude;
		const float Displacement = (NormalizedDisplacement * DisplacementMagnitude) - CenterScaled;
		float4 NormalClip = Lerp(
			TransformedTri.Verts[0].NormalClip,
			TransformedTri.Verts[1].NormalClip,
			TransformedTri.Verts[2].NormalClip,
			Barycentrics).Value;
		float4 PointClip = BaseClip + NormalClip * Displacement;
		return PointClip;
	}
	bool EvaluatePixel( FBarycentrics Barycentrics, float4 SvPosition, bool bBackFace, inout FVisBufferPixel Pixel )
	{
		return true;
	}
};
groupshared uint GroupVsmPageTableCache[8 * 8];
void VsmPageTableStore(uint2 pPage, uint2 Coords)
{
	uint pPagePacked = (pPage.y << 16) | pPage.x;
	uint Index = Coords.y * 8 + Coords.x;
	GroupVsmPageTableCache[Index] = pPagePacked;
}
uint2 VsmPageTableLoad(uint2 Coords)
{
	uint Index = Coords.y * 8 + Coords.x;
	uint pPagePacked = GroupVsmPageTableCache[Index];
	return uint2(pPagePacked & 0xffff, pPagePacked >> 16);
}
void FetchAndCachePageTableEntry(FNaniteView NaniteView, uint2 vPageStart, uint2 vPageEnd, uint CacheIndex)
{
	uint2 CacheCoords = uint2(CacheIndex & 0x7, CacheIndex >> 3);
	if (all(vPageStart + CacheCoords <= vPageEnd))
	{
		FShadowPhysicalPage PhysicalPage = ShadowGetPhysicalPage( CalcPageOffset( NaniteView.TargetLayerIndex, NaniteView.TargetMipLevel, vPageStart + CacheCoords ) );
		uint2 pPageAddress = PhysicalPage.bThisLODValid ? PhysicalPage.PhysicalAddress : 0xffff;
		VsmPageTableStore(pPageAddress, CacheCoords);
	}
}
struct FCachedPageTable
{
	bool operator()( inout FVisBufferPixel Pixel )
	{
		uint2 pPage = VsmPageTableLoad(Pixel.Position / 128);
		if (pPage.x == 0xffff)
		{
			return false;
		}
		Pixel.PhysicalPosition.xy = pPage * 128 + (Pixel.Position & 127);
		return true;
	}
};
uint2 GetVisualizeValues(uint AddValue, uint SubPatch, uint MicroTri)
{
	uint VisualizeValueMax = 0;			
	uint VisualizeValueAdd = AddValue;	
	VisualizeValueMax = 3; 
	VisualizeValueMax |= (SubPatch & 0xffu) << 8u;
	VisualizeValueMax |= (MicroTri & 0xffu) << 16u;
	return uint2(VisualizeValueMax, VisualizeValueAdd);
}
uint2 GetVisualizeValues()
{
	return GetVisualizeValues(1u , 0u , 0u );
}
void RasterizeDicedTri(
	FRasterTri		Tri,
	FRaster			Raster,
	FMaterialShader	Shader,
	uint			PixelValue,
	uint2			VisualizeValues )
{
	if (!Raster.bSinglePage)
	{
		TNaniteWritePixel< FMaterialShader, FCachedPageTable > NaniteWritePixel = { Raster, Shader, PixelValue, VisualizeValues };
		RasterizeTri_Rect( Tri, NaniteWritePixel );
	}
	else
	{
		TNaniteWritePixel< FMaterialShader > NaniteWritePixel = { Raster, Shader, PixelValue, VisualizeValues };
		RasterizeTri_Rect( Tri, NaniteWritePixel );
	}
}
groupshared float4 GroupPointPackedClip[ 32 ];
groupshared float4 GroupNormalPackedClip[ 32 ];
struct FDiceTask
{
	FRaster			Raster;
	FMaterialShader	Shader;
	uint			PixelValue;
	uint2			VisualizeValues;
	float4			UVDensities;
	bool			bReverseWinding;
	FNaniteTransformedVert	Vert;
	FTessellatedPatch		TessellatedPatch;
	uint4	Encoded;
	uint	PatchData;
	float3 CachedPackedSubpixelPosition;
	void Init( float3 TessFactors, uint3 VertIndexes, uint TriIndex )
	{
		TessellatedPatch.Init( TessFactors, VertIndexes, true );
		PatchData  = VertIndexes.x << 0;
		PatchData |= VertIndexes.y << 8;
		PatchData |= VertIndexes.z << 16;
		PatchData |= TriIndex << 24;
		CachedPackedSubpixelPosition = 0.0f;
	}
	FDiceTask CreateChild( uint ParentLaneIndex )
	{
		FDiceTask ChildTask;
		ChildTask.Raster			= Raster;
		ChildTask.Shader			= Shader;
		ChildTask.PixelValue		= PixelValue;
		ChildTask.VisualizeValues	= VisualizeValues;
		ChildTask.UVDensities		= UVDensities;
		ChildTask.bReverseWinding	= bReverseWinding;
		ChildTask.TessellatedPatch	= WaveReadLaneAt( TessellatedPatch, ParentLaneIndex );
		ChildTask.Encoded			= WaveReadLaneAt( Encoded, ParentLaneIndex );
		ChildTask.PatchData			= WaveReadLaneAt( PatchData, ParentLaneIndex );
		uint3 PatchVertIndexes;
		PatchVertIndexes.x = ( ChildTask.PatchData >>  0 ) & 0xff;
		PatchVertIndexes.y = ( ChildTask.PatchData >>  8 ) & 0xff;
		PatchVertIndexes.z = ( ChildTask.PatchData >> 16 ) & 0xff;
		FNaniteTransformedTri TransformedTri = MakeTransformedNaniteTriangle( Vert, PatchVertIndexes );
		for (uint Corner = 0; Corner < 3; ++Corner)
		{
			const uint SourceIndex = PatchVertIndexes[ Corner ];
			TransformedTri.Verts[ Corner ].PointClip	= GroupPointPackedClip[ SourceIndex ];
			TransformedTri.Verts[ Corner ].NormalClip	= GroupNormalPackedClip[ SourceIndex ];
		}
		ChildTask.Shader.TransformedTri = TransformedTri;	
		return ChildTask;
	}
	void CacheToLDS()
	{
		const uint LaneIndex = WaveGetLaneIndex();
		GroupPointPackedClip[LaneIndex] = Vert.PointClip;
		GroupNormalPackedClip[LaneIndex] = Vert.NormalClip;
		GroupMemoryBarrierWithGroupSync();
	}
	void RunChild( inout FDiceTask ParentTask, bool bActive, uint LocalItemIndex );
};
void FDiceTask::RunChild( inout FDiceTask ParentTask, bool bActive, uint LocalItemIndex )
{
	uint PatchIndex = PatchData >> 24;
	uint3 VertIndexes = TessellatedPatch.GetIndexes( LocalItemIndex );
	if( bReverseWinding )
		VertIndexes.yz = VertIndexes.zy;
	float4 Verts[3];
	const float3 TessFactors = TessellatedPatch.GetTessFactors();
	FBarycentrics Barycentrics;
	Barycentrics.Value = TessellatedPatch.GetVert( LocalItemIndex );
	Barycentrics.Value_dx = 0;	
	Barycentrics.Value_dy = 0;	
	const bool bOrtho = IsOrthoProjection( Shader.NaniteView.ViewToClip );
	float3 CornerPackedSubpixel0;	
	[branch]
	if (bOrtho)
	{
		const float3 PointPackedClip = Shader.EvaluateDomain( UVDensities, Barycentrics ).xyz;
		CornerPackedSubpixel0 = PointPackedClip.xyz;
	}
	else
	{
		const float3 PointPackedClip = Shader.EvaluateDomain( UVDensities, Barycentrics ).xyw;
		CornerPackedSubpixel0 = float3( PointPackedClip.xy / PointPackedClip.z, PointPackedClip.z );
	}
	CornerPackedSubpixel0.xy = CornerPackedSubpixel0.xy * Raster.ViewportScale + Raster.ViewportBias;
	CornerPackedSubpixel0.xy = floor( CornerPackedSubpixel0.xy );
	const int3 RelativeVertIndexes = WaveGetLaneIndex() - ( LocalItemIndex - VertIndexes );	
	const uint3 ReadLaneIndex = uint3( RelativeVertIndexes ) & ( WaveGetLaneCount() - 1u );
	float3 CornerPackedSubpixel1 = WaveReadLaneAt( ParentTask.CachedPackedSubpixelPosition, ReadLaneIndex.y );
	float3 CornerPackedSubpixel2 = WaveReadLaneAt( ParentTask.CachedPackedSubpixelPosition, ReadLaneIndex.z );
	ParentTask.CachedPackedSubpixelPosition = CornerPackedSubpixel0;
	CornerPackedSubpixel1 =  select_internal( RelativeVertIndexes.y >= 0 , WaveReadLaneAt( ParentTask.CachedPackedSubpixelPosition, ReadLaneIndex.y ) , CornerPackedSubpixel1 );
	CornerPackedSubpixel2 =  select_internal( RelativeVertIndexes.z >= 0 , WaveReadLaneAt( ParentTask.CachedPackedSubpixelPosition, ReadLaneIndex.z ) , CornerPackedSubpixel2 );
	[branch]
	if (bOrtho)
	{
		Verts[0] = float4( CornerPackedSubpixel0, 1.0f );
		Verts[1] = float4( CornerPackedSubpixel1, 1.0f );
		Verts[2] = float4( CornerPackedSubpixel2, 1.0f );
	}
	else
	{
		Verts[0] = float4( CornerPackedSubpixel0.xy, float2( ClipZFromLinearZ( Shader.NaniteView, CornerPackedSubpixel0.z ), 1.0f ) / CornerPackedSubpixel0.z );
		Verts[1] = float4( CornerPackedSubpixel1.xy, float2( ClipZFromLinearZ( Shader.NaniteView, CornerPackedSubpixel1.z ), 1.0f ) / CornerPackedSubpixel1.z );
		Verts[2] = float4( CornerPackedSubpixel2.xy, float2( ClipZFromLinearZ( Shader.NaniteView, CornerPackedSubpixel2.z ), 1.0f ) / CornerPackedSubpixel2.z );
	}
	FRasterTri Tri = SetupTriangle< (1 << 8), !0 >( Raster.ScissorRect, Verts );
	if( !bActive || min3( Verts[0].w, Verts[1].w, Verts[2].w ) < 0 )
		Tri.bIsValid = false;
	if( Tri.bIsValid )
	{
		VisualizeValues.x = GetVisualizeValues(1u , 0u , LocalItemIndex);
		RasterizeDicedTri(
			Tri,
			Raster,
			Shader,
			PixelValue | PatchIndex,
			VisualizeValues );
	}
}
struct FClusterSplitTask
{
	FTessellatedPatch	TessellatedPatch;
	uint4	Encoded;
	void				Init( float3 TessFactors, uint VisibleClusterIndex, uint TriIndex );
	FClusterSplitTask	CreateChild( uint ParentLaneIndex );
	void				RunChild( inout FClusterSplitTask ParentTask, bool bActive, uint LocalItemIndex );
};
void FClusterSplitTask::Init( float3 TessFactors, uint VisibleClusterIndex, uint TriIndex )
{
	Encoded.x = ( VisibleClusterIndex << 7 ) | TriIndex;
	Encoded.y = BarycentricMax;
	Encoded.z = BarycentricMax << 16;
	Encoded.w = 0;
	TessellatedPatch.Init( TessFactors, Encoded.yzw, false );
}
FClusterSplitTask FClusterSplitTask::CreateChild( uint ParentLaneIndex )
{
	FClusterSplitTask ChildTask;
	ChildTask.TessellatedPatch	= WaveReadLaneAt( TessellatedPatch, ParentLaneIndex );
	ChildTask.Encoded			= WaveReadLaneAt( Encoded, ParentLaneIndex );
	return ChildTask;
}
void FClusterSplitTask::RunChild( inout FClusterSplitTask ParentTask, bool bActive, uint LocalItemIndex )
{
	if( !bActive )
		return;
	FSplitPatch Patch;
	Patch.Decode( Encoded );
	uint3 VertIndexes = TessellatedPatch.GetIndexes( LocalItemIndex );
	for( int i = 0; i < 3; i++ )
	{
		float3 Barycentrics = TessellatedPatch.GetVert( VertIndexes[i] );
		Barycentrics = 
			Patch.Barycentrics[0] * Barycentrics.x +
			Patch.Barycentrics[1] * Barycentrics.y +
			Patch.Barycentrics[2] * Barycentrics.z;
		Encoded[ i + 1 ] = EncodeBarycentrics( Barycentrics );
	}
	uint WriteOffset = SplitWorkQueue.Add();
	if( WriteOffset < SplitWorkQueue.Size )
	{
		 { };
		SplitWorkQueue.DataBuffer.Store4( WriteOffset * 16, Encoded );
	}
}
uint ActiveRasterBin;
StructuredBuffer<FNaniteRasterBinMeta> RasterBinMeta;
StructuredBuffer<uint2> RasterBinData;
uint4 FetchSWRasterBin(const uint ClusterIndex)
{
	const uint RasterBinOffset		= RasterBinMeta[ActiveRasterBin].ClusterOffset;
	const uint2 PackedData			= RasterBinData[RasterBinOffset + ClusterIndex].xy;
	const uint VisibleIndex			= PackedData.x;
	const uint RangeStart			= PackedData.y >> 16u;
	const uint RangeEnd				= PackedData.y & 0xFFFFu;
	return uint4(VisibleIndex, RangeStart, RangeEnd, RasterBinMeta[ActiveRasterBin].MaterialFlags);
}
ViewState ResolveView(FNaniteView NaniteView)
{
	ViewState Ret = ResolveView();
	Ret.SVPositionToTranslatedWorld	= NaniteView.SVPositionToTranslatedWorld;
	Ret.ViewToTranslatedWorld 		= NaniteView.ViewToTranslatedWorld;
	Ret.TranslatedWorldToView 		= NaniteView.TranslatedWorldToView;
	Ret.TranslatedWorldToClip 		= NaniteView.TranslatedWorldToClip;
	Ret.ViewToClip 					= NaniteView.ViewToClip;
	Ret.ClipToWorld 				= NaniteView.ClipToWorld;
	Ret.PrevTranslatedWorldToView 	= NaniteView.PrevTranslatedWorldToView;
	Ret.PrevTranslatedWorldToClip 	= NaniteView.PrevTranslatedWorldToClip;
	Ret.PrevViewToClip 				= NaniteView.PrevViewToClip;
	Ret.PrevClipToWorld 			= NaniteView.PrevClipToWorld;
	Ret.ViewRectMin					= (float4)NaniteView.ViewRect;
	Ret.ViewSizeAndInvSize 			= NaniteView.ViewSizeAndInvSize;
	Ret.PreViewTranslation 			= NaniteView.PreViewTranslation;
	Ret.PrevPreViewTranslation 		= NaniteView.PrevPreViewTranslation;
	Ret.ViewForward 				= NaniteView.ViewForward;
	Ret.ViewOriginHigh 				= NaniteView.ViewOriginHigh;
	Ret.NearPlane 					= NaniteView.NearPlane;
	Ret.WorldCameraOrigin = DFFastSubtract(NaniteView.CullingViewOriginTranslatedWorld, NaniteView.PreViewTranslation);
	Ret.TileOffset.PreViewTranslation = DFToTileOffset(Ret.PreViewTranslation);
	Ret.TileOffset.PrevPreViewTranslation = DFToTileOffset(Ret.PrevPreViewTranslation);
	Ret.TileOffset.WorldCameraOrigin = DFToTileOffset(Ret.WorldCameraOrigin);
	return Ret;
}
bool ReverseWindingOrder(FNaniteView NaniteView, FPrimitiveSceneData PrimitiveData, FInstanceSceneData InstanceData)
{
	float DeterminantSign = InstanceData.DeterminantSign;
	bool bReverseInstanceCull = (DeterminantSign < 0.0f);
	bool bViewReverseCull = (NaniteView.Flags & 0x10);
	return (bReverseInstanceCull != bViewReverseCull);
}
FRaster CreateRaster( FNaniteView NaniteView, FInstanceSceneData InstanceData, FVisibleCluster VisibleCluster )
{
	FRaster Raster;
	Raster.ScissorRect = NaniteView.ViewRect;
	Raster.ViewportScale = float2(0.5, -0.5) * NaniteView.ViewSizeAndInvSize.xy;
	Raster.ViewportBias = 0.5 * NaniteView.ViewSizeAndInvSize.xy + NaniteView.ViewRect.xy;
	Raster.vPage = VisibleCluster.vPage;
	Raster.pPage = 0;
	Raster.bSinglePage = all( VisibleCluster.vPage == VisibleCluster.vPageEnd );
	if (Raster.bSinglePage)
	{
		FShadowPhysicalPage PhysicalPage = ShadowGetPhysicalPage( CalcPageOffset( NaniteView.TargetLayerIndex, NaniteView.TargetMipLevel, Raster.vPage ) );
		Raster.pPage = PhysicalPage.bThisLODValid ? PhysicalPage.PhysicalAddress : 0xffff;
	}
	const bool bCacheAsStatic = (VisibleCluster.Flags & 0x4) != 0u;
	Raster.ArrayIndex = bCacheAsStatic ? GetVirtualShadowMapStaticArrayIndex() : 0;
	if (!Raster.bSinglePage)
	{
		Raster.ScissorRect.xy = 0;
		Raster.ScissorRect.zw = (VisibleCluster.vPageEnd - VisibleCluster.vPage) * 128 + 128;
	}
	else
	{
		Raster.ScissorRect.xy = Raster.pPage * 128;
		Raster.ScissorRect.zw = Raster.ScissorRect.xy + 128;
	}
	Raster.vTranslation = ( (float2)Raster.pPage - (float2)Raster.vPage ) * 128;
	Raster.ViewportBias += Raster.vTranslation;
	Raster.ViewportScale *= (1 << 8);
	Raster.ViewportBias  *= (1 << 8);
	Raster.ViewportBias  += 0.5f;
	return Raster;
}
groupshared float3 GroupVerts[120];
void PatchRasterize( uint GroupID, uint GroupThreadIndex ) 
{
	if(GroupThreadIndex >= WaveGetLaneCount())	
	{
		return;
	}
	const uint ThreadGroupSize	= min(32, WaveGetLaneCount());
	const uint TotalPatches		= RasterBinMeta[ActiveRasterBin].BinSWCount;
	const uint PatchStartIndex	= min(GroupID * MaxPatchesPerGroup, TotalPatches);
	const uint PatchEndIndex	= min(PatchStartIndex + MaxPatchesPerGroup, TotalPatches);
	const uint NumPatches		= PatchEndIndex - PatchStartIndex;
	uint4					Patches_EncodedPatch;
	bool					Patches_bReverseWindingOrders;
	FInstanceSceneData		Patches_InstanceData;
	FInstanceDynamicData	Patches_InstanceDynamicData;
	FSplitPatch				Patches_SplitPatch;
	FTessellatedPatch		Patches_TessellatedPatch;
	FNaniteVertTransforms	Patches_VertTransforms;
	FNaniteTransformedVert	Patches_Verts;
	float4					Patches_UVDensities;
	if (GroupThreadIndex < NumPatches * 3u)
	{
		const uint LocalPatchIndex = GroupThreadIndex / 3u;
		const uint PatchCornerIndex = GroupThreadIndex - LocalPatchIndex * 3u;
		const uint PatchIndex = PatchStartIndex + LocalPatchIndex;
		const uint PatchStartLane = LocalPatchIndex * 3;
		const uint4 RasterBin = FetchSWRasterBin(PatchIndex);
		const uint VisibleIndex = RasterBin.x;
		const uint2 VisiblePatch = VisiblePatches.Load2(VisibleIndex * 8);
		Patches_EncodedPatch = SplitWorkQueue.DataBuffer.Load4(VisiblePatch.x * 16);
		Patches_SplitPatch.Decode(Patches_EncodedPatch);
		const FVisibleCluster VisibleCluster = GetVisibleCluster(Patches_SplitPatch.VisibleClusterIndex, 1);
		const FCluster Cluster = GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);
		FPrimitiveSceneData PrimitiveData;
		GetNaniteMaterialSceneData(VisibleCluster, PrimitiveData, Patches_InstanceData);
		const FNaniteView NaniteView = GetNaniteView(VisibleCluster.ViewId);
		ResolvedView = ResolveView(NaniteView);
		Patches_InstanceDynamicData = CalculateInstanceDynamicData(NaniteView, Patches_InstanceData);
		Patches_bReverseWindingOrders = ReverseWindingOrder(NaniteView, PrimitiveData, Patches_InstanceData);
		Patches_VertTransforms = CalculateNaniteVertexTransforms(Patches_InstanceData, Patches_InstanceDynamicData, NaniteView);
		const bool bEvaluateWPO = (VisibleCluster.Flags & 0x8) != 0;
		const uint3 VertIndexes = DecodeTriangleIndices(Cluster, Patches_SplitPatch.TriIndex);
		Patches_Verts = FetchTransformedNaniteVertex(PrimitiveData, Patches_InstanceData, Patches_VertTransforms, Cluster, VertIndexes[PatchCornerIndex], bEvaluateWPO);
		Patches_UVDensities = GetMaterialUVDensities(Cluster, Patches_InstanceData.PrimitiveId, Patches_SplitPatch.TriIndex);
		Patches_TessellatedPatch.Init(VisiblePatch.y, false);
	}
	for (uint i = 0; i < NumPatches; i++)
	{
		const uint PatchStartLane						= i * 3;
		const bool bReverseWindingOrder					= WaveReadLaneAt(Patches_bReverseWindingOrders, PatchStartLane);
		const FSplitPatch SplitPatch					= WaveReadLaneAt(Patches_SplitPatch, PatchStartLane);
		const FTessellatedPatch TessellatedPatch		= WaveReadLaneAt(Patches_TessellatedPatch, PatchStartLane);
		const float4 UVDensities						= WaveReadLaneAt(Patches_UVDensities, PatchStartLane);
		const FInstanceSceneData InstanceData			= WaveReadLaneAt(Patches_InstanceData, PatchStartLane);
		const FInstanceDynamicData InstanceDynamicData	= WaveReadLaneAt(Patches_InstanceDynamicData, PatchStartLane);
		const FNaniteVertTransforms	VertTransforms		= WaveReadLaneAt(Patches_VertTransforms, PatchStartLane);
		const uint4 PatchEncoded						= WaveReadLaneAt(Patches_EncodedPatch, PatchStartLane);
		const FVisibleCluster VisibleCluster			= GetVisibleCluster(SplitPatch.VisibleClusterIndex, 1);
		const FCluster Cluster							= GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);
		const FNaniteView NaniteView					= GetNaniteView(VisibleCluster.ViewId);
		ResolvedView = ResolveView(NaniteView);
		FMaterialShader MaterialShader;
		MaterialShader.InstanceData = InstanceData;
		MaterialShader.InstanceDynamicData = InstanceDynamicData;
		MaterialShader.NaniteView = NaniteView;
		MaterialShader.Cluster = Cluster;
		MaterialShader.VertTransforms = VertTransforms;
		MaterialShader.TransformedTri = MakeTransformedNaniteTriangle(Patches_Verts, PatchStartLane + uint3(0, 1, 2));
		MaterialShader.DisplacementCenter = RasterBinMeta[ActiveRasterBin].MaterialDisplacementCenter;
		MaterialShader.DisplacementMagnitude = RasterBinMeta[ActiveRasterBin].MaterialDisplacementMagnitude;
		uint PixelValue = (SplitPatch.VisibleClusterIndex + 1) << 7;
		uint NumVerts = TessellatedPatch.GetNumVerts();
		uint NumTris = TessellatedPatch.GetNumTris();
		FRaster Raster = CreateRaster( NaniteView, InstanceData, VisibleCluster );
		GroupMemoryBarrierWithGroupSync();
		if (!Raster.bSinglePage)
		{
			for (uint Offset = 0; Offset < 8 * 8; Offset += ThreadGroupSize)
			{
				FetchAndCachePageTableEntry(NaniteView, VisibleCluster.vPage, VisibleCluster.vPageEnd, Offset + GroupThreadIndex);
			}
			GroupMemoryBarrierWithGroupSync();
		}
		for( uint VertIndex = GroupThreadIndex; VertIndex < NumVerts; VertIndex += ThreadGroupSize )
		{
			FBarycentrics Barycentrics;
			Barycentrics.Value	= TessellatedPatch.GetVert( VertIndex );
			Barycentrics.Value_dx	= 0;
			Barycentrics.Value_dy	= 0;
			Barycentrics = SplitPatch.TransformBarycentrics( Barycentrics );
			GroupVerts[ VertIndex ] = CalculateSubpixelCoordinates( Raster, MaterialShader.EvaluateDomain( UVDensities, Barycentrics ) ).xyz;
		}
		GroupMemoryBarrierWithGroupSync();
		for( uint TriIndex = GroupThreadIndex; TriIndex < NumTris; TriIndex += ThreadGroupSize )
		{
			uint3 VertIndexes = TessellatedPatch.GetIndexes( TriIndex );
			if( bReverseWindingOrder )
				VertIndexes.yz = VertIndexes.zy;
			float4 Verts[3];
			Verts[0] = float4( GroupVerts[ VertIndexes.x ], 1 );
			Verts[1] = float4( GroupVerts[ VertIndexes.y ], 1 );
			Verts[2] = float4( GroupVerts[ VertIndexes.z ], 1 );
			FRasterTri Tri = SetupTriangle< (1 << 8), !0 >( Raster.ScissorRect, Verts );
			if( max3( Verts[0].z, Verts[1].z, Verts[2].z ) > 1 )
				Tri.bIsValid = false;
			if( Tri.bIsValid )
			{
				const uint SubPatch = (Rand3DPCG32(PatchEncoded.yzw).x & 0xff0000u) >> 16u;
				const uint MicroTri = TriIndex & 0xffu;
				const uint2 VisualizeValues = GetVisualizeValues(1u , SubPatch, MicroTri);
				RasterizeDicedTri(
					Tri,
					Raster,
					MaterialShader,
					PixelValue | SplitPatch.TriIndex,
					VisualizeValues );
			}
		}
	}
}
[numthreads(32, 1, 1)]
void MicropolyRasterize(
	uint DispatchThreadID	: SV_DispatchThreadID,
	uint GroupID			: SV_GroupID,
	uint GroupIndex			: SV_GroupIndex) 
{
	PatchRasterize( GroupID, GroupIndex );
}

/* BASE64_ENV
CAAAABkAAABWSUVXX0hBU19USUxFT0ZGU0VUX0RBVEEAAAEAAAAeAAAAUFJJTUlUSVZFX0hBU19USUxFT0ZGU0VUX0RBVEEAAAEAAAARAAAASU5TVEFOQ0VEX1NURVJFTwAAAAAAAAsAAABNVUxUSV9WSUVXAAAAAAAAEgAAAE1PQklMRV9NVUxUSV9WSUVXAAAAAAAAGwAAAFVTRVNfV09STERfUE9TSVRJT05fT0ZGU0VUAAAAAAAAEgAAAFVTRVNfRElTUExBQ0VNRU5UAAABAAAAHAAAAFVTSU5HX1ZBUklBQkxFX1JBVEVfU0hBRElORwAAAQAAAAAQECEEAAAAAAAAAA4BAAAECAAABAgBAAQFAgAEBQMABAUEAAQFBQAEBQYABAUHAAQFCAAEBQkABAUKAAQFCwAECAwABAgNAAQIDgAECA8ABAgQAAQIEQAECBIABAgTAAQIFAAEBRUABAUWAAQFFwAEBRgABAgZAAQIGgAECBsABAUcAAQIHQAEBR4ABAgfAAQFIAAECCEABAUiAAQIIwAEBSQABAglAAQFJgAECCcABAgoAAQIKQAECCoABAgrAAQILAAECC0ABAUuAAQILwAEBjAABAUxAAQIMgAEBTMABAg0AAQFNQAECDYABAU3AAQIOAAEBTkABAg6AAQFOwAECDwABAU9AAQIPgAEBT8ABAhAAAQFQQAECEIABAVDAAQIRAAEBUUABAVGAAQFRwAEBUgABAhJAAQFSgAECEsABAVMAAQITQAEBU4ABAhPAAQFUAAECFEABAhSAAQFUwAECFQABAVVAAQIVgAEBlcABAZYAAQFWQAECFoABAVbAAQIXAAECF0ABAZeAAQGXwAEB2AABAZhAAkJAAAJCQEACQkCAAkJAwAJEAQACRAFAA8QAAAPEAEABRAAAAUQAQAFEAIABRADAAUQBAAFEAUABRAGAAUMBwAFDAgABQgJABAQAAAGEAAABhABAAYQAgAGEAMABgYEAAYJBQAGCQYABgkHAAYJCAAGEAkABhAKAAYQCwAGEAwABhANABAGAAAQBgEAEAYCABAQAAAQEAEAEBACABAQAwAQCQQAEBAFABAQBgAQEAcADQUAAAoGAAAKBgEACgYCAAoGAwAXBQAAFwgBABcFAgAXCAMAEwkAABMJAQATCQIAEwkDABMJBAATCQUAEwkGABMJBwATCQgAEwkJABMJCgATCQsAEwwMABMIDQAQCQAAEAgBABAJAgAQCAMAEAkEABAMBQAQCAYAEAkHABAICAAQBQkAEAUKABMJAAATCAEAEwkCABMJAwATCAQAEwkFABMIBgATCQcAEwgIABMMCQATCQoAEwgLABMJDAATCQ0AEwkOABMJDwATCRAAEwkRABMJEgATCRMAEwgUABMIFQATCBYAEwgXABMIGAAJBQAACQUBAAgJAAAICAEACAUCAAgIAwAIEAQACBAFAAgQBgAIEAcACAkIAAgICQAIBQoACAgLAAgQDAAIEA0ACBAOAAgQDwAICRAACAgRAAgFEgAICBMACAUUAAgIFQAIBRYACAgXAAgFGAAICBkACAUaAAgIGwAICRwACAgdAAgFHgAICB8ACAkgAAgIIQAIECIACAwjAAgJJAAIECUACAgmAAgFAAAICAEACAUCAAgIAwAIBQQACAgFAAgFBgAICAcACAUIAAgICQAIBQoACAgLAAgFDAAICA0ACAUOAAgIDwAIBRAACAgRAAgFEgAICBMACAUUAAgIFQAIBRYACAgXAAgFGAAICBkACAgaAAgIGwAaAAAABQAAAFZpZXcABQAAAFZpZXcAGgJoFQMAAAAA8AwAAFYAaQBlAHcAXwBNAGEAdABlAHIAaQBhAGwAVABlAHgAdAB1AHIAZQBCAGkAbABpAG4AZQBhAHIAVwByAGEAcABlAGQAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBNAGEAdABlAHIAaQBhAGwAVABlAHgAdAB1AHIAZQBCAGkAbABpAG4AZQBhAHIAQwBsAGEAbQBwAGUAZABTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFYAbwBsAHUAbQBlAHQAcgBpAGMATABpAGcAaAB0AG0AYQBwAEkAbgBkAGkAcgBlAGMAdABpAG8AbgBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFYAbwBsAHUAbQBlAHQAcgBpAGMATABpAGcAaAB0AG0AYQBwAEIAcgBpAGMAawBBAG0AYgBpAGUAbgB0AFYAZQBjAHQAbwByAAAAVgBpAGUAdwBfAFYAbwBsAHUAbQBlAHQAcgBpAGMATABpAGcAaAB0AG0AYQBwAEIAcgBpAGMAawBTAEgAQwBvAGUAZgBmAGkAYwBpAGUAbgB0AHMAMAAAAFYAaQBlAHcAXwBWAG8AbAB1AG0AZQB0AHIAaQBjAEwAaQBnAGgAdABtAGEAcABCAHIAaQBjAGsAUwBIAEMAbwBlAGYAZgBpAGMAaQBlAG4AdABzADEAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAQgByAGkAYwBrAFMASABDAG8AZQBmAGYAaQBjAGkAZQBuAHQAcwAyAAAAVgBpAGUAdwBfAFYAbwBsAHUAbQBlAHQAcgBpAGMATABpAGcAaAB0AG0AYQBwAEIAcgBpAGMAawBTAEgAQwBvAGUAZgBmAGkAYwBpAGUAbgB0AHMAMwAAAFYAaQBlAHcAXwBWAG8AbAB1AG0AZQB0AHIAaQBjAEwAaQBnAGgAdABtAGEAcABCAHIAaQBjAGsAUwBIAEMAbwBlAGYAZgBpAGMAaQBlAG4AdABzADQAAABWAGkAZQB3AF8AVgBvAGwAdQBtAGUAdAByAGkAYwBMAGkAZwBoAHQAbQBhAHAAQgByAGkAYwBrAFMASABDAG8AZQBmAGYAaQBjAGkAZQBuAHQAcwA1AAAAVgBpAGUAdwBfAFMAawB5AEIAZQBuAHQATgBvAHIAbQBhAGwAQgByAGkAYwBrAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8ARABpAHIAZQBjAHQAaQBvAG4AYQBsAEwAaQBnAGgAdABTAGgAYQBkAG8AdwBpAG4AZwBCAHIAaQBjAGsAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBWAG8AbAB1AG0AZQB0AHIAaQBjAEwAaQBnAGgAdABtAGEAcABCAHIAaQBjAGsAQQBtAGIAaQBlAG4AdABWAGUAYwB0AG8AcgBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFYAbwBsAHUAbQBlAHQAcgBpAGMATABpAGcAaAB0AG0AYQBwAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAwAAAAVgBpAGUAdwBfAFYAbwBsAHUAbQBlAHQAcgBpAGMATABpAGcAaAB0AG0AYQBwAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAxAAAAVgBpAGUAdwBfAFYAbwBsAHUAbQBlAHQAcgBpAGMATABpAGcAaAB0AG0AYQBwAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAyAAAAVgBpAGUAdwBfAFYAbwBsAHUAbQBlAHQAcgBpAGMATABpAGcAaAB0AG0AYQBwAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAzAAAAVgBpAGUAdwBfAFYAbwBsAHUAbQBlAHQAcgBpAGMATABpAGcAaAB0AG0AYQBwAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgA0AAAAVgBpAGUAdwBfAFYAbwBsAHUAbQBlAHQAcgBpAGMATABpAGcAaAB0AG0AYQBwAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgA1AAAAVgBpAGUAdwBfAFMAawB5AEIAZQBuAHQATgBvAHIAbQBhAGwAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAEQAaQByAGUAYwB0AGkAbwBuAGEAbABMAGkAZwBoAHQAUwBoAGEAZABvAHcAaQBuAGcAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAEcAbABvAGIAYQBsAEQAaQBzAHQAYQBuAGMAZQBGAGkAZQBsAGQAUABhAGcAZQBBAHQAbABhAHMAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBHAGwAbwBiAGEAbABEAGkAcwB0AGEAbgBjAGUARgBpAGUAbABkAEMAbwB2AGUAcgBhAGcAZQBBAHQAbABhAHMAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBHAGwAbwBiAGEAbABEAGkAcwB0AGEAbgBjAGUARgBpAGUAbABkAFAAYQBnAGUAVABhAGIAbABlAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8ARwBsAG8AYgBhAGwARABpAHMAdABhAG4AYwBlAEYAaQBlAGwAZABNAGkAcABUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEcAbABvAGIAYQBsAEQAaQBzAHQAYQBuAGMAZQBGAGkAZQBsAGQAUABhAGcAZQBBAHQAbABhAHMAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAEcAbABvAGIAYQBsAEQAaQBzAHQAYQBuAGMAZQBGAGkAZQBsAGQAQwBvAHYAZQByAGEAZwBlAEEAdABsAGEAcwBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8ARwBsAG8AYgBhAGwARABpAHMAdABhAG4AYwBlAEYAaQBlAGwAZABNAGkAcABUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AQQB0AG0AbwBzAHAAaABlAHIAZQBUAHIAYQBuAHMAbQBpAHQAdABhAG4AYwBlAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AQQB0AG0AbwBzAHAAaABlAHIAZQBUAHIAYQBuAHMAbQBpAHQAdABhAG4AYwBlAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBBAHQAbQBvAHMAcABoAGUAcgBlAEkAcgByAGEAZABpAGEAbgBjAGUAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBBAHQAbQBvAHMAcABoAGUAcgBlAEkAcgByAGEAZABpAGEAbgBjAGUAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAEEAdABtAG8AcwBwAGgAZQByAGUASQBuAHMAYwBhAHQAdABlAHIAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBBAHQAbQBvAHMAcABoAGUAcgBlAEkAbgBzAGMAYQB0AHQAZQByAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBQAGUAcgBsAGkAbgBOAG8AaQBzAGUARwByAGEAZABpAGUAbgB0AFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUABlAHIAbABpAG4ATgBvAGkAcwBlAEcAcgBhAGQAaQBlAG4AdABUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUABlAHIAbABpAG4ATgBvAGkAcwBlADMARABUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFAAZQByAGwAaQBuAE4AbwBpAHMAZQAzAEQAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAbwBiAG8AbABTAGEAbQBwAGwAaQBuAGcAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBTAGgAYQByAGUAZABQAG8AaQBuAHQAVwByAGEAcABwAGUAZABTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAaABhAHIAZQBkAFAAbwBpAG4AdABDAGwAYQBtAHAAZQBkAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUwBoAGEAcgBlAGQAQgBpAGwAaQBuAGUAYQByAFcAcgBhAHAAcABlAGQAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBTAGgAYQByAGUAZABCAGkAbABpAG4AZQBhAHIAQwBsAGEAbQBwAGUAZABTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAaABhAHIAZQBkAEIAaQBsAGkAbgBlAGEAcgBBAG4AaQBzAG8AQwBsAGEAbQBwAGUAZABTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAaABhAHIAZQBkAFQAcgBpAGwAaQBuAGUAYQByAFcAcgBhAHAAcABlAGQAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBTAGgAYQByAGUAZABUAHIAaQBsAGkAbgBlAGEAcgBDAGwAYQBtAHAAZQBkAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AUAByAGUASQBuAHQAZQBnAHIAYQB0AGUAZABCAFIARABGAAAAVgBpAGUAdwBfAFAAcgBlAEkAbgB0AGUAZwByAGEAdABlAGQAQgBSAEQARgBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAawB5AEkAcgByAGEAZABpAGEAbgBjAGUARQBuAHYAaQByAG8AbgBtAGUAbgB0AE0AYQBwAAAAVgBpAGUAdwBfAFQAcgBhAG4AcwBtAGkAdAB0AGEAbgBjAGUATAB1AHQAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBUAHIAYQBuAHMAbQBpAHQAdABhAG4AYwBlAEwAdQB0AFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBTAGsAeQBWAGkAZQB3AEwAdQB0AFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUwBrAHkAVgBpAGUAdwBMAHUAdABUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8ARABpAHMAdABhAG4AdABTAGsAeQBMAGkAZwBoAHQATAB1AHQAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBEAGkAcwB0AGEAbgB0AFMAawB5AEwAaQBnAGgAdABMAHUAdABUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AQwBhAG0AZQByAGEAQQBlAHIAaQBhAGwAUABlAHIAcwBwAGUAYwB0AGkAdgBlAFYAbwBsAHUAbQBlAAAAVgBpAGUAdwBfAEMAYQBtAGUAcgBhAEEAZQByAGkAYQBsAFAAZQByAHMAcABlAGMAdABpAHYAZQBWAG8AbAB1AG0AZQBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAEMAYQBtAGUAcgBhAEEAZQByAGkAYQBsAFAAZQByAHMAcABlAGMAdABpAHYAZQBWAG8AbAB1AG0AZQBNAGkAZQBPAG4AbAB5AAAAVgBpAGUAdwBfAEMAYQBtAGUAcgBhAEEAZQByAGkAYQBsAFAAZQByAHMAcABlAGMAdABpAHYAZQBWAG8AbAB1AG0AZQBNAGkAZQBPAG4AbAB5AFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AQwBhAG0AZQByAGEAQQBlAHIAaQBhAGwAUABlAHIAcwBwAGUAYwB0AGkAdgBlAFYAbwBsAHUAbQBlAFIAYQB5AE8AbgBsAHkAAABWAGkAZQB3AF8AQwBhAG0AZQByAGEAQQBlAHIAaQBhAGwAUABlAHIAcwBwAGUAYwB0AGkAdgBlAFYAbwBsAHUAbQBlAFIAYQB5AE8AbgBsAHkAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBIAGEAaQByAFMAYwBhAHQAdABlAHIAaQBuAGcATABVAFQAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBIAGEAaQByAFMAYwBhAHQAdABlAHIAaQBuAGcATABVAFQAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBHAEcAWABMAFQAQwBNAGEAdABUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAEcARwBYAEwAVABDAE0AYQB0AFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8ARwBHAFgATABUAEMAQQBtAHAAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBHAEcAWABMAFQAQwBBAG0AcABTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAaABlAGUAbgBMAFQAQwBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFMAaABlAGUAbgBMAFQAQwBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAaABhAGQAaQBuAGcARQBuAGUAcgBnAHkARwBHAFgAUwBwAGUAYwBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFMAaABhAGQAaQBuAGcARQBuAGUAcgBnAHkARwBHAFgARwBsAGEAcwBzAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUwBoAGEAZABpAG4AZwBFAG4AZQByAGcAeQBDAGwAbwB0AGgAUwBwAGUAYwBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFMAaABhAGQAaQBuAGcARQBuAGUAcgBnAHkARABpAGYAZgB1AHMAZQBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFMAaABhAGQAaQBuAGcARQBuAGUAcgBnAHkAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBHAGwAaQBuAHQAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBHAGwAaQBuAHQAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBTAGkAbQBwAGwAZQBWAG8AbAB1AG0AZQBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFMAaQBtAHAAbABlAFYAbwBsAHUAbQBlAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBTAGkAbQBwAGwAZQBWAG8AbAB1AG0AZQBFAG4AdgBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFMAaQBtAHAAbABlAFYAbwBsAHUAbQBlAEUAbgB2AFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBTAFMAUAByAG8AZgBpAGwAZQBzAFQAZQB4AHQAdQByAGUAAABWAGkAZQB3AF8AUwBTAFAAcgBvAGYAaQBsAGUAcwBTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAFMAUwBQAHIAbwBmAGkAbABlAHMAVAByAGEAbgBzAG0AaQBzAHMAaQBvAG4AUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBTAFMAUAByAG8AZgBpAGwAZQBzAFAAcgBlAEkAbgB0AGUAZwByAGEAdABlAGQAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBTAFMAUAByAG8AZgBpAGwAZQBzAFAAcgBlAEkAbgB0AGUAZwByAGEAdABlAGQAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBTAHAAZQBjAHUAbABhAHIAUAByAG8AZgBpAGwAZQBUAGUAeAB0AHUAcgBlAAAAVgBpAGUAdwBfAFMAcABlAGMAdQBsAGEAcgBQAHIAbwBmAGkAbABlAFMAYQBtAHAAbABlAHIAAABWAGkAZQB3AF8AVwBhAHQAZQByAEkAbgBkAGkAcgBlAGMAdABpAG8AbgAAAFYAaQBlAHcAXwBXAGEAdABlAHIARABhAHQAYQAAAFYAaQBlAHcAXwBSAGUAYwB0AEwAaQBnAGgAdABBAHQAbABhAHMAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBSAGUAYwB0AEwAaQBnAGgAdABBAHQAbABhAHMAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBJAEUAUwBBAHQAbABhAHMAVABlAHgAdAB1AHIAZQAAAFYAaQBlAHcAXwBJAEUAUwBBAHQAbABhAHMAUwBhAG0AcABsAGUAcgAAAFYAaQBlAHcAXwBMAGEAbgBkAHMAYwBhAHAAZQBXAGUAaQBnAGgAdABtAGEAcABTAGEAbQBwAGwAZQByAAAAVgBpAGUAdwBfAEwAYQBuAGQAcwBjAGEAcABlAEkAbgBkAGkAcgBlAGMAdABpAG8AbgAAAFYAaQBlAHcAXwBMAGEAbgBkAHMAYwBhAHAAZQBQAGUAcgBDAG8AbQBwAG8AbgBlAG4AdABEAGEAdABhAAAAVgBpAGUAdwBfAFYAVABGAGUAZQBkAGIAYQBjAGsAQgB1AGYAZgBlAHIAAABWAGkAZQB3AF8AUABoAHkAcwBpAGMAcwBGAGkAZQBsAGQAQwBsAGkAcABtAGEAcABCAHUAZgBmAGUAcgAAABgAAABEcmF3UmVjdGFuZ2xlUGFyYW1ldGVycwAAAAAAAAEwAAEAAAAAAAAAAAoAAABTdWJzdHJhdGUAAAAAAEERcAkBAAAAALwAAABTAHUAYgBzAHQAcgBhAHQAZQBfAE0AYQB0AGUAcgBpAGEAbABUAGUAeAB0AHUAcgBlAEEAcgByAGEAeQAAAFMAdQBiAHMAdAByAGEAdABlAF8AVABvAHAATABhAHkAZQByAFQAZQB4AHQAdQByAGUAAABTAHUAYgBzAHQAcgBhAHQAZQBfAE8AcABhAHEAdQBlAFIAbwB1AGcAaABSAGUAZgByAGEAYwB0AGkAbwBuAFQAZQB4AHQAdQByAGUAAABTAHUAYgBzAHQAcgBhAHQAZQBfAEMAbABvAHMAdQByAGUATwBmAGYAcwBlAHQAVABlAHgAdAB1AHIAZQAAAFMAdQBiAHMAdAByAGEAdABlAF8AQwBsAG8AcwB1AHIAZQBUAGkAbABlAEIAdQBmAGYAZQByAAAAUwB1AGIAcwB0AHIAYQB0AGUAXwBDAGwAbwBzAHUAcgBlAFQAaQBsAGUAQwBvAHUAbgB0AEIAdQBmAGYAZQByAAAADgAAAEluc3RhbmNlZFZpZXcADgAAAEluc3RhbmNlZFZpZXcAAQOwHAMAAAAAAAAAABAAAABJbnN0YW5jZUN1bGxpbmcAFgAAAEluc3RhbmNlQ3VsbGluZ1ViU2xvdAAZAjAAAgAAAABBAAAASQBuAHMAdABhAG4AYwBlAEMAdQBsAGwAaQBuAGcAXwBJAG4AcwB0AGEAbgBjAGUASQBkAHMAQgB1AGYAZgBlAHIAAABJAG4AcwB0AGEAbgBjAGUAQwB1AGwAbABpAG4AZwBfAFAAYQBnAGUASQBuAGYAbwBCAHUAZgBmAGUAcgAAAAoAAABQcmltaXRpdmUAAAAAAAABAAMBAAAAAAAAAAAGAAAAU2NlbmUABgAAAFNjZW5lAFEfjAADAAAAAHUBAABTAGMAZQBuAGUAXwBHAFAAVQBTAGMAZQBuAGUAXwBHAFAAVQBTAGMAZQBuAGUASQBuAHMAdABhAG4AYwBlAFMAYwBlAG4AZQBEAGEAdABhAAAAUwBjAGUAbgBlAF8ARwBQAFUAUwBjAGUAbgBlAF8ARwBQAFUAUwBjAGUAbgBlAEkAbgBzAHQAYQBuAGMAZQBQAGEAeQBsAG8AYQBkAEQAYQB0AGEAAABTAGMAZQBuAGUAXwBHAFAAVQBTAGMAZQBuAGUAXwBHAFAAVQBTAGMAZQBuAGUAUAByAGkAbQBpAHQAaQB2AGUAUwBjAGUAbgBlAEQAYQB0AGEAAABTAGMAZQBuAGUAXwBHAFAAVQBTAGMAZQBuAGUAXwBHAFAAVQBTAGMAZQBuAGUATABpAGcAaAB0AG0AYQBwAEQAYQB0AGEAAABTAGMAZQBuAGUAXwBHAFAAVQBTAGMAZQBuAGUAXwBHAFAAVQBTAGMAZQBuAGUATABpAGcAaAB0AEQAYQB0AGEAAABTAGMAZQBuAGUAXwBOAGEAbgBpAHQAZQBNAGEAdABlAHIAaQBhAGwAcwBfAFAAcgBpAG0AaQB0AGkAdgBlAE0AYQB0AGUAcgBpAGEAbABEAGEAdABhAAAAUwBjAGUAbgBlAF8ATgBhAG4AaQB0AGUATQBhAHQAZQByAGkAYQBsAHMAXwBNAGEAdABlAHIAaQBhAGwARABhAHQAYQAAAFMAYwBlAG4AZQBfAFMAcABsAGkAbgBlAE0AZQBzAGgAXwBTAHAAbABpAG4AZQBQAG8AcwBUAGUAeAB0AHUAcgBlAAAAUwBjAGUAbgBlAF8AUwBwAGwAaQBuAGUATQBlAHMAaABfAFMAcABsAGkAbgBlAFIAbwB0AFQAZQB4AHQAdQByAGUAAABTAGMAZQBuAGUAXwBTAHAAbABpAG4AZQBNAGUAcwBoAF8AUwBwAGwAaQBuAGUAUwBhAG0AcABsAGUAcgAAABEAAABCYXRjaGVkUHJpbWl0aXZlABEAAABCYXRjaGVkUHJpbWl0aXZlABEDEAADAQAAABYAAABCAGEAdABjAGgAZQBkAFAAcgBpAG0AaQB0AGkAdgBlAF8ARABhAHQAYQAAAAcAAABOYW5pdGUABwAAAE5hbml0ZQA4HdkJAgAAAABCAQAATgBhAG4AaQB0AGUAXwBDAGwAdQBzAHQAZQByAFAAYQBnAGUARABhAHQAYQAAAE4AYQBuAGkAdABlAF8AVgBpAHMAaQBiAGwAZQBDAGwAdQBzAHQAZQByAHMAUwBXAEgAVwAAAE4AYQBuAGkAdABlAF8ASABpAGUAcgBhAHIAYwBoAHkAQgB1AGYAZgBlAHIAAABOAGEAbgBpAHQAZQBfAE0AYQB0AGUAcgBpAGEAbABUAGkAbABlAFIAZQBtAGEAcAAAAE4AYQBuAGkAdABlAF8ATQBhAHQAZQByAGkAYQBsAEQAZQBwAHQAaABUAGEAYgBsAGUAAABOAGEAbgBpAHQAZQBfAFMAaABhAGQAaQBuAGcATQBhAHMAawAAAE4AYQBuAGkAdABlAF8AVgBpAHMAQgB1AGYAZgBlAHIANgA0AAAATgBhAG4AaQB0AGUAXwBEAGIAZwBCAHUAZgBmAGUAcgA2ADQAAABOAGEAbgBpAHQAZQBfAEQAYgBnAEIAdQBmAGYAZQByADMAMgAAAE4AYQBuAGkAdABlAF8AUgBhAHkAVAByAGEAYwBpAG4AZwBEAGEAdABhAEIAdQBmAGYAZQByAAAATgBhAG4AaQB0AGUAXwBTAGgAYQBkAGkAbgBnAEIAaQBuAEQAYQB0AGEAAABOAGEAbgBpAHQAZQBfAE0AdQBsAHQAaQBWAGkAZQB3AEkAbgBkAGkAYwBlAHMAAABOAGEAbgBpAHQAZQBfAE0AdQBsAHQAaQBWAGkAZQB3AFIAZQBjAHQAUwBjAGEAbABlAE8AZgBmAHMAZQB0AHMAAABOAGEAbgBpAHQAZQBfAEkAbgBWAGkAZQB3AHMAAAARAAAATmFuaXRlUmF5VHJhY2luZwARAAAATmFuaXRlUmF5VHJhY2luZwA5A0YAAwAAAABoAAAATgBhAG4AaQB0AGUAUgBhAHkAVAByAGEAYwBpAG4AZwBfAEMAbAB1AHMAdABlAHIAUABhAGcAZQBEAGEAdABhAAAATgBhAG4AaQB0AGUAUgBhAHkAVAByAGEAYwBpAG4AZwBfAEgAaQBlAHIAYQByAGMAaAB5AEIAdQBmAGYAZQByAAAATgBhAG4AaQB0AGUAUgBhAHkAVAByAGEAYwBpAG4AZwBfAFIAYQB5AFQAcgBhAGMAaQBuAGcARABhAHQAYQBCAHUAZgBmAGUAcgAAABEAAABWaXJ0dWFsU2hhZG93TWFwABcAAABWaXJ0dWFsU2hhZG93TWFwVWJTbG90AAECoBkCAAAAAAUBAABWAGkAcgB0AHUAYQBsAFMAaABhAGQAbwB3AE0AYQBwAF8AUAByAG8AagBlAGMAdABpAG8AbgBEAGEAdABhAAAAVgBpAHIAdAB1AGEAbABTAGgAYQBkAG8AdwBNAGEAcABfAFAAYQBnAGUAVABhAGIAbABlAAAAVgBpAHIAdAB1AGEAbABTAGgAYQBkAG8AdwBNAGEAcABfAFAAYQBnAGUARgBsAGEAZwBzAAAAVgBpAHIAdAB1AGEAbABTAGgAYQBkAG8AdwBNAGEAcABfAFAAYQBnAGUAUgBlAGMAdABCAG8AdQBuAGQAcwAAAFYAaQByAHQAdQBhAGwAUwBoAGEAZABvAHcATQBhAHAAXwBQAGgAeQBzAGkAYwBhAGwAUABhAGcAZQBQAG8AbwBsAAAAVgBpAHIAdAB1AGEAbABTAGgAYQBkAG8AdwBNAGEAcABfAEMAYQBjAGgAZQBQAHIAaQBtAGkAdABpAHYAZQBBAHMARAB5AG4AYQBtAGkAYwAAAFYAaQByAHQAdQBhAGwAUwBoAGEAZABvAHcATQBhAHAAXwBMAGkAZwBoAHQARwByAGkAZABEAGEAdABhAAAAVgBpAHIAdAB1AGEAbABTAGgAYQBkAG8AdwBNAGEAcABfAE4AdQBtAEMAdQBsAGwAZQBkAEwAaQBnAGgAdABzAEcAcgBpAGQAAAAOAAAARGVmZXJyZWREZWNhbAAPAAAARGVmZXJyZWREZWNhbHMABAIgAAIAAAAAIgAAAEQAZQBmAGUAcgByAGUAZABEAGUAYwBhAGwAXwBQAHIAZQB2AGkAbwB1AHMARgByAGEAbQBlAE4AbwByAG0AYQBsAAAACwAAAEluc3RhbmNlVkYAAAAAAAYHNgYBAAAAAK0AAABJAG4AcwB0AGEAbgBjAGUAVgBGAF8AVgBlAHIAdABlAHgARgBlAHQAYwBoAF8ASQBuAHMAdABhAG4AYwBlAE8AcgBpAGcAaQBuAEIAdQBmAGYAZQByAAAASQBuAHMAdABhAG4AYwBlAFYARgBfAFYAZQByAHQAZQB4AEYAZQB0AGMAaABfAEkAbgBzAHQAYQBuAGMAZQBUAHIAYQBuAHMAZgBvAHIAbQBCAHUAZgBmAGUAcgAAAEkAbgBzAHQAYQBuAGMAZQBWAEYAXwBWAGUAcgB0AGUAeABGAGUAdABjAGgAXwBJAG4AcwB0AGEAbgBjAGUATABpAGcAaAB0AG0AYQBwAEIAdQBmAGYAZQByAAAASQBuAHMAdABhAG4AYwBlAFYARgBfAEkAbgBzAHQAYQBuAGMAZQBDAHUAcwB0AG8AbQBEAGEAdABhAEIAdQBmAGYAZQByAAAAGAAAAE1vYmlsZVJlZmxlY3Rpb25DYXB0dXJlAAAAAAAIBDgFAQAAAACYAAAATQBvAGIAaQBsAGUAUgBlAGYAbABlAGMAdABpAG8AbgBDAGEAcAB0AHUAcgBlAF8AVABlAHgAdAB1AHIAZQAAAE0AbwBiAGkAbABlAFIAZQBmAGwAZQBjAHQAaQBvAG4AQwBhAHAAdAB1AHIAZQBfAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAE0AbwBiAGkAbABlAFIAZQBmAGwAZQBjAHQAaQBvAG4AQwBhAHAAdAB1AHIAZQBfAFQAZQB4AHQAdQByAGUAQgBsAGUAbgBkAAAATQBvAGIAaQBsAGUAUgBlAGYAbABlAGMAdABpAG8AbgBDAGEAcAB0AHUAcgBlAF8AVABlAHgAdAB1AHIAZQBCAGwAZQBuAGQAUwBhAG0AcABsAGUAcgAAABAAAABQcmltaXRpdmVEaXRoZXIAAAAAAAABEAABAAAAAAAAAAAOAAAAUHJpbWl0aXZlRmFkZQAAAAAAAAEQAAEAAAAAAAAAABQAAABTY2VuZVRleHR1cmVzU3RydWN0AA4AAABTY2VuZVRleHR1cmVzAAgOcAkCAAAAABsCAABTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAFMAdAByAHUAYwB0AF8AUwBjAGUAbgBlAEMAbwBsAG8AcgBUAGUAeAB0AHUAcgBlAAAAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBTAHQAcgB1AGMAdABfAFMAYwBlAG4AZQBEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBTAGMAZQBuAGUAUABhAHIAdABpAGEAbABEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBHAEIAdQBmAGYAZQByAEEAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBHAEIAdQBmAGYAZQByAEIAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBHAEIAdQBmAGYAZQByAEMAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBHAEIAdQBmAGYAZQByAEQAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBHAEIAdQBmAGYAZQByAEUAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBHAEIAdQBmAGYAZQByAEYAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBHAEIAdQBmAGYAZQByAFYAZQBsAG8AYwBpAHQAeQBUAGUAeAB0AHUAcgBlAAAAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBTAHQAcgB1AGMAdABfAFMAYwByAGUAZQBuAFMAcABhAGMAZQBBAE8AVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBDAHUAcwB0AG8AbQBEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQAAAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAUwB0AHIAdQBjAHQAXwBDAHUAcwB0AG8AbQBTAHQAZQBuAGMAaQBsAFQAZQB4AHQAdQByAGUAAABTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAFMAdAByAHUAYwB0AF8AUABvAGkAbgB0AEMAbABhAG0AcABTAGEAbQBwAGwAZQByAAAAEQAAAFNpbmdsZUxheWVyV2F0ZXIADwAAAERlZmVycmVkRGVjYWxzACQLGQACAAAAACoCAABTAGkAbgBnAGwAZQBMAGEAeQBlAHIAVwBhAHQAZQByAF8AUwBjAGUAbgBlAEMAbwBsAG8AcgBXAGkAdABoAG8AdQB0AFMAaQBuAGcAbABlAEwAYQB5AGUAcgBXAGEAdABlAHIAVABlAHgAdAB1AHIAZQAAAFMAaQBuAGcAbABlAEwAYQB5AGUAcgBXAGEAdABlAHIAXwBTAGMAZQBuAGUAQwBvAGwAbwByAFcAaQB0AGgAbwB1AHQAUwBpAG4AZwBsAGUATABhAHkAZQByAFcAYQB0AGUAcgBTAGEAbQBwAGwAZQByAAAAUwBpAG4AZwBsAGUATABhAHkAZQByAFcAYQB0AGUAcgBfAFMAYwBlAG4AZQBEAGUAcAB0AGgAVwBpAHQAaABvAHUAdABTAGkAbgBnAGwAZQBMAGEAeQBlAHIAVwBhAHQAZQByAFQAZQB4AHQAdQByAGUAAABTAGkAbgBnAGwAZQBMAGEAeQBlAHIAVwBhAHQAZQByAF8AUwBjAGUAbgBlAEQAZQBwAHQAaABXAGkAdABoAG8AdQB0AFMAaQBuAGcAbABlAEwAYQB5AGUAcgBXAGEAdABlAHIAUwBhAG0AcABsAGUAcgAAAFMAaQBuAGcAbABlAEwAYQB5AGUAcgBXAGEAdABlAHIAXwBDAHUAcwB0AG8AbQBEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQAAAFMAaQBuAGcAbABlAEwAYQB5AGUAcgBXAGEAdABlAHIAXwBDAHUAcwB0AG8AbQBTAHQAZQBuAGMAaQBsAFQAZQB4AHQAdQByAGUAAABTAGkAbgBnAGwAZQBMAGEAeQBlAHIAVwBhAHQAZQByAF8AQwB1AHMAdABvAG0ARABlAHAAdABoAFMAYQBtAHAAbABlAHIAAABTAGkAbgBnAGwAZQBMAGEAeQBlAHIAVwBhAHQAZQByAF8ARgBvAHIAdwBhAHIAZABEAGkAcgBMAGkAZwBoAHQAQwBsAG8AdQBkAFMAaABhAGQAbwB3AF8AQwBsAG8AdQBkAFMAaABhAGQAbwB3AG0AYQBwAFQAZQB4AHQAdQByAGUAAABTAGkAbgBnAGwAZQBMAGEAeQBlAHIAVwBhAHQAZQByAF8ARgBvAHIAdwBhAHIAZABEAGkAcgBMAGkAZwBoAHQAQwBsAG8AdQBkAFMAaABhAGQAbwB3AF8AQwBsAG8AdQBkAFMAaABhAGQAbwB3AG0AYQBwAFMAYQBtAHAAbABlAHIAAABTAGkAbgBnAGwAZQBMAGEAeQBlAHIAVwBhAHQAZQByAF8AQgBsAHUAZQBOAG8AaQBzAGUAXwBTAGMAYQBsAGEAcgBUAGUAeAB0AHUAcgBlAAAAUwBpAG4AZwBsAGUATABhAHkAZQByAFcAYQB0AGUAcgBfAEIAbAB1AGUATgBvAGkAcwBlAF8AVgBlAGMAMgBUAGUAeAB0AHUAcgBlAAAAFAAAAE1vYmlsZVNjZW5lVGV4dHVyZXMADgAAAFNjZW5lVGV4dHVyZXMAyALQBQIAAAAAGgQAAE0AbwBiAGkAbABlAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBTAGMAZQBuAGUAQwBvAGwAbwByAFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAEMAbwBsAG8AcgBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAEQAZQBwAHQAaABUAGUAeAB0AHUAcgBlAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAFMAYwBlAG4AZQBEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQBBAHIAcgBhAHkAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAEQAZQBwAHQAaABUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAFAAYQByAHQAaQBhAGwARABlAHAAdABoAFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAFAAYQByAHQAaQBhAGwARABlAHAAdABoAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAE0AbwBiAGkAbABlAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBDAHUAcwB0AG8AbQBEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQAAAE0AbwBiAGkAbABlAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBDAHUAcwB0AG8AbQBEAGUAcAB0AGgAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAEMAdQBzAHQAbwBtAFMAdABlAG4AYwBpAGwAVABlAHgAdAB1AHIAZQAAAE0AbwBiAGkAbABlAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBTAGMAZQBuAGUAVgBlAGwAbwBjAGkAdAB5AFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAFYAZQBsAG8AYwBpAHQAeQBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ARwBCAHUAZgBmAGUAcgBBAFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ARwBCAHUAZgBmAGUAcgBCAFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ARwBCAHUAZgBmAGUAcgBDAFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ARwBCAHUAZgBmAGUAcgBEAFQAZQB4AHQAdQByAGUAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8AUwBjAGUAbgBlAEQAZQBwAHQAaABBAHUAeABUAGUAeAB0AHUAcgBlAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAFMAYwBlAG4AZQBEAGUAcAB0AGgAQQB1AHgAVABlAHgAdAB1AHIAZQBBAHIAcgBhAHkAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ATABvAGMAYQBsAEwAaQBnAGgAdABUAGUAeAB0AHUAcgBlAEEAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ATABvAGMAYQBsAEwAaQBnAGgAdABUAGUAeAB0AHUAcgBlAEIAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ARwBCAHUAZgBmAGUAcgBBAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAE0AbwBiAGkAbABlAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBHAEIAdQBmAGYAZQByAEIAVABlAHgAdAB1AHIAZQBTAGEAbQBwAGwAZQByAAAATQBvAGIAaQBsAGUAUwBjAGUAbgBlAFQAZQB4AHQAdQByAGUAcwBfAEcAQgB1AGYAZgBlAHIAQwBUAGUAeAB0AHUAcgBlAFMAYQBtAHAAbABlAHIAAABNAG8AYgBpAGwAZQBTAGMAZQBuAGUAVABlAHgAdAB1AHIAZQBzAF8ARwBCAHUAZgBmAGUAcgBEAFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAE0AbwBiAGkAbABlAFMAYwBlAG4AZQBUAGUAeAB0AHUAcgBlAHMAXwBTAGMAZQBuAGUARABlAHAAdABoAEEAdQB4AFQAZQB4AHQAdQByAGUAUwBhAG0AcABsAGUAcgAAAA4AAABTcGVlZFRyZWVEYXRhAAAAAAAAAWACAQAAAAAAAAAACwAAAEF0bW9zcGhlcmUAAAAAAAABsAABAAAAAAAAAAAKAAAAQmx1ZU5vaXNlAAAAAAANATUAAQAAAAAuAAAAQgBsAHUAZQBOAG8AaQBzAGUAXwBTAGMAYQBsAGEAcgBUAGUAeAB0AHUAcgBlAAAAQgBsAHUAZQBOAG8AaQBzAGUAXwBWAGUAYwAyAFQAZQB4AHQAdQByAGUAAAAJAAAAQmFzZVBhc3MAAAAAAFEWgQUBAAAAALwGAABCAGEAcwBlAFAAYQBzAHMAXwBGAG8AcgB3AGEAcgBkAF8ARABpAHIAZQBjAHQAaQBvAG4AYQBsAEwAaQBnAGgAdABTAGgAYQBkAG8AdwBtAGEAcABBAHQAbABhAHMAAABCAGEAcwBlAFAAYQBzAHMAXwBGAG8AcgB3AGEAcgBkAF8AUwBoAGEAZABvAHcAbQBhAHAAUwBhAG0AcABsAGUAcgAAAEIAYQBzAGUAUABhAHMAcwBfAEYAbwByAHcAYQByAGQAXwBEAGkAcgBlAGMAdABpAG8AbgBhAGwATABpAGcAaAB0AFMAdABhAHQAaQBjAFMAaABhAGQAbwB3AG0AYQBwAAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAHIAdwBhAHIAZABfAFMAdABhAHQAaQBjAFMAaABhAGQAbwB3AG0AYQBwAFMAYQBtAHAAbABlAHIAAABCAGEAcwBlAFAAYQBzAHMAXwBGAG8AcgB3AGEAcgBkAF8ARgBvAHIAdwBhAHIAZABMAG8AYwBhAGwATABpAGcAaAB0AEIAdQBmAGYAZQByAAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAHIAdwBhAHIAZABfAE4AdQBtAEMAdQBsAGwAZQBkAEwAaQBnAGgAdABzAEcAcgBpAGQAAABCAGEAcwBlAFAAYQBzAHMAXwBGAG8AcgB3AGEAcgBkAF8AQwB1AGwAbABlAGQATABpAGcAaAB0AEQAYQB0AGEARwByAGkAZAAzADIAQgBpAHQAAABCAGEAcwBlAFAAYQBzAHMAXwBGAG8AcgB3AGEAcgBkAF8AQwB1AGwAbABlAGQATABpAGcAaAB0AEQAYQB0AGEARwByAGkAZAAxADYAQgBpAHQAAABCAGEAcwBlAFAAYQBzAHMAXwBGAG8AcgB3AGEAcgBkAEkAUwBSAF8ARABpAHIAZQBjAHQAaQBvAG4AYQBsAEwAaQBnAGgAdABTAGgAYQBkAG8AdwBtAGEAcABBAHQAbABhAHMAAABCAGEAcwBlAFAAYQBzAHMAXwBGAG8AcgB3AGEAcgBkAEkAUwBSAF8AUwBoAGEAZABvAHcAbQBhAHAAUwBhAG0AcABsAGUAcgAAAEIAYQBzAGUAUABhAHMAcwBfAEYAbwByAHcAYQByAGQASQBTAFIAXwBEAGkAcgBlAGMAdABpAG8AbgBhAGwATABpAGcAaAB0AFMAdABhAHQAaQBjAFMAaABhAGQAbwB3AG0AYQBwAAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAHIAdwBhAHIAZABJAFMAUgBfAFMAdABhAHQAaQBjAFMAaABhAGQAbwB3AG0AYQBwAFMAYQBtAHAAbABlAHIAAABCAGEAcwBlAFAAYQBzAHMAXwBGAG8AcgB3AGEAcgBkAEkAUwBSAF8ARgBvAHIAdwBhAHIAZABMAG8AYwBhAGwATABpAGcAaAB0AEIAdQBmAGYAZQByAAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAHIAdwBhAHIAZABJAFMAUgBfAE4AdQBtAEMAdQBsAGwAZQBkAEwAaQBnAGgAdABzAEcAcgBpAGQAAABCAGEAcwBlAFAAYQBzAHMAXwBGAG8AcgB3AGEAcgBkAEkAUwBSAF8AQwB1AGwAbABlAGQATABpAGcAaAB0AEQAYQB0AGEARwByAGkAZAAzADIAQgBpAHQAAABCAGEAcwBlAFAAYQBzAHMAXwBGAG8AcgB3AGEAcgBkAEkAUwBSAF8AQwB1AGwAbABlAGQATABpAGcAaAB0AEQAYQB0AGEARwByAGkAZAAxADYAQgBpAHQAAABCAGEAcwBlAFAAYQBzAHMAXwBSAGUAZgBsAGUAYwB0AGkAbwBuAF8AUwBrAHkATABpAGcAaAB0AEMAdQBiAGUAbQBhAHAAAABCAGEAcwBlAFAAYQBzAHMAXwBSAGUAZgBsAGUAYwB0AGkAbwBuAF8AUwBrAHkATABpAGcAaAB0AEMAdQBiAGUAbQBhAHAAUwBhAG0AcABsAGUAcgAAAEIAYQBzAGUAUABhAHMAcwBfAFIAZQBmAGwAZQBjAHQAaQBvAG4AXwBTAGsAeQBMAGkAZwBoAHQAQgBsAGUAbgBkAEQAZQBzAHQAaQBuAGEAdABpAG8AbgBDAHUAYgBlAG0AYQBwAAAAQgBhAHMAZQBQAGEAcwBzAF8AUgBlAGYAbABlAGMAdABpAG8AbgBfAFMAawB5AEwAaQBnAGgAdABCAGwAZQBuAGQARABlAHMAdABpAG4AYQB0AGkAbwBuAEMAdQBiAGUAbQBhAHAAUwBhAG0AcABsAGUAcgAAAEIAYQBzAGUAUABhAHMAcwBfAFIAZQBmAGwAZQBjAHQAaQBvAG4AXwBSAGUAZgBsAGUAYwB0AGkAbwBuAEMAdQBiAGUAbQBhAHAAAABCAGEAcwBlAFAAYQBzAHMAXwBSAGUAZgBsAGUAYwB0AGkAbwBuAF8AUgBlAGYAbABlAGMAdABpAG8AbgBDAHUAYgBlAG0AYQBwAFMAYQBtAHAAbABlAHIAAABCAGEAcwBlAFAAYQBzAHMAXwBSAGUAZgBsAGUAYwB0AGkAbwBuAF8AUAByAGUASQBuAHQAZQBnAHIAYQB0AGUAZABHAEYAAABCAGEAcwBlAFAAYQBzAHMAXwBSAGUAZgBsAGUAYwB0AGkAbwBuAF8AUAByAGUASQBuAHQAZQBnAHIAYQB0AGUAZABHAEYAUwBhAG0AcABsAGUAcgAAAEIAYQBzAGUAUABhAHMAcwBfAFAAbABhAG4AYQByAFIAZQBmAGwAZQBjAHQAaQBvAG4AXwBQAGwAYQBuAGEAcgBSAGUAZgBsAGUAYwB0AGkAbwBuAFQAZQB4AHQAdQByAGUAAABCAGEAcwBlAFAAYQBzAHMAXwBQAGwAYQBuAGEAcgBSAGUAZgBsAGUAYwB0AGkAbwBuAF8AUABsAGEAbgBhAHIAUgBlAGYAbABlAGMAdABpAG8AbgBTAGEAbQBwAGwAZQByAAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAGcAXwBGAG8AZwBJAG4AcwBjAGEAdAB0AGUAcgBpAG4AZwBDAG8AbABvAHIAQwB1AGIAZQBtAGEAcAAAAEIAYQBzAGUAUABhAHMAcwBfAEYAbwBnAF8ARgBvAGcASQBuAHMAYwBhAHQAdABlAHIAaQBuAGcAQwBvAGwAbwByAFMAYQBtAHAAbABlAHIAAABCAGEAcwBlAFAAYQBzAHMAXwBGAG8AZwBfAEkAbgB0AGUAZwByAGEAdABlAGQATABpAGcAaAB0AFMAYwBhAHQAdABlAHIAaQBuAGcAAABCAGEAcwBlAFAAYQBzAHMAXwBGAG8AZwBfAEkAbgB0AGUAZwByAGEAdABlAGQATABpAGcAaAB0AFMAYwBhAHQAdABlAHIAaQBuAGcAUwBhAG0AcABsAGUAcgAAAEIAYQBzAGUAUABhAHMAcwBfAEYAbwBnAEkAUwBSAF8ARgBvAGcASQBuAHMAYwBhAHQAdABlAHIAaQBuAGcAQwBvAGwAbwByAEMAdQBiAGUAbQBhAHAAAABCAGEAcwBlAFAAYQBzAHMAXwBGAG8AZwBJAFMAUgBfAEYAbwBnAEkAbgBzAGMAYQB0AHQAZQByAGkAbgBnAEMAbwBsAG8AcgBTAGEAbQBwAGwAZQByAAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAGcASQBTAFIAXwBJAG4AdABlAGcAcgBhAHQAZQBkAEwAaQBnAGgAdABTAGMAYQB0AHQAZQByAGkAbgBnAAAAQgBhAHMAZQBQAGEAcwBzAF8ARgBvAGcASQBTAFIAXwBJAG4AdABlAGcAcgBhAHQAZQBkAEwAaQBnAGgAdABTAGMAYQB0AHQAZQByAGkAbgBnAFMAYQBtAHAAbABlAHIAAABCAGEAcwBlAFAAYQBzAHMAXwBMAEYAVgBfAEwAbwBjAGEAbABGAG8AZwBWAG8AbAB1AG0AZQBJAG4AcwB0AGEAbgBjAGUAcwAAAEIAYQBzAGUAUABhAHMAcwBfAEwARgBWAF8ATABvAGMAYQBsAEYAbwBnAFYAbwBsAHUAbQBlAFQAaQBsAGUARABhAHQAYQBUAGUAeAB0AHUAcgBlAAAAQgBhAHMAZQBQAGEAcwBzAF8ATABpAGcAaAB0AEYAdQBuAGMAdABpAG8AbgBBAHQAbABhAHMAXwBMAGkAZwBoAHQARgB1AG4AYwB0AGkAbwBuAEEAdABsAGEAcwBUAGUAeAB0AHUAcgBlAAAAQgBhAHMAZQBQAGEAcwBzAF8ATABpAGcAaAB0AEYAdQBuAGMAdABpAG8AbgBBAHQAbABhAHMAXwBMAGkAZwBoAHQASQBuAGYAbwBEAGEAdABhAEIAdQBmAGYAZQByAAAAQgBhAHMAZQBQAGEAcwBzAF8ATABpAGcAaAB0AEYAdQBuAGMAdABpAG8AbgBBAHQAbABhAHMAXwBMAGkAZwBoAHQARgB1AG4AYwB0AGkAbwBuAEEAdABsAGEAcwBTAGEAbQBwAGwAZQByAAAAGgAAAFByZWNvbXB1dGVkTGlnaHRpbmdCdWZmZXIAAAAAAAAB8AABAAAAAAAAAAAQAAAAU2hhZGVyUHJpbnREYXRhAAAAAAAAAVAAAQAAAAAAAAAACQAAAE1hdGVyaWFsAAAAAAAICZgEAQAAAADGAgAATQBhAHQAZQByAGkAYQBsAF8AVABlAHgAdAB1AHIAZQAyAEQAXwAwAAAATQBhAHQAZQByAGkAYQBsAF8AVABlAHgAdAB1AHIAZQAyAEQAXwAwAFMAYQBtAHAAbABlAHIAAABNAGEAdABlAHIAaQBhAGwAXwBUAGUAeAB0AHUAcgBlADIARABfADEAAABNAGEAdABlAHIAaQBhAGwAXwBUAGUAeAB0AHUAcgBlADIARABfADEAUwBhAG0AcABsAGUAcgAAAE0AYQB0AGUAcgBpAGEAbABfAFQAZQB4AHQAdQByAGUAMgBEAF8AMgAAAE0AYQB0AGUAcgBpAGEAbABfAFQAZQB4AHQAdQByAGUAMgBEAF8AMgBTAGEAbQBwAGwAZQByAAAATQBhAHQAZQByAGkAYQBsAF8AVABlAHgAdAB1AHIAZQAyAEQAXwAzAAAATQBhAHQAZQByAGkAYQBsAF8AVABlAHgAdAB1AHIAZQAyAEQAXwAzAFMAYQBtAHAAbABlAHIAAABNAGEAdABlAHIAaQBhAGwAXwBUAGUAeAB0AHUAcgBlADIARABfADQAAABNAGEAdABlAHIAaQBhAGwAXwBUAGUAeAB0AHUAcgBlADIARABfADQAUwBhAG0AcABsAGUAcgAAAE0AYQB0AGUAcgBpAGEAbABfAFQAZQB4AHQAdQByAGUAMgBEAF8ANQAAAE0AYQB0AGUAcgBpAGEAbABfAFQAZQB4AHQAdQByAGUAMgBEAF8ANQBTAGEAbQBwAGwAZQByAAAATQBhAHQAZQByAGkAYQBsAF8AVABlAHgAdAB1AHIAZQAyAEQAXwA2AAAATQBhAHQAZQByAGkAYQBsAF8AVABlAHgAdAB1AHIAZQAyAEQAXwA2AFMAYQBtAHAAbABlAHIAAABNAGEAdABlAHIAaQBhAGwAXwBUAGUAeAB0AHUAcgBlADIARABfADcAAABNAGEAdABlAHIAaQBhAGwAXwBUAGUAeAB0AHUAcgBlADIARABfADcAUwBhAG0AcABsAGUAcgAAAE0AYQB0AGUAcgBpAGEAbABfAFQAZQB4AHQAdQByAGUAMgBEAF8AOAAAAE0AYQB0AGUAcgBpAGEAbABfAFQAZQB4AHQAdQByAGUAMgBEAF8AOABTAGEAbQBwAGwAZQByAAAATQBhAHQAZQByAGkAYQBsAF8AVABlAHgAdAB1AHIAZQAyAEQAXwA5AAAATQBhAHQAZQByAGkAYQBsAF8AVABlAHgAdAB1AHIAZQAyAEQAXwA5AFMAYQBtAHAAbABlAHIAAABNAGEAdABlAHIAaQBhAGwAXwBUAGUAeAB0AHUAcgBlADIARABfADEAMAAAAE0AYQB0AGUAcgBpAGEAbABfAFQAZQB4AHQAdQByAGUAMgBEAF8AMQAwAFMAYQBtAHAAbABlAHIAAABNAGEAdABlAHIAaQBhAGwAXwBUAGUAeAB0AHUAcgBlADIARABfADEAMQAAAE0AYQB0AGUAcgBpAGEAbABfAFQAZQB4AHQAdQByAGUAMgBEAF8AMQAxAFMAYQBtAHAAbABlAHIAAABNAGEAdABlAHIAaQBhAGwAXwBUAGUAeAB0AHUAcgBlADIARABfADEAMgAAAE0AYQB0AGUAcgBpAGEAbABfAFQAZQB4AHQAdQByAGUAMgBEAF8AMQAyAFMAYQBtAHAAbABlAHIAAABNAGEAdABlAHIAaQBhAGwAXwBXAHIAYQBwAF8AVwBvAHIAbABkAEcAcgBvAHUAcABTAGUAdAB0AGkAbgBnAHMAAABNAGEAdABlAHIAaQBhAGwAXwBDAGwAYQBtAHAAXwBXAG8AcgBsAGQARwByAG8AdQBwAFMAZQB0AHQAaQBuAGcAcwAAAAAAAAA=
BASE64_ENV */
/* DIRECT COMPILE
-directcompile -format=PCD3D_SM6 -entry="MicropolyRasterize" -shaderPlatformName=PCD3D_SM6 -supportedHardwareMask=0 -cs C:/Users/cajv.paris/Documents/GitHub/Ruins/Ruins/Saved/ShaderDebugInfo/PCD3D_SM6/MM_LandScape_Desert_1b7a6bb3a09de46a/Default/FMicropolyRasterizeCS/221/NaniteRasterizer.usf -nocrashreports
DIRECT COMPILE */
